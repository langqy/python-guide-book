% !Mode:: "TeX:UTF-8"%確保文檔utf-8編碼
%新加入的命令如下：addchtoc addsectoc reduline showendnotes hlabel
%新加入的环境如下：common-format  fig  xverbatim

\documentclass[12pt,oneside]{book}
\newlength{\textpt}
\setlength{\textpt}{12pt}


\usepackage{myconfig}
\usepackage{mytitle}



\begin{document}
\frontmatter

\titlea{python3指南}
\titleb{用python3玩转电脑}
\author{万泽}
\authorinfo{作者：}
\editor{德山书生}
\email{a358003542@gmail.com}
\editorinfo{编者：}
\version{0.01}
\titleLB

\addchtoc{前言}
\chapter*{前言}
\begin{common-format}
xverbatim环境目前不能进行交互，如果终端交互又不支持pdf的结果输出了。决定新加入一个模式，1显示代码3用geany打开代码。后面就用编辑器调试吧。
这里因为涉及到交互，看了一下tee命令，似乎使用“python3 test.py | tee test.py.out”这样的命令应该是可行的，但是可惜要某调用gnome-terminal就不能生成文件，要某不调用texmaker本身就弹不出对话框。现在只好设置一个简单的13模式，所谓3实际上非常的简单，就是用geany打开那个代码，因为geany编辑器调整好倒也方便，只是遇到这种交互程序的生成结果需要手动复制了。


需要提醒的是在本文档中不管是xverbatim环境生成的code文件还是cverbatim环境，最前面都多了一个空行，因为最前面有一个newlinechar符号最后转变成换行了，我还不知道如何避免，所以，如果你需要将代码文件以可执行模式执行（以脚本文件模式载入的没有问题），你需要进入文件按一下Backspace键将第一行消去即可。

主要参考资料：

1.python入门教程 Python 教學文件 作者：Guido van Rossum  Fred L. Drake

2.A Comprehensive Introduction to Python Programming and\\ GUI Design Using Tkinter 作者：Bruno Dufour

3.Python and Tkinter Programming  JOHN E. G RAYSON

4.learning python v5  主要python语言参考   python学习手册（第四版） 老鼠版（略过：23，24，30，31，异常和工具，高级话题，）

5.programming python v4 蟒蛇版

6.python官网其他参考资料（遇到问题则google之，这部分不会专门学习）

7.tkinter官方文档

8.pyqt4 tutorial \href{http://zetcode.com/gui/pyqt4/}{英文网站} 也参考了jimmykuu的中文翻译，\href{http://blog.cx125.com/books/PyQt4_Tutorial/}{中文翻译网站}



%这里空一行。

\end{common-format}


\addchtoc{目录}
\setcounter{tocdepth}{2}
\tableofcontents

\begin{common-format}
\mainmatter

\part{python3基础}

\chapter{beginning}
\section{python简介}
Python是个成功的脚本语言。它最初由Guido van Rossum开发，\sidenote{这是一段测试文字}在1991年第一次发布。Python由ABC和Haskell语言所启发。Python是一个高级的、通用的、跨平台、解释型的语言。一些人更倾向于称之为动态语言。它很易学，Python是一种简约的语言。它的最明显的一个特征是，不使用分号或括号，Python使用缩进。现在，Python由来自世界各地的庞大的志愿者维护。

python现在主要有两个版本区别，python2和python3。作为新学者推荐完全使用python3编程，本文档完全基于python3。

完全没有编程经验的人推荐简单学一下c语言和scheme语言（就简单学习一下这个语言的基本概念即可）。相信我学习这两门语言不会浪费你任何时间，其中scheme语言如果你学得深入的话甚至编译器的基本原理你都能够学到。了解了这两门语言的核心理念，基本上任何语言在你看来都大同小异了。

\section{进入python的REPL环境}
在ubuntu13.10下终端中输入python即进入python语言的REPL环境，目前默认的是python2。你可以运行：\\
\verb+python  --version+\\
来查看。要进入python3在终端中输入python3即可。


\section{python3命令行用法}
命令行的一般格式就是：\\
\verb+python3  [可选项]  test.py  [可选参数1 可选参数2]+

同样类似的运行\verb+python3  --help+即可以查看python3命令的一些可选项。比如加入\textbf{-i}选项之后，python执行完脚本之后会进入REPL环境继续等待下一个命令，这个在最后结果一闪而过的时候有用。后面的-c，-m选项还看不明白。

\subsection{python执行脚本参数的传递}
上面的命令行接受多个参数都没有问题的，不会报错，哪怕你在py文件并没有用到他们。在py文件中要使用他们，首先导入sys宏包，然后sys.argv[0]是现在这个py文件在系统中的文件名，接下来的sys.argv[1]就是之前命令行接受的第一个参数，后面的就依次类推了。


\section{geany的相关配置}
geany的其他配置这里不做过多说明，就自动执行命令默认的应该是python2，修改成为：\\
\verb+python3  -i  %f  +\\
即可。


\section{代码注释}
python语言的注释符号和bash语言（linux终端的编程语言）一样用的是\#{}符号来注释代码。然后py文件开头一般如下面代码所示：
\begin{Verbatim}
#!/usr/bin/env python3
#-*-coding:utf-8-*-
\end{Verbatim}
其中代码第一行表示等下如果py文件可执行模式执行那么将用python3来编译\footnote{也就是用chmod加上可执行权限那么可以直接执行了。第一行完整的解释是什么通过\textit{env}程序来搜索python的路径，这样代码更具可移植性。}，第二行的意思是py文件编码是utf-8编码的，python3直接支持utf-8各个符号，这是很强大的一个更新。


多行注释可以利用编辑器快速每行前面加上\#{}符号。

\section{Unicode码支持}
前面谈及python3是可以直接支持Unicode码的，如果以可执行模式加载，那么第二行需要写上：\\
\verb+#-*-coding:utf-8-*-+\\
这么一句。

\begin{Verbatim}
#!/usr/bin/env python3
#-*-coding:utf-8-*-
print('\u2460')
\end{Verbatim}
上面的数字是具体这个Unicode符号的十六进制。

\section{代码多行表示一行}
这个技巧防止代码越界所以经常会用到。用反斜线\textbackslash 即可。不过通常更常用的是将表达式用圆括号( )括起来，这样内部可以直接换行并继续。在python中任何表达式都可以包围在圆括号中。

\subsection{一行表示多行}
python中一般不用分号，但是分号的意义大致和bash或者c语言中的意义类似，表示一行结束的意思。其中c语言我们知道是必须使用分号的。


\section{输入和输出}
\subsection{最基本的input和print命令}
input函数请求用户输入，并将这个值赋值给某个变量。注意赋值之后类型是字符串，但后面你可以用强制类型转换——int函数（变成整数），float函数（变成实数），str函数（变成字符串）——将其转变过来。print函数就是一般的输出函数。

\begin{Verbatim}
x=input('请输入一个实数：')
string001='你输入的这个实数乘以2等于：'+ str(float(x)*2)
print(string001)
\end{Verbatim}





\chapter{程序中的逻辑}
\section{条件判断}
python中的条件语句基本格式如下：
\begin{Verbatim}
if  test:
    条件判断执行区块
\end{Verbatim}
也就是if命令后面跟个条件判断语句，然后记住加个冒号，然后后面缩进的区块都是条件判断为真的时候要执行的语句。

\begin{Verbatim}
if  test:
    do something001
else :
    do something002
\end{Verbatim}
这里的逻辑是条件判断，如果真，do something001；如果假，do something002。

\begin{Verbatim}
if  test001:
    do something001
elif test002:
    do something002
\end{Verbatim}
显然你一看就明白了，elif是else和if的结合。






\subsection{逻辑与或否}
and表示逻辑与，or表示逻辑或，not表示逻辑否。

下面编写一个逻辑，判断一个字符串，这个字符串开头必须是a或者b，结尾必须是s，倒数第二个字符不能是单引号'。在这里就演示一下逻辑。。
\begin{xverbatim}[129]{py}
x='agais'
if ((x[0] == 'a' or x[0] == 'b')
    and x[-1] =='s'
    and (not x[-2] =="'")):
    print('yes it is..')
\end{xverbatim}
上面的显示效果是xverbatim环境input之后的问题，目前主要的问题就是新的一行前面的空格无法显示，想了一些方法都不行，只好作罢。


\subsection{稍复杂的条件判断}
现在我们了解了if，elif和else语句，然后还了解了逻辑与或非的组合判断。那么在实际编程中如何处理复杂的条件逻辑呢？

首先能够用逻辑语句与或非组合起来的就将其组合起来，而不要过分使用嵌套。然后让我们看下面几个小代码： 
\begin{tcbpython}[]
x=-2
if x>0:
    print('x大于0')
else:
    print('x小于0')
\end{tcbpython}

\begin{tcbpython}
x=2
if x>0:
    print('x大于0')
elif x<0:
    print('x小于0')
else:
    print('x等于0')
\end{tcbpython}

\begin{tcbpython}
x=2
if x>0:
    print('x大于0')
if x<0:
    print('x小于0')
else:
    print('x等于0')
\end{tcbpython}

%警告，自动编号会因为本章前面加入tcbcode环境而被破坏。
如tcbcode-\ref{tcbcode-2.1}所示，如果一个情况分成两部分，那么就用if...eles...语句，而如果一个情况分成三部分，那么就用if...elif...else语句（如tcbcode-\ref{tcbcode-2.2}）。同一深度的这些平行语句对应的是“或”逻辑，或者说类似其他编程语言的switch语句。我们再看一看tcbcode-\ref{tcbcode-2.3}，这个代码是\emph{错误的}，两个if语句彼此并不构成逻辑分析关系。\footnote{四个甚至更多的平行或逻辑就用更多的elif，读者请自己实验一下。}

\begin{tcbpython}
x=-2
if x>0:
    print('x大于0')
    if x>2:
        print('x>2')
    elif x<2:
        print('0<x<2')
    else:
        print('x=2')
elif x<0:
    print('x小于0')
else:
    print('x等于0')
\end{tcbpython}

然后我们看到上面的最后一个代码tcbcode-\ref{tcbcode-2.4}，这个例子演示的是在加深一个深度个条件判断语句它当时处于的逻辑判断情况，这个语句的条件判断逻辑是本语句的判断逻辑再和左边（也就是前面）的深度的判断逻辑的“与”逻辑，或者说成是“交集”。比如说\textit{print('0<x<2')}这个语句就是本语句的判断逻辑x<2和上一层判断逻辑x>0的“交集”，也就是0<x<2。

整个过程的情况如下图所示：
\begin{linefig}{复杂条件判断}
\caption{复杂条件判断}
\label{fig:复杂条件判断}
\end{linefig}
为了在编程的时候对处于何种判断逻辑之下有一个清晰的认识，强烈建议读者好好思考一下。毕竟磨刀不误砍柴功。


\subsection{其他逻辑小知识}
在python中，有些关于逻辑真假上的小知识，需要简单了解下。
\begin{itemize}
\item 数0、空对象或者其他特殊对象None值都认为是假
\item 其他非零的数字或非空的对象都认为是真
\item 前面两条用bool函数可以进行强制类型转换
\item 比较和相等测试会递归作用在数据结构中
\item 比较和相等测试会返回True或False（1和0的custom version（翻译为定制版？））
\end{itemize}


\subsection{try语句捕捉错误}
try语句是编程中用来处理可能出现的错误或者已经出现但并不打算应付的错误最通用的方式。比如一个变量你预先想的是接受一个数值，但是用户却输入了一个字符，这个时候你就可以将这段语句包围在try里面；或者有时你在编程的时候就发现了这种情况，只是懒得理会他们，那么简单的把这块出错的语句包围在try里面，然后后面跟个except语句，打印出一个信息“出错了”，即可。用法如下所示：
\begin{tcbpython}
while True:
    x=input('请输入一个数，将返回它除以2之后的数值\n输入"quit"退出\n')
    if x=='quit':
        break
    try :
        num=float(x)
        print(num/2)
    except:
        print('出错了')
\end{tcbpython}






\subsection{in语句}
\begin{Verbatim}
>>> 'a' in ['a',1,2]
True
>>> dict
{'a': 1, 'c': 2, 'b': 3, 'd': 4}
>>> 'e' in dict
False
>>> '2' in dict
False
\end{Verbatim}
从上面例子可以看到，一般的列表判断元素是否存在和我们之前预料的一致，关于字典需要说的就是in语句\uwave{只判断键}，不判断值。






\section{迭代}
一般有内部重复操作的程序可以先考虑for迭代结构实现，实在不行才考虑while循环结构，毕竟简单更美更安全。

python的for迭代语句有点类似lisp语言的dolist和dotimes函数，具体例子如下：
\begin{xverbatim}[129]{py}
for x in 'abc':
    print(x)
\end{xverbatim}
in后面跟的是\textbf{序列}类型，也就是字符串，列表，数组都是可以的。这个语句可以看作先执行x='a'，然后执行缩进的区块，后面依次类推。

如果缩进区块中有对原列表进行的操作，为了避免逻辑混乱，之前in的列表应该是之前的列表，也就是你需要制造一个之前的列表的复制品，用\verb+list[:]+这样的形式就能达到这个目的。

\subsection{range函数}
range函数是为for迭代语句准备的，有点类似于lisp的dotimes函数，但是功能更全更接近common-lisp的loop宏了。

\verb+range(1,10,2)+\\
range函数的用法如上，表示从1开始到10，步长为2，如果用list函数将其包裹，将会输出[1,3,5,7,9]。如果不考虑步长的话，这个range函数就有点类似于在序列连着来那一小节\ref{sec:序列连着来}谈论的区间的情况。所以range(10)就可以看作[0,10)，range(1,10)就可以看作[1,10)。但是在这里再加上步长的概念和区间的概念又有所不同了，range函数产生的是一个什么迭代器对象，目前我只知道这个对象和之前谈论的序列对象是不同的。

\begin{xverbatim}[129]{py}
for x in range(-10,-20,-3):
    print(x)
\end{xverbatim}
上面例子还演示了range的负数概念，这里如果用区间概念来考察的话，是不能理解的，之所以行得通，是因为它的步长是负数，如果不是负数，那么情况就会和之前讨论的结果类似，将是一个空值。


\subsection{迭代加上操作}
迭代产生信息流并经过某些操作之后生成目标序列：
\begin{Verbatim}
squares=[x**2 for x in [1,2,3,4,5]]
squares
\end{Verbatim}







\section{循环}
while语句用法和大多数编程语言类似，就是条件控制，循环结构。
\begin{Verbatim}
while test:
    do something
\end{Verbatim}

\subsection{break命令}
break跳出最近的while或者for循环结构。

\subsection{continue命令}
continue命令接下来的循环结构的执行区块将不执行了，跳到条件判断那里看看是不是继续循环。如果是，那么继续循环。

\subsection{循环结构中的else命令}
循环结构（for语句和while语句）最后还可以有一个else字句，表示循环执行完了（for是执行完了，while是条件为假时也相当于执行完了。）将执行这个语句。

如果break跳出语句，那么最后的else字句将不执行，说明else字句是平行于该循环结构的语句。

\subsection{pass命令}
pass命令就是什么都不做。pass命令即可用于循环语句也可用于条件语句，其中有些条件语句有的时候是需要什么都不做。





\chapter{程序中的操作对象}
python和c语言不同，c 是什么\verb+int x = 3+ ，也就是这个变量是整数啊，字符啊什么的都要明确指定，python不需要这样做，只需要声明\verb+x ＝ 3+即可。但是我们知道任何程序语言它到最后必然要明确某一个变量（这里也包括后面的更加复杂的各个结构对象）的内存分配，只是python语言帮我们将这些工作做了，所以就让我们省下这份心吧。

\begin{Verbatim}
''' 这是一个多行注释
    你可以在这里写上很多废话
    '''
x = 10
print(x,type(x))
\end{Verbatim}

python程序由各个模块（modules）组成，模块就是各个文件。模块由声明（statements）组成，声明由表达式（expressions）组成，表达式负责创造和操作对象（objects）。在python中一切皆对象。python语言内置对象（数值、字符串、列表、数组、字典、文件、集合、其他内置对象。）后面会详细说明之。


\section{赋值}
python中的赋值语法非常的简单，x=1，就是一个赋值语句了。和c语言不同，c是必须先声明int x之类，开辟一个内存空间，然后才能给这个x赋值。而python的x=1语句实际上至少完成了三个工作：一，判断1的类型（动态类型语言必须要这步）；二，把这个类型的对象存储在内存里面；三，创建x这个名字和这个名字指向这个内存，x似乎可以称之为对应c语言的指针对象。

\subsection{序列赋值}
\begin{Verbatim}
x,y=1,'a'
[z,w]=['b',10]
print(x,y,z,w)
\end{Verbatim}

我们记得python中表达式可以加上圆括号，所以这里\verb+x,y+产生的是一个数组\verb+(x,y)+，然后是对应的数组平行赋值，第二行是列表的平行赋值。这是一个很有用的技巧。

\subsection{同时赋相同的值}
\begin{Verbatim}
x=y='a'
z=w=2
print(x,y,z,w)
\end{Verbatim}
这种语句形式c语言里面也有，不过内部实现机制就非常的不一样了。python当声明x=y的时候，x和y是相同的指针值，然后相同的指针值都指向了'a'这个字符串对象，也可以说x和y就是一个东西，只是取的名字不同罢了。

但如果写成这种形式：
\begin{Verbatim}
x=1
y=1
\end{Verbatim}
那么x和y还是指向的同一个对象，甚至是同一内存区块吗？如果是的话，那我对python内部如何处理的实现了这样的效果很感兴趣了。


\subsection{增强赋值语句}
x=x+y可以写作x += y。类似的还有：
\begin{tabular}{|c|c|c|}
\hline 
+= & \&{}= & >>= \\ 
\hline 
-= & |= & <<= \\ 
\hline 
*= & \^{}= & **= \\ 
\hline 
/= & \%{}= & //= \\ 
\hline 
\end{tabular} 




\section{数值}
python的数值的内置类型有：int，float，complex等\footnote{这些int、float等命令都是强制类型转换命令}。\\python的基本算术运算操作有加减乘除（+ - * /）。然后‘=’表示赋值，类似数学书上的中缀表达式和优先级和括号法则等，这些都是一般编程语言说到烂的东西了。

\begin{Verbatim}
print((1+2)*(10-5)/2)
print(2**100)
\end{Verbatim}

\subsection{二进制八进制十六进制}
二进制的数字以0b（零比）开头，八进制的数字以0o（零哦）开头，十六进制的数字以0x（零艾克斯）开头。
\begin{Verbatim}
0b101010, 0o177, 0x9ff
\end{Verbatim}

以二进制格式查看数字使用bin命令，以十六进制查看数字使用hex命令。
\begin{Verbatim}
>>> bin(42)
'0b101010'
>>> hex(42)
'0x2a'
\end{Verbatim}




\subsection{数学幂方运算}
$ x^y $，x的y次方如上面第二行所述就是用\verb+x**y+这样的形式即可。此外pow函数作用是一样的，\verb+pow(x,y)+。


\subsection{数值比较}
数值比较除了之前提及的>，<，==之外，>=，<=，!=也是有的（大于等于，小于等于，不等于）。此外python还支持连续比较，就是数学格式$a<x<b$，x在区间$(a,b)$的判断。在python中可以直接写成如下形式：\verb+a<x<b+。这实际实现的过程就是两个比较操作的进一步与操作。

\subsection{相除取整}
就作为正整数相除使用\verb+x//y+得到的值意义还是很明显的就是商。带上负号感觉有点怪了，这里先略过。相关的还有取余数，就是\verb+x%y+，这样就得到x除以y之后的余数了，同样带上负号情况有变，这里先略过。



\subsection{复数}
python直接支持复数， 复数的写法是类似\verb|1+2j|这样的形式，然后如果z被赋值了一个复数，这样它就是一个复数类型，那么这个类具有两个属性量，\textbf{real}和\textbf{imag}。也就是使用\verb+z.real+就给出这个复数的实数部。imag是imaginary number的缩写，虚数，想像出来的数。

\subsection{abs函数}
大家都知道abs函数是绝对值函数，这个python自带的，不需要加载什么宏包。作用于复数也是可以的：
\begin{Verbatim}
z=3+4j
print(z.real,z.imag)
print(abs(z))
\end{Verbatim}

这个和数学中复数绝对值的定义完全一致，也就是复数的模：\\
$ \left| z \right| =\sqrt { a^{ 2 }+b^{ 2 } }  $

\subsection{round函数}
简单的理解就是这个函数实现了对数值的四舍五入功能，第二个参数默认是0，即保留零位小数的意思。
\begin{Verbatim}
>>> round(3.1415926,0)
3.0
>>> round(3.1415926,1)
3.1
>>> round(3.1415926,2)
3.14
>>> round(3.1415926,3)
3.142
>>> round(3.1415926,4)
3.1416
>>> round(3.1415926,5)
3.14159
\end{Verbatim}



\subsection{min，max和sum函数}
\label{sec:sum函数}
min，max函数的用法和sum的用法稍微有点差异，简单起见可以认为min，max，sum都接受一个元组或者列表（还有其他？），然后返回这个元组或者列表其中的最小值，最大值或者相加总和。此外min和max还支持min(1,2,3)这样的形式，而sum不支持。
\begin{Verbatim}
>>> min((1,6,8,3,4))
1
>>> max([1,6,8,3,4])
8
>>> sum([1,6,8,3,4])
22
>>> min(1,6,8,3,4)
1
\end{Verbatim}



\subsection{位操作}
python支持位操作的，这里简单说一下：位左移操作<<，位与操作\&{}，位或操作|，位异或操作\^{}。
\begin{Verbatim}
>>> x=0b0001
>>> bin(x << 2)
'0b100'
>>> bin(x | 0b010)
'0b11'
>>> bin(x & 0b1)
'0b1'
>>> bin(x ^ 0b101)
'0b100'
\end{Verbatim}




\subsection{math宏包}
在\verb+from math import *+之后，可以直接用符号pi和e来引用圆周率和自然常数。此外math宏包还提供了很多数学函数，比如：
\begin{description}
\item[sqrt] 开平方根函数，sqrt(x)。
\item[sin] 正弦函数，类似的还有cos，tan等，sin(x)。
\item[degrees] 将弧度转化为角度，三角函数默认输入的是弧度值。
\item[radians] 将角度转化位弧度，radians(30)。 
\item[log] 开对数，log(x,y)，即$\log_y x$，y默认是e。
\item[exp] 指数函数，exp(x)。
\item[pow] 扩展了内置方法，现在支持float了。pow(x,y)
\end{description}

这里简单写个例子：
\begin{Verbatim}
>>> from math import *
>>> print(pi)
3.141592653589793
>>> print(sqrt(85))
9.219544457292887
>>> print(round(sin(radians(30)),1))#sin(30°)
0.5
\end{Verbatim}


更多具体细节请参看\href{http://docs.python.org/3.4/library/math.html}{官方文档}。




\subsection{random宏包}
random宏包提供了一些函数来解决随机数问题。%内容待充实
\begin{description}
\item[random] random函数产生0到1之间的随机实数（包括0）
\item[uniform] uniform函数产生从a到b之间的随机实数（a，b的值指定，包括a。）
\item[randrange] randrange函数产生从a到b之间的随机整数，步长为c（a，b，c的值指定，相当于choice(range(start,stop,step))，range(0,5)是从0到4不包括5，所以这里是从a到b不包括b。）
\item[choice] choice随机从一个列表或者字符串中取出一个元素。
\end{description}

下面是一个简单的例子：
\begin{xverbatim}[129]{py}
from random import *
print(random())
print(uniform(1,10))
print(randrange(1,6))
print(choice('abcdefghij'))
print(choice(['①','②','③']))
\end{xverbatim}

更多详细细节请参阅\href{http://docs.python.org/3.4/library/random.html}{官方帮助文档}。


\subsection{numpy宏包}
关于numpy宏包的介绍请看文件夹[\textit{玩ipython notebook}]。










\section{序列}
字符串，列表，元组（tuple，这里最好翻译成元组，因为里面的内容不一定是数值。）都是序列（sequence）的子类，所以序列的一些性质他们都具有，最好在这里一起讲方便理解记忆。

\subsection{len函数}
len函数返回序列所含元素的个数：
\begin{xverbatim}[129]{py}
string001='string'
list001=['a','b','c']
tuple001=(1,2,3,4)

for x in [string001,list001,tuple001]:
    print(len(x))
\end{xverbatim}


\subsection{调出某个值}
对于序列来说后面跟个方括号，然后加上序号（程序界的老规矩，从0开始计数。），那么调出对应位置的那个值。还以上面那个例子来说明。
\begin{xverbatim}[129]{py}
string001='string'
list001=['a','b','c']
tuple001=(1,2,3,4)

for x in [string001,list001,tuple001]:
    print(x[2])
\end{xverbatim}

\subsubsection{倒着来}
倒着来计数-1表示倒数第一个，-2表示倒数第二个。依次类推。
\begin{xverbatim}[129]{py}
string001='string'
list001=['a','b','c']
tuple001=(1,2,3,4)

for x in [string001,list001,tuple001]:
    print(x[-1],x[-2])
\end{xverbatim}

\subsubsection{连着来}
\label{sec:序列连着来}
前面不写表示从头开始，后面不写表示到达尾部。中间加个冒号的形式表示从那里到那里。这里\textbf{注意}后面那个元素是\uwave{不包括}进来，看来python区间的默认含义都是包头不包尾。这样如果你想要最后一个元素也进去，只有使用默认的不写形式了。
\begin{xverbatim}[129]{py}
string001='string'
list001=['a','b','c']
tuple001=(1,2,3,4)

for x in [string001,list001,tuple001]:
    print(x[1:3],x[-2:-1],x[:-1],x[1:],x[1:-1])
\end{xverbatim}
用数学半开半闭区间的定义来理解这里的包含关系还是很便捷的。
\begin{enumerate}
\item 首先是数学半开半闭区间，左元素和右元素都是之前叙述的对应的定位点。左元素包含右元素不包含。
\item 其次方向应该是从左到右，如果定义的区间是从右到左，那么将产生空值。
\item 如果区间超过，那么从左到右包含的所有元素就是结果。
\item 最后如果左右元素定位点相同，那么将产生空值，比如：\\
\verb+string001[2:-4]+，其中2和-4实际上是定位在同一个元素之上的。额外值得一提的列表插入操作，请参看列表的插入操作这一小节。\ref{sec:列表插入操作}
\end{enumerate}


\subsection{序列的可更改性}
字符串不可以直接更改，但可以组合成为新的字符串；列表可以直接更改；元组不可以直接更改。



\subsection{序列的加法和减法}
两个字符串相加就是字符串拼接了。乘法就是加法的重复，所以一个字符串乘以一个数字就是自己和自己拼接了几次。列表还有元组和字符串一样大致情况类似。

\begin{xverbatim}[129]{py}
print('abc'+'def')
print('abc'*3)
print([1,2,3]+[4,5,6])
print((0,'a')*2)
\end{xverbatim}



\section{字符串}
python语言不像c语言字符和字符串是不分的，用单引号或者双引号包起来就表示一个字符串了。单引号和双引号的区别是一般用单引号，如果字符串里面有单引号，那么就使用双引号，这样单引号直接作为字符处理而不需要而外的转义处理——所谓转义处理和其他很多编程语言一样用\textbackslash 符号。比如要显示\verb+'+就输入\verb+\'+。

\subsection{三单引号和三双引号}
在单引号或者双引号的情况下，你可以使用\verb+\n+来换行，其中\textbackslash n表示换行。此外还可以使用三单引号'''或者三双引号"""来包围横跨多行的字符串，其中换行的意义就是换行，不需要似前面那样的处理。

\begin{Verbatim}
print('''\
这是一段测试文字
  this is a test line
      其中空白和    换行都所见所得式的保留。''')
\end{Verbatim}

\subsection{find方法}
字符串的find方法可用来查找某个子字符串，没有找到返回-1，找到了返回字符串的偏移量。用法就是：\verb+s.find('d')+。


\subsection{replace方法}
字符串的replace方法进行替换操作，接受两个参数：第一个参数是待匹配的子字符串，第二个参数是要替换成为的样子。

\subsection{upper方法}
将字符串转换成大写形式。

\subsection{isdigit方法}
类似的还有isalpha方法，测试是不是数字或字母。值得注意的是就算是字母组成的语句，中间有空间也会返回False。

\subsection{split方法}
字符串的split方法可以将字符串比如有空格或者逗号等分隔符分割而成，可以将其分割成子字符串列表。默认是空格是分隔符。

\subsection{join方法}
字符串的join方法非常有用，严格来说它接受一个迭代器参数，不过最常见的是列表，如下所示：
\begin{Verbatim}
>>> list001=['a','b','c']
>>> "".join(list001)
'abc'
\end{Verbatim}



\subsection{rstrip方法}
字符串右边的空格都删除。换行符也会被删除掉。

\subsection{format方法}
字符串的format方法方便对字符串内的一些变量进行替换操作，其中花括号不带数字跟format方法里面所有的替换量，带数字0表示第一个替换量，后面类推。
\begin{Verbatim}
print('1+1={0}，2+2={1}'.format(1+1,2+2))
\end{Verbatim}

\subsection{转义和不转义}
\verb+\n    \t  +这是一般常用的转义字符，换行和制表。此外还有\verb+\\+输出\textbackslash 符号。

如果输出字符串不想转义那么使用如下格式：
\begin{Verbatim}
>>> print(r'\t \n \test')
\t \n \test
\end{Verbatim}





\section{列表}
方括号包含几个元素就是列表。


\subsection{列表的插入操作}
\label{sec:列表插入操作}
字符串和数组都不可以直接更改所以不存在这个问题，列表可以。其中列表还可以以一种定位在相同元素的区间的方法来实现插入操作，这个和之前理解的区间多少有点违和，不过考虑到定位在相同元素的区间本来就概念模糊，所以在这里就看作特例，视作在这个\uwave{定位点相同元素之前}插入吧。
\begin{xverbatim}[129]{py}
list001=['one','two','three']
list001[1:-2]=['four','five']
print(list001)
\end{xverbatim}

除了序列中的一些继承的操作之外，列表还有很多方法，实际上这还算少的（如果你见识了lisp中各种列表操作）。因为列表这个数据结构可以直接修改相当灵活，下面我打算将我学lisp语言中接触到的一些列表操作对应过来一一说明之：

extend方法似乎和列表之间的加法重合了，比如\\list001.extend([4,5,6])就和list001=list001+[4,5,6]是一致的，而且用加法表示还可以自由选择是不是覆盖原定义，这实际上更加自由。所以extend方法略过。

insert方法也就是列表的插入操作，这个前面关于列表的插入实现方法说过一种了，所以insert方法也略过。

\subsection{append方法}
python的append方法和lisp中的append还是有点差异的，python的append就是在最后面加\textbf{一个元素}，如果你append一个列表那么这一个列表整体作为一个元素。lisp的append函数和python的extend方法类似，接受一个列表。

其次append是list类中的一个方法，也就是list001.append这样的形式，也就是永久的改变了某个列表实例的值了。



\subsection{reverse方法}
reverse方法不接受任何参数，直接将一个列表永久性地翻转过来。

\subsection{sort方法}
也就是排序，永久性改变列表。默认是递增排序，可以用\textbf{reverse=True}来调成递减排序。可以用\textbf{key=function}来设置排序的函数，这个排序函数是单参数函数。

类似的有sorted函数，不同的sorted函数返回的是一个新的列表而不是原处修改。



\subsection{删除某个元素}
\begin{itemize}
\item 赋空列表值，相当于所有元素都删除了。 
\item pop方法：接受一个参数，就是列表元素的定位值，然后那个元素就删除了，方法并返回那个元素的值。如果不接受参数默认是删除最后一个元素。
\item remove方法：移除第一个相同的元素，如果没有返回相同的元素，返回错误。
\item del函数：删除列表中的某个元素。
\end{itemize}

\begin{Verbatim}
>>> list001=['a','b','c','d','e']
>>> list001.pop(2)
'c'
>>> list001
['a', 'b', 'd', 'e']
>>> list001.pop()
'e'
>>> list001
['a', 'b', 'd']
>>> list001.remove('a')
>>> list001
['b', 'd']
>>> del list001[1]
>>> list001
['b']
\end{Verbatim}




\subsection{index方法}
index方法返回某个相同元素的偏移值。
\begin{Verbatim}
>>> list001=[1,'a',100]
>>> list001.index('a')
1
\end{Verbatim}



\subsection{列表元素的替换}
lisp语言中有subst函数，是substitute的缩写。作用于整个列表，列表中所有出现的某个元素都要被另一个元素替换掉。

由于我现在对如何修改python语言内置类还毫无头绪，只好简单写这么一个函数了。
\begin{xverbatim}[129]{py}
def subst(list001,element001,element002):
    try:
        list001.index(element001)
    except ValueError:
        return list001
    else:
        n=list001.index(element001)
        del list001[n]
        list001[n:n]=[element002]
        return subst(list001,element001,element002)

print(subst([1,'a',3,[4,5]],[4,5],'b'))
print(subst([1,1,5,4,1,6],1,'replaced'))
\end{xverbatim}
这个subst函数接受三个参数，表示接受的列表，要替换的元素和替换成为的元素。这里使用的程序结构是try...except...else...语句。其中try来侦测是不是有错误，其中index方法是看那个要替换的元素存不存在，由于不存在这个函数将产生一个\textbf{ValueError}错误，所以用except来接著。既然没有要替换的元素了，那么返回原列表即可，程序中止。

else语句接著没有错误的时候你要执行的操作，先index再删掉这个元素，再在之前插入那个元素，然后使用了递归算法，调用函数自身。

\subsection{列表解析}
lisp中的mapcar函数有这个功用，python中的map函数基本上和它情况类似。

我们先来看lisp中的情况：
\begin{xverbatim}[129]{lisp}
(defun square (n) (* n n))
(format t "~&~s" (mapcar #'square '(1 2 3 4 5)) )
\end{xverbatim}

再来看python中的情况：
\begin{xverbatim}[129]{py}
def square(n):
    return n*n
    
print(list(map(square,[1,2,3,4,5])))
print([square(x) for x in [1,2,3,4,5]])
\end{xverbatim}
map函数将某个应数应用于某个列表的元素中并生成一个map对象，需要外面加上list函数才能生成列表形式。第二种方式更有python风格，是推荐使用的列表解析方法。


\subsection{count方法}
统计某个元素出现的次数。
\begin{Verbatim}
>>> list001=[1,'a',100,1,1,1]
>>> list001.count(1)
4
\end{Verbatim}


\subsection{for语句的进阶}
在lisp语言的loop宏中，还有很多高级应用，比如

\begin{description}
\item[collect] 将迭代产生的所有信息收集到列表中。
\item[summing] 将迭代产生的所有信息加到一起。
\item[count] 跟着一个判断函数，每次迭代运行一次，然后记录得到的True即真值的情况的总数。
\item[minimize] 将每次迭代的结果进行比较，然后返回最小值。
\item[maximize] 同minimize，返回最大值。
\item[append] 将每次迭代产生的列表append在一起。
\end{description}

那么在python中如何实现以上功能呢？

在这里最基本的是通过迭代语句产生一个列表，然后通过某些函数比如minimize对应min函数，maximize对应max函数等对这个列表进行一些操作即可。

\begin{xverbatim}[129]{py}
from random import *
def random_list_max(n):
    y=[randint(1,n) for x in range(1000)]
    list_count=[y.count(x) for x in range(1,n+1)]
    return list_count.index(max(list_count))+1

print(random_list_max(40))
\end{xverbatim}










\section{字典}
与列表一样字典是可变的，可以像列表一样引用然后原处修改，del语句也适用。

\subsection{创建字典}
字典是一种映射，并没有从左到右的顺序，只是简单地将键映射到值。字典的声明格式如下：
\begin{Verbatim}
dict001={'name':'tom','height':'180','color':'red'}
dict001['name']
\end{Verbatim}

或者创建一个空字典，然后一边赋值一边创建对应的键：
\begin{Verbatim}
dict002={}
dict002['name']='bob'
dict002['height']=195
\end{Verbatim}

所以对字典内不存在的键赋值是可行的。








\subsection{字典里面有字典}
和列表的不同就在于字典的索引方式是根据“键”来的。
\begin{Verbatim}
dict003={'name':{'first':'bob','second':'smith'}}
dict003['name']['first']
\end{Verbatim}

\subsection{字典遍历操作}
字典特定顺序的遍历操作的通用做法就是通过字典的keys方法收集键的列表，然后用列表的sort方法处理之后用for语句遍历，如下所示：
\begin{Verbatim}
dict={'a':1,'c':2,'b':3}
dictkeys=list(dict.keys())
dictkeys.sort()
for key in dictkeys:
    print(key,'->',dict[key])
\end{Verbatim}

如果你对字典遍历的顺序没有要求，那么就可以简单的这样处理：
\begin{Verbatim}
>>> for key in dict:
...     print(key,'->',dict[key])
... 
c -> 2
a -> 1
b -> 3
\end{Verbatim}



\subsubsection{sorted函数}
sorted方法可以对字典直接排序，返回的是该字典键值的列表。
\begin{Verbatim}
dict={'a':1,'c':2,'b':3}
for key in sorted(dict):
    print(key,'->',dict[key])
\end{Verbatim}

\subsubsection{values方法}
和keys方法类似，收集的值。
\begin{Verbatim}
>>> dict001.values()
dict_values([3, 1, 2])
>>> list(dict001.values())
[3, 1, 2]
\end{Verbatim}

\subsubsection{items方法}
和keys和values方法类似，不同的是返回的是(key,value)对。
\begin{Verbatim}
>>> dict001.items()
dict_items([('c', 3), ('a', 1), ('b', 2)])
>>> list(dict001.items())
[('c', 3), ('a', 1), ('b', 2)]
\end{Verbatim}





\subsection{字典的in语句}
可以看到in语句只针对字典的键，不针对字典的值。
\begin{Verbatim}
>>> dict001={'a':1,'b':2,'c':3}
>>> 2 in dict001
False
>>> 'b' in dict001
True
\end{Verbatim}

\subsection{字典对象的get方法}
get方法是去找某个键的值，为什么不直接引用呢，get方法的好处就是某个键不存在也不会出错。
\begin{Verbatim}
>>> dict001={'a':1,'b':2,'c':3}
>>> dict001.get('b')
2
>>> dict001.get('e')
\end{Verbatim}

\subsection{update方法}
感觉字典就是一个小型数据库，update方法将另外一个字典里面的键和值覆盖进之前的字典中去，称之为更新，没有的加上，有的覆盖。
\begin{Verbatim}
>>> dict001={'a':1,'b':2,'c':3}
>>> dict002={'e':4,'a':5}
>>> dict001.update(dict002)
>>> dict001
{'c': 3, 'a': 5, 'e': 4, 'b': 2}
\end{Verbatim}

\subsection{pop方法}
pop方法类似列表的pop方法，不同引用的是键，而不是偏移地址，这个就不多说了。



\subsection{字典解析}
这种字典解析方式还是很好理解的。
\begin{Verbatim}
>>> dict001={x:x**2 for x in [1,2,3,4]}
>>> dict001
{1: 1, 2: 4, 3: 9, 4: 16}
\end{Verbatim}

\subsubsection{zip函数创建字典}
可以利用zip函数来通过两个列表平成一个字典，这个有时很有用。zip函数刚开始返回的是什么zip对象，然后对其进行字典解析。
\begin{Verbatim}
>>> dict001=zip(['a','b','c'],[1,2,3])
>>> dict001
<zip object at 0xb6b464ac>
>>> dict001={a:b for (a,b) in dict001}
>>> dict001
{'c': 3, 'a': 1, 'b': 2}
\end{Verbatim}

这种解析方式的理解有一定难度，主要是zip函数这里比较抽象了。而下面这段代码是\emph{python2}的，就比较好理解一点。所以要理解python3的那种语法，只好认为python3中的zip对象只是还未展开的如下所示结构的那种列表。值得一提的在python3中\uwave{dict强制变换不能使用}了。
\begin{Verbatim}
>>> zip(['a','b','c'],[1,2,3])
[('a', 1), ('b', 2), ('c', 3)]
>>> dict001=dict(zip(['a','b','c'],[1,2,3]))
>>> dict001
{'a': 1, 'c': 3, 'b': 2}
\end{Verbatim}


\subsection{字典的集合操作}
python3的字典更多的接近集合了，它现在支持很多集合操作，比如-，\&{}，|等。字典的集合操作是以键参与集合操作的。


\section{集合}
集合可以用过可以通过set函数创建一个集合对象，集合的元素是无序的，数学上类似的集合操作这里都有：
\begin{Verbatim}
>>> set001=set('hello')
>>> set001
set(['h', 'e', 'l', 'o'])
>>> set002={'h','a','b'}
>>> set002
set(['a', 'h', 'b'])
>>> print(set001)
set(['h', 'e', 'l', 'o'])
>>> set001 & set002
set(['h'])
>>> set001 | set002
set(['a', 'b', 'e', 'h', 'l', 'o'])
>>> set001 - set002
set(['e', 'l', 'o'])
>>> {x**2 for x in [1,2,3,4,5]}
set([16, 1, 4, 25, 9])
\end{Verbatim}

其中\verb+&  |  -+就是交，与，差的意思。




\section{元组}
圆括号包含几个元素就是元组(tuple)。元组和列表的不同在于元组是不可改变。元组也是从属于序列对象的，元组的很多方法之前都讲了。而且元组在使用上和列表极其接近，有很多内容这里也略过了。

值得一提的是如果输入的时候写的是\textit{x,y}这样的形式，实际上表达式就加上括号了，也就是一个元组了\textit{(x,y)}。




\section{文件}

\subsection{写文件}
对文件的操作首先需要用open函数创建一个文件对象，简单的理解就是把相应的接口搭接好。文件对象的write方法进行对某个文件的写操作，最后需要调用close方法写的内容才真的写进去了。

\begin{Verbatim}
file001 = open('test.txt','w')
file001.write('hello world1\n')
file001.write('hello world2\n')
file001.close()
\end{Verbatim}

如果你们了解C语言的文件操作，在这里会为python语言的简单便捷赞叹不已。就是这样三句话：创建一个文件对象，然后调用这个文件对象的wirte方法写入一些内容，然后用close方法关闭这个文件即可。


\subsection{读文件}
一般的用法就是用open函数创建一个文件对象，然后用read方法调用文件的内容。最后记得用close关闭文件。
\begin{Verbatim}
file001 = open('test.txt')
filetext=file001.read()
print(filetext)
file001.close()
\end{Verbatim}

此外还有readline方法是一行一行的读取某文件的内容。


\subsection{open函数的处理模式}
open函数的处理模式如下：
\begin{description}
\item['r'] 默认值，read，读文件。
\item['w'] wirte，写文件，如果文件不存在会创建文件，如果文件已存在，文件原内容会清空。
\item['a'] append，附加内容，也就是后面用write方法内容会附加在原文件之后。
\item['b'] 处理模式设置的\uwave{附加}选项，'b'不能单独存在，要和上面三个基本模式进行组合，比如'rb'等，意思是二进制数据格式读。
\item['+'] 处理模式设置的\uwave{附加}选项，同样'+'不能单独存在，要和上面三个基本模式进行组合，比如'r+'等，+是updating更新的意思，也就是既可以读也可以写，那么'r+'，'w+'，'a+'还有什么区别呢？区别就是'r+'不具有文件创建功能，如果文件不存在会报错，然后'r+'不会清空文件，如果'r+'不清空文件用write方法情况会有点复杂；而'w+'具有文件创建功能，然后'w+'的write方法内容都是重新开始的；而'a+'的write方法内容是附加在原文件上的，然后'a+'也有文件创建功能。
\end{description}



\subsection{用with语句打开文件}
类似之前的例子我们可以用with语句来打开文件，这样就不用close方法来关闭文件了。然后with语句来提供了类似try语句的功能可以自动应对打开文件时的一些异常情况。
\begin{Verbatim}
with open('test.txt','w') as file001:
    file001.write('hello world1\n')
    file001.write('hello world2\n')

with open('test.txt','r') as file001:
    filetext=file001.read()
    print(filetext)
\end{Verbatim}


\subsection{除字符串外其他类型的读取}
文本里面存放的都是字符串类型，也就是写入文件需要用str函数强行将其他类型转变成字符串类型，而读取进来想要进行一些操作则需要将字符串类型转变回去。比如用int或者float等，不过列表和字典的转变则需要eval函数。

eval这个函数严格来讲作用倒不是为了进行上面说的类型转换的，它就是一个内置函数，一个字符串类型python代码用eval函数处理了之后就能转变为可执行代码。
\begin{Verbatim}
>>> eval('1+1')
2
>>> eval('[1,2,3]')
[1, 2, 3]
>>> eval("{'a':1,'b':2,'c':3}")
{'c': 3, 'b': 2, 'a': 1}
\end{Verbatim}

推荐使用pickle宏包来处理其他类型的文件读写问题，相对来说更简单更安全。请参看pickle宏包这一小节\ref{sec:pickle宏包}。





\section{总结}


\chapter{类}
类相当于自己创造一个自己的操作对象。一般面向对象(OOP)编程的基本概念这里不重复说明了，如有不明请读者自己随便搜索一篇网页阅读下即可。

\section{python中类的结构}
python中的类就好像树叶，所有的类就构成了一棵树，而python中超类，子类，实例的重载或继承关系等就是由一种搜索机制实现的：
\begin{fig}{类搜索结构图}
\label{fig:类搜索结构图}
\end{fig}
python首先搜索self有没有这个属性或者方法，如果没有，就向上搜索。比如说实例l1没有，就向上搜索C1，C1没有就向上搜索C2或C3等。

实例继承了创造他的类的属性，创造他的类上面可能还有更上层的超类，类似的概念还有子类，表示这个 类在树形层次中比较低。

well，简单来说类的结构和搜索机制就是这样的，很好地模拟了真实世界知识的树形层次结构。

上面那副图实际编写的代码如下：
\begin{Verbatim}
class C2: ...
class C3: ...
class C1(C2,C3): ...
l1=C1()
l2=C1()
\end{Verbatim}
其中class语句是创造类，而C1继承自C2和C3，这是多重继承，从左到右是内部的搜索顺序（会影响重载）。l1和l2是根据类C1创造的两个实例。

对于初次接触类这个概念的读者并不指望他们马上就弄懂类这个概念，这个概念倒并一定要涉及很多哲学的纯思考的东西，也可以看作一种编程经验或技术的总结。多接触也许对类的学习更重要，而不是纯哲学抽象概念的讨论，毕竟类这个东西创造出来就是为了更好地描述现实世界的。

最后别人编写的很多宏包就是一堆类，你就是要根据这些类来根据自己的情况情况编写自己的子类，为了更好地利用前人的成果，或者你的成果更好地让别人快速使用和上手，那么你需要好好掌握类这个工具。

\section{类的最基础知识}
\subsection{类的创建}
\begin{Verbatim}
class MyClass:
    something
\end{Verbatim}
类的创建语法如上所示，然后你需要想一个好一点的类名。类名规范的写法是首字母大写，这样好和其他变量有所区分。

\subsection{根据类创建实例}
按照如下语句格式就根据MyClass类创建了一个实例myclass001。
\begin{Verbatim}
myclass001=MyClass()
\end{Verbatim}

\subsection{类的属性}
\begin{Verbatim}
>>> class MyClass:
...  name='myclass'
... 
>>> myclass001=MyClass()
>>> myclass001.name
'myclass'
>>> MyClass.name
'myclass'
>>> myclass001.name='myclass001'
>>> myclass001.name
'myclass001'
>>> MyClass.name
'myclass'
\end{Verbatim}
如上代码所示，我们首先创建了一个类，这个类加上了一个name属性，然后创建了一个实例myclass001，然后这个实例和这个类都有了name属性。然后我们通过实例加上点加上name的这种格式引用了这个实例的name属性，并将其值做了修改。

这个例子简单演示了类的创建，属性添加，实例创建，多态等核心概念。后面类的继承等概念都和这些大同小异了。


\subsection{类的方法}
类的方法就是类似上面类的属性一样加上def语句来定义一个函数，只是函数在类里面我们一般称之为方法。这里演示一个例子，读者看一下就明白了。
\begin{Verbatim}
>>> class MyClass:
...  name='myclass'
...  def double(self):
...   self.name=self.name*2
...   print(self.name)
... 
>>> myclass001=MyClass()
>>> myclass001.name
'myclass'
>>> myclass001.double()
myclassmyclass
>>> myclass001.name
'myclassmyclass'
\end{Verbatim}

这里需要说明的是在类的定义结构里面，self代表着类自身，self.name代表着对自身name属性的引用。然后实例在调用自身的这个方法时用的是myclass001.double()这样的结构，这里double函数实际上接受的第一个参数就是自身，也就是myclass001，而不是无参数函数。所以类里面的方法（被外部引用的话）至少有一个参数self。





\section{类的继承}
实例虽然说是根据类创建出来的，但实际上实例和类也是一种继承关系，实例继承自类，而类和类的继承关系也与之类似，只是语法稍有不同。下面我们来看这个例子：
\begin{xverbatim}[129]{py}
class Hero():
    def addlevel(self):
        self.level=self.level+1
        self.hp=self.hp+self.addhp

class Garen(Hero):
    level=1
    hp=455
    addhp=96

garen001=Garen()
for i in range(6):
    print('级别:',garen001.level,'生命值：' ,garen001.hp)
    garen001.addlevel()
\end{xverbatim}

\begin{fig}[0.5]{类的继承示例}
\caption{类的继承示例}
\label{fig:类的继承示例}
\end{fig}

这里就简单的两个类，盖伦Garen类是继承自Hero类的，实例garen001是继承自Garen类的，这样garen001也有了addlevel方法，就是将自己的level属性加一，同时hp生命值也加上一定的值，整个过程还是很直观的。


\section{类的内置方法}
如果构建一个类，就使用pass语句，什么都不做，python还是会为这个类自动创建一些属性或者方法。
\begin{Verbatim}
>>> class TestClass:
...  pass
... 
>>> dir(TestClass)
['__class__', '__delattr__', '__dict__', '__dir__', '__doc__',
 '__eq__', '__format__', '__ge__', '__getattribute__',
  '__gt__',  '__hash__', '__init__', '__le__', '__lt__',
   '__module__', '__ne__', '__new__', '__reduce__', 
   '__reduce_ex__', '__repr__', '__setattr__', 
   '__sizeof__', '__str__', '__subclasshook__',
    '__weakref__']
\end{Verbatim}

这些变量名字前后都加上双下划线是给python这个语言的设计者用的，一般应用程序开发者还是不要这么做。

这些内置方法用户同样也是可以重定义他们从来覆盖掉原来的定义，其中特别值得一讲的就是\verb+__init__+方法或者称之为构造函数。

\subsection{\_\_init\_\_{}方法}
\verb+__init__+方法对应的就是该类创建实例的时候的构造函数。比如：
\begin{Verbatim}
>>> class Point:
...  def __init__(self,x,y):
...   self.x=x
...   self.y=y
... 
>>> point001=Point(5,4)
>>> point001.x
5
>>> point001.y
4
\end{Verbatim}
这个例子重载了\verb+__init__+函数，然后让他接受三个参数，self等下要创建的实例，x，还有y通过下面的语句给这个待创建的实例的属性x和y赋了值。


\subsection{self意味着什么}
self在类中是一个很重要的概念，当类的结构层次较简单时还容易看出来， 当类的层次结构很复杂之后，你可能会弄糊涂。\uwave{self就是指现在引用的这个实例}。比如你现在通过调用某个实例的某个方法，这个方法可能是一个远在天边的某个类给出的定义，就算如此，那个定义里面的self还是指调用这个方法的那个实例，这一点要牢记于心。


\subsection{类的操作第二版}
现在我们可以写出和之前那个版本相比更加专业的类的使用版本了。
\begin{xverbatim}[129]{py}
class Hero():
    def addlevel(self):
        self.level=self.level+1
        self.hp=self.hp+self.addhp

class Garen(Hero):
    def __init__(self):
        self.level=1
        self.hp=455
        self.addhp=96
        self.skill=['不屈','致命打击','勇气','审判','德玛西亚正义']

garen001=Garen()
for i in range(6):
    print('级别:',garen001.level,'生命值：' ,garen001.hp)
    garen001.addlevel()
print('盖伦的技能有：',"".join([x + '  ' for x in garen001.skill]))
\end{xverbatim}

似乎专业的做法类里面多放点方法，最好不要放属性，不太清楚是什么。但确实这样写给人感觉更干净点，方法是方法，如果没有调用代码就放在那里我们不用管它，后面用了构造函数我们就去查看相关类的构造方法，这样很省精力。


\section{类的操作第三版}
\begin{xverbatim}[129]{py}
class Unit():
    def __init__(self,hp,atk,color):
        self.hp=hp
        self.atk=atk
        self.color=color
    def __str__(self):
        return '生命值：{0}，攻击力：{1}，颜色：\
        {2}'.format(self.hp,self.atk,self.color)

class Hero(Unit):
    def __init__(self,level,hp,atk,color):
        Unit.__init__(self,hp,atk,color)
        self.level=level
    def __str__(self):
        return '级别：{0},生命值：{1}，攻击力：{2}，\
        颜色：{3}'.format(self.level,self.hp,self.atk,self.color)

    def addlevel(self):
        self.level=self.level+1
        self.hp=self.hp+self.addhp
        self.atk=self.atk+self.addatk

class Garen(Hero):
    def __init__(self,color='blue'):
        Hero.__init__(self,1,455,56,color)
        self.name='盖伦'
        self.addhp=96
        self.addatk=3.5
        self.skill=['不屈','致命打击','勇气','审判','德玛西亚正义']

if __name__ == '__main__':
    garen001=Garen('red')
    garen002=Garen()
    print(garen001)
    unit001=Unit(1000,1000,'gray')
    print(unit001)
    for i in range(6):
        print(garen001)
        garen001.addlevel()
    print('盖伦的技能有：',"".join([x + '  ' for x in garen001.skill]))
\end{xverbatim}
现在就这个例子相对于第二版所作的改动，也就是核心知识点说明之。其中函数参量列表中这样表述\verb+color='blue'+表示blue是color变量的备选值，也就是color成了可选参量了。


\subsection{构造函数的继承和重载}
上面例子很核心的一个概念就是\verb+__init__+构造函数的继承和重载。比如我们看到garen001实例的创建，其中就引用了Hero的构造函数，特别强调的是\uwave{只有创造实例的时候比如这样的形式Garen()才叫做调用了Garen类的构造方法}， 比如这里\\
\verb+Hero.__init__(self,1,455,56,color)+就是调用了Hero类的构造函数，这个时候需要把self写上，因为self就是最终创建的实例garen001，而不是Hero，而且调用Hero类的构造函数就必须按照它的参量列表形式来。这个概念需要弄清楚！

理解了这一点，在类的继承关系中的构造函数的继承和重载就好看了。比如这里Hero类的构造函数又是继承自Unit类的构造函数，Hero类额外有一个参量level接下来也要开辟存储空间配置好。

\subsection{\_\_str\_\_{}函数的继承和重载}
第二个修改是这里重定义了一些类的\verb+__str__+函数，通过重新定义它可以改变默认print某个类对象是的输出。默认只是一段什么什么类并无具体内容信息。具体就是return一段你想要的字符串样式即可。




\subsection{类的其他内置方法}
类还有其他的一些内置方法，比如\verb+__add__+就控制这对象面对加号时候的行为。这些我们暂时先略过。




\chapter{操作或者函数}
\section{自定义函数}
定义函数用def命令，语句基本结构如下：
\begin{Verbatim}
def yourfunctionname(para001,para002...):
    do something001
    do something002
\end{Verbatim}

\section{参数和默认参数}
定义的函数圆括号那里就是接受的参数，如果参数后面跟个等号，来个赋值语句，那个这个赋的值就是这个参数的默认值。比如下面随便写个演示程序：
\begin{xverbatim}[129]{py}
def test(x='hello'):
    print(x)
test()
test('world')
\end{xverbatim}


\section{递归函式}
虽然递归函式能够在某种程度上取代前面的一些循环或者迭代程序结构，不过不推荐这么做。这里谈及递归函式是把某些问题归结为数学函数问题，而这些问题常常用递归算法更加直观（不一定高效）。比如下面的菲波那奇函数：
\begin{xverbatim}[129]{py}
def fib(n):
    if n==0:
        return 1
    if n==1:
        return 1
    else:
        return fib(n-1)+fib(n-2)
        
for x in range(5):
    print(fib(x))
\end{xverbatim}
我们可以看到，对于这样专门的数学问题来说，用这样的递归算法来表述是非常简洁易懂的。至于其内部细节，我们可以将上面定义的fib称之为函式，函式是一种操作的模式，然后具体操作就是复制出这个函式（函数或者操作都是数据），然后按照这个函式来扩展生成具体的函数或者操作。

下面看通过递归函式来写阶乘函数，非常的简洁，我以为这就是最好最美的方法了。
\begin{xverbatim}[129]{py}
def fact(n):
    if n == 0:
        return 1
    else:
        return n*fact(n-1)
        
print(fact(0),fact(10))
\end{xverbatim}

其实通过递归函式也可以实现类似for的迭代结构，不过我觉得递归函式还是不应该滥用。比如下面通过递归函式生成一种执行某个操作n次的结构：

\begin{xverbatim}[129]{py}
def dosomething(n):
    if n==0:
        pass
    elif n==1:
        print('do!')
    else:
        print('do!')
        return dosomething(n-1)

print(dosomething(5))
\end{xverbatim}
可以看到，如果把上面的print语句换成其他的某个操作，比如机器人向前走一步，那么这里dosomething换个名字向前走(5)就成了向前走5步了。

\section{不定参量函数}
我们在前面谈到sum函数\ref{sec:sum函数}只接受一个列表，而不支持这样的形式：sum(1,2,3,4,5)。现在我们设计这样一个可以接受不定任意数目参量的函数。首先让我们看看一种奇怪的赋值方式。

\subsection{序列解包赋值}
\begin{Verbatim}
>>> a,b,*c=1,2,3,4,5,6,7,8,9
>>> print(a,b,c,sep=' | ')
1 | 2 | [3, 4, 5, 6, 7, 8, 9]
>>> a,*b,c=1,2,3,4,5,6,7,8,9
>>> print(a,b,c,sep=' | ')
1 | [2, 3, 4, 5, 6, 7, 8] | 9
>>> *a,b,c=1,2,3,4,5,6,7,8,9
>>> print(a,b,c,sep=' | ')
[1, 2, 3, 4, 5, 6, 7] | 8 | 9
\end{Verbatim}
带上一个星号*的变量变得有点类似通配符的味道了，针对后面的序列\footnote{似乎序列赋值内置迭代操作}（数组，列表，字符串），它都会将遇到的元素收集在一个列表里面，然后说是它的。


\subsection{函数中的通配符}
\begin{Verbatim}
>>> def test(*args):
...  print(args)
... 
>>> test(1,2,3,'a')
(1, 2, 3, 'a')
\end{Verbatim}
我们看到类似上面序列解包赋值中的带星号表通配的概念，在定义函数的时候写上一个带星号的参量（我们可以想象在函数传递参数的时候有一个类似的序列解包赋值过程），在函数定义里面，这个args就是接受到的参量组成的\emph{数组}。


\subsection{mysum函数}
\begin{xverbatim}[129]{py}
def mysum(*args):
    return sum([arg for arg in args[:]])

print(mysum(1,2,3,4,5,6))
\end{xverbatim}
这样我们定义的可以接受任意参数的mysum函数，如上所示。具体过程就是将接受到的args进行列表解析，然后用sum函数处理了一下。


\subsection{任意数目的可选参数}
在函数定义的写上带上两个星号的变量**args，那么args在函数里面的意思就是接受到的可选参数组成的一个字典值。
\begin{Verbatim}
>>> def test(**args):
...  print(args)
... 
>>> test(a=1,b=2)
{'b': 2, 'a': 1}
\end{Verbatim}

老实说一般参数，可选参数（关键字参数），任意参数，任意关键字参数所有这些概念混在一起非常的让人困惑了，这一块有时间再好好琢磨一下。


\section{lambda函式}
lambda
λ表达式这个在刚开始介绍lisp语言的时候已有所说明，简单来说就是函数只是一个映射规则，变量名，函数名都无所谓的。这里就是没有名字的函数的意思。

具体的样子如下面所示：
\begin{xverbatim}[129]{py}
f=lambda x,y,z:x+y+z
print(f(1,2,3))
\end{xverbatim}

lanmbda函式在有些情况下要用到，比如pyqt里面的信号－槽机制用connect方法的时候，槽比如是函数名或者无参函数，如果用户想加入参量的话，可以使用lamba函式引入，具体这里我还不够清晰。


\section{print函数}
print函数因为很常用和基础，就放在这里了。

print函数接受任意的参量，逐个打印出来。然后它还有一些关键字参数，\textbf{sep}：默认值是' '，也就是一个空格，如果修改为空字符串，那么逐个打印出来的字符之间就没有间隔了。\textbf{end}：默认值是'\textbackslash{}n'，\textbf{file}默认值是sys.stdout，也就是在终端显示，你可以修改为某个文件变量，这样直接往某个文件里面输出内容。



\chapter{宏包}
现在让我们进入宏包基础知识的学习吧，建立编写自己的宏包，这样不断积累自己的知识，不断变得更强。

实际上之前我们已经接触过很多python自身的标准宏包或者其他作者写的第三方宏包，而import和from语句就是加载宏包用的。这里我们主要讨论如何自己编写自己的宏包。

from语句和import语句内部作用机制很类似，只是在变量名的处理方式上有点差异（from会把变量名复制过来）。这里重点就import的工作方式说明如下：
\begin{enumerate}
\item 首先需要找到宏包文件。
\item 然后将宏包文件编译成位码（需要时，根据文件的时间戳。），你会看到新多出来一个\verb+__pycache__+文件夹。
\item 执行编译出来的位码，创建该py文件定义的对象。
\end{enumerate}
这三个步骤是第一次import的时候会执行的，第二次import的时候会跳过去，而直接引用内存中已加载的对象。



\section{找到宏包文件}
python宏包的搜索路径会搜索几个地方，这些地方最后都会放在sys.path这个列表里面，所以在你的py文件刚开始修改这个sys.path，append上你想要的地址也是可以的。我在这里选择了这种简单的方法，除此之外还有很多方法这里先不涉及。

比如主文件一般如下：
\begin{Verbatim}
import os,sys
sys.path.append(os.environ['HOME']+'/pymf')
from pyconfig import *
\end{Verbatim}
这里为什么使用\verb+from pyconfig import *+这样的语句而不是import语句呢？因为我决定整个项目的主py文件除了这一个from语句之外不会再import或者from其他宏包了，其他所有宏包的引用都放在pyconfig.py这个主配置文件里面。

pyconfig.py任务就是加载最常用最通用的一些宏包，如果你实际编写的另外一个项目通用pyconfig文件满足不了你的要求了，那么你可以把那个pyconfig文件复制过来，然后放在你的项目文件夹里面，然后继续衍化修改。这个经验是我从\LaTeX 文档的编写中总结出来的，既满足了共性又满足了个性。

那么为什么要用from语句，很简单。如果用import语句，那么pyconfig.py文件里面import math宏包，在主py文件里面引用就要使用这样的格式\verb+pyconfig.math.pi+，这既不方便而且违背大家平时惯用的那种math.pi格式。


现在我们让可以开始编写自己的宏包吧。

\section{编写宏包}
well，编写宏包就是一些py文件，然后宏包的名字和py文件里面的内容编写好就是了。

我现在编写了一个pyconfig.py文件，放在主文件夹（ubuntu系统）的pymf文件里面的。里面定义了一个斐波拉契函数，如下所示：
\begin{Verbatim}
#菲波那奇数列
def fib(n):
    if n==0:
        return 1
    if n==1:
        return 1
    else:
        return fib(n-1)+fib(n-2)
\end{Verbatim}

然后我们的测试小脚本如下：
\begin{xverbatim}[129]{py}
import os,sys
sys.path.append(os.environ['HOME']+'/pymf')
from pyconfig import *

print([fib(n) for n in range(10)])
\end{xverbatim}

一些你觉得常用的类和函数就直接放在pyconfig.py文件里面吧，然后一些不太常用的你可以分类出来放在其他py文件里面，然后pyconfig.py文件用import或者from语句来加载那个宏包即可，这里就不多说了。


\section{import语句}
import语句的一般使用方法之前已有接触，比如import math，然后要使用math宏包里面的函数或者类等需要使用这样的带点的变量名结构：math.pi。

此外import语句还有一个常见的缩写名使用技巧，比如import numpy as np，那么后面就可以这样写了， np.array，而不是numpy.array。


\section{from语句}
from语句的使用有以下两种情况：
\begin{Verbatim}
from this import this
from what import *
\end{Verbatim}
第一种形式是点名只导入某个变量，第二种形式是都导入进来。我想读者肯定知道这点，使用第二种导入形式的时候要小心变量名覆盖问题，这个自己心里有数即可。


\section{reload函数}
reload函数可以重新载入某个宏包，这个重载和程序重新运行第一次载入宏包又有点区别。








\part{python3高级篇}
\chapter{类}
\section{静态方法}
\begin{Verbatim}
class Test:
#    @staticmethod
    def hello():
        print('aaa')

test=Test()
test.hello()
\end{Verbatim}
在上面的例子中，我们希望创造一个函数，这个函数和self或者其他类都没有关系（这里的其他类一般指继承来的）。如上所示，hello函数只是希望简单打印一小段字符，如上面这样的代码是错误的，如果我们在这个函数上面加上\textbf{@staticmethod}，那么上面这段代码就不会出错了，

\begin{Verbatim}
class Test:
    @staticmethod
    def hello():
        print('aaa')

test=Test()
test.hello()
\end{Verbatim}
这样在类里面定义出来的函数叫做这个类的静态方法，静态方法同样可以继承等等，而静态方法通常使用最大的特色就是不需要建立实例，即可以直接从类来调用，如下所示：
\begin{Verbatim}
class Test:
    @staticmethod
    def hello():
        print('aaa')

Test.hello()
\end{Verbatim}





\chapter{模块}
多个宏包py文件组成一个多文件夹目录的整体就是一个模块，这个暂时还用不到而且处理起来更加复杂，暂时略过。

\chapter{pyqt4GUI设计}
具体内容请参看文件夹\textbf{pyqt4指南}。




\part{常用的宏包}
\chapter{pickle宏包}
\label{sec:pickle宏包}
pickle宏包可以将某\uwave{一个}复杂的对象永久存入\uwave{一个}文件中，以后再导入这个文件，这样自动将这个复杂的对象导入进来了。
\section{将对象存入文件}
\begin{Verbatim}
import pickle

class Test:
    def __init__(self):
        self.a=0
        self.b=0
        self.c=1
        self.d=1

    def __str__(self):
        return str(self.__dict__)

if __name__ == '__main__':
    test001=Test()
    print(test001)
    testfile=open('data.pkl','wb')
    pickle.dump(test001,testfile)
    testfile.close()
\end{Verbatim}

\section{从文件中取出对象}
值得一提的是从文件中取出对象，原来的类的定义还是必须存在，也就是声明一次在内存中的，否则会出错。
\begin{Verbatim}
import pickle

class Test:
    def __init__(self):
        self.a=0
        self.b=0
        self.c=1
        self.d=1

    def __str__(self):
        return str(self.__dict__)

if __name__ == '__main__':
    testfile=open('data.pkl','rb')
    test001=pickle.load(testfile)
    print(test001)
    testfile.close()
\end{Verbatim}


\chapter{shelve宏包}

\chapter{collections宏包}





%这里空一行

\end{common-format}
\end{document}