%!Mode:: "TeX:UTF-8"%確保文檔utf-8編碼
%新加入的命令如下：addchtoc addsectoc reduline showendnotes hlabel
%新加入的环境如下：common-format  fig  xverbatim

\documentclass[12pt,oneside]{book}
\newlength{\textpt}
\setlength{\textpt}{12pt}


\usepackage{book}
\usepackage{title}



\begin{document}
\frontmatter

\titlea{python3指南}
\titleb{用python3玩转电脑}
\author{万泽}
\authorinfo{作者：}
\editor{德山书生}
\email{a358003542@gmail.com}
\editorinfo{编者：}
\version{0.1}
\titleLB

\addchtoc{前言}
\chapter*{前言}
\begin{common-format}
本书讨论了python3语言的基础和进阶,并对python3中的一些常用模块进行了介绍。其中有关python3语言本身的基础和进阶知识为本书的着重点,将求全面和详细的讨论。


%这里空一行。

\end{common-format}


\addchtoc{目录}
\setcounter{tocdepth}{2}
\tableofcontents

\begin{common-format}
\mainmatter

\part{python3基础}

\chapter{beginning}
\section{python简介}
Python是个成功的脚本语言。它最初由Guido van Rossum开发，在1991年第一次发布。Python由ABC和Haskell语言所启发。Python是一个高级的、通用的、跨平台、解释型的语言。一些人更倾向于称之为动态语言。它很易学，Python是一种简约的语言。它的最明显的一个特征是，不使用分号或括号，Python使用缩进。现在，Python由来自世界各地的庞大的志愿者维护。

python现在主要有两个版本区别，python2和python3。作为新学者推荐完全使用python3编程，本文档完全基于python3。

完全没有编程经验的人推荐简单学一下c语言和scheme语言（就简单学习一下这个语言的基本概念即可）。相信我学习这两门语言不会浪费你任何时间，其中scheme语言如果你学得深入的话甚至编译器的基本原理你都能够学到。了解了这两门语言的核心理念，基本上任何语言在你看来都大同小异了。

\section{进入python的REPL环境}
在ubuntu13.10下终端中输入python即进入python语言的REPL环境，目前默认的是python2。你可以运行：
\begin{tcbbash}[]
python  --version
\end{tcbbash}
来查看。要进入python3在终端中输入python3即可。


\section{python3命令行用法}
命令行的一般格式就是：
\begin{tcbbash}[]
python3  [可选项]  test.py  [可选参数1 可选参数2]
\end{tcbbash}

同样类似的运行\verb+python3  --help+即可以查看python3命令的一些可选项。比如加入\textbf{-i}选项之后，python执行完脚本之后会进入REPL环境继续等待下一个命令，这个在最后结果一闪而过的时候有用。后面的-c，-m选项还看不明白。

\subsection{python执行脚本参数的传递}
上面的命令行接受多个参数都没有问题的，不会报错，哪怕你在py文件并没有用到他们。在py文件中要使用他们，首先导入sys模块，然后sys.argv[0]是现在这个py文件在系统中的文件名，接下来的sys.argv[1]就是之前命令行接受的第一个参数，后面的就依次类推了。


\section{geany的相关配置}
geany的其他配置这里不做过多说明，就自动执行命令默认的应该是python2，修改成为：
\begin{Verbatim}
python3  -i  %f  
\end{Verbatim}
即可。


\section{代码注释}
python语言的注释符号和bash语言（linux终端的编程语言）一样用的是\#{}符号来注释代码。然后py文件开头一般如下面代码所示：
\begin{Verbatim}
#!/usr/bin/env python3
#-*-coding:utf-8-*-
\end{Verbatim}
其中代码第一行表示等下如果py文件可执行模式执行那么将用python3来编译\footnote{也就是用chmod加上可执行权限那么可以直接执行了。第一行完整的解释是什么通过\textit{env}程序来搜索python的路径，这样代码更具可移植性。}，第二行的意思是py文件编码是utf-8编码的，python3直接支持utf-8各个符号，这是很强大的一个更新。

多行注释可以利用编辑器快速每行前面加上\#{}符号。

\section{Unicode码支持}
前面谈及python3是可以直接支持Unicode码的，如果以可执行模式加载，那么第二行需要写上：
\begin{Verbatim}
#-*-coding:utf-8-*-
\end{Verbatim}
这么一句。

读者请实验下面这个小例子，这将打印一个笑脸符号：
\begin{xverbatim}[129]{py}
#!/usr/bin/env python3
#-*-coding:utf-8-*-
print('\u263a')
\end{xverbatim}

上面的数字就是笑脸符号具体的Unicode码（十六进制）。


\section{代码多行表示一行}
这个技巧防止代码越界所以经常会用到。用反斜线\textbackslash 即可。不过更常用的是将表达式用圆括号( )括起来，这样内部可以直接换行并继续。在python中任何表达式都可以包围在圆括号中。

\subsection{一行表示多行}
python中一般不用分号，但是分号的意义大致和bash或者c语言中的意义类似，表示一行结束的意思。其中c语言我们知道是必须使用分号的。



\section{输入和输出}
\subsection{最基本的input和print命令}
input函数请求用户输入，并将这个值赋值给某个变量。注意赋值之后类型是字符串，但后面你可以用强制类型转换——int函数（变成整数），float函数（变成实数），str函数（变成字符串）——将其转变过来。print函数就是一般的输出函数。

读者请运行下面的例子：
\begin{tcbpython}[]
x=input('请输入一个实数：')
string='你输入的这个实数乘以2等于：'+ str(float(x)*2)
print(string)
\end{tcbpython}


\section{\_{}\_{}main\_{}\_{}和\_{}\_{}name\_{}\_{}}
按照\href{http://stackoverflow.com/questions/419163/what-does-if-name-main-do}{这个网站}的讲解，如果当前这个py文件是被执行的，那么\verb+__name__+在本py文件中的值是\verb+__main__+，如果这个py文件是被作为模块引入的，那么\verb+__name__+在那个py文件中的值是本py文件作为模块的模块名。比如说你随便新建一个test.py文件，这个py文件里面就简单打印\verb+__name__+的值，这个时候你会发现\verb+__name__+的值是字符"test"，如果是mymodule模块里的mymod.py文件，那么在这个py文件里面其\verb+__name__+的值是"mymodule.mymod"。



\chapter{程序中的操作对象}
python和c语言不同，c 是什么\verb+int x = 3+ ，也就是这个变量是整数啊，字符啊什么的都要明确指定，python不需要这样做，只需要声明\verb+x ＝ 3+即可。但是我们知道任何程序语言它到最后必然要明确某一个变量（这里也包括后面的更加复杂的各个结构对象）的内存分配，只是python语言帮我们将这些工作做了，所以就让我们省下这份心吧。

\begin{Verbatim}
''' 这是一个多行注释
    你可以在这里写上很多废话
    '''
x = 10
print(x,type(x))
\end{Verbatim}

python程序由各个模块（modules）组成，模块就是各个文件。模块由声明（statements）组成，声明由表达式（expressions）组成，表达式负责创造和操作对象（objects）。在python中一切皆对象。python语言内置对象（数值、字符串、列表、数组、字典、文件、集合、其他内置对象。）后面会详细说明之。


\section{赋值}
python中的赋值语法非常的简单，x=1，就是一个赋值语句了。和c语言不同，c是必须先声明int x之类，开辟一个内存空间，然后才能给这个x赋值。而python的x=1语句实际上至少完成了三个工作：一，判断1的类型（动态类型语言必须要这步）；二，把这个类型的对象存储在内存里面；三，创建x这个名字和这个名字指向这个内存，x似乎可以称之为对应c语言的指针对象。

\subsection{序列赋值}
\begin{xverbatim}[129]{py}
x,y=1,'a'
[z,w]=['b',10]
print(x,y,z,w)
\end{xverbatim}

我们记得python中表达式可以加上圆括号，所以这里\verb+x,y+产生的是一个数组\verb+(x,y)+，然后是对应的数组平行赋值，第二行是列表的平行赋值。这是一个很有用的技巧。

在其他语言里面常常会介绍swap函数，就是接受两个参数然后将这两个参数的值交换一下，交换过程通常要用到临时变量。而在python中不需要再创建一个临时变量了，因为序列赋值会自动生成一个临时的右边的序列（其中的变量都对应原来的原始值），然后再\uwave{一一对应}赋值（这里强调一一对应是指两边的序列长度要一致。）

\subsubsection{交换两个元素}
在python中交换两个元素用序列赋值形式是很便捷的：
\begin{Verbatim}
>>> x = 1
>>> y = 2
>>> x,y = y,x
>>> print(x,y)
2 1
\end{Verbatim}
这个过程显然不是先执行x=y然后执行y=x，如上所述的，程序首先右边创建一个临时的序列，其中的变量都对应原来的值，即\verb+x,y=(2,1)+，然后再进行序列赋值。



\subsection{同时赋相同的值}
\begin{xverbatim}[129]{py}
x=y='a'
z=w=2
print(x,y,z,w)
\end{xverbatim}

这种语句形式c语言里面也有，不过内部实现机制就非常的不一样了。python当声明x=y的时候，x和y是相同的指针值，然后相同的指针值都指向了'a'这个字符串对象，也可以说x和y就是一个东西，只是取的名字不同罢了。

我们用is语句\footnote{is语句用来测试对象的同一性，就是真正是内存里的同一个东西，而不仅仅是值相同而已。==只是确保值相同。}来测试，显示x和y就是一个东西。
\begin{Verbatim}
>>> x=y='a'
>>> x is y
True
>>> x == y
True
\end{Verbatim}


但如果写成这种形式：
\begin{Verbatim}
>>> x = 'a'
>>> y = 'a'
>>> x is y
True
\end{Verbatim}
x和y还是指向的同一个对象，关于这点python内部是如何实现的我还不太清楚（似乎有点神奇）。为了说明is语句功能正常这里再举个例子吧：
\begin{Verbatim}
>>> x = [1,2,3]
>>> y = [1,2,3]
>>> x == y
True
>>> x is y
False
\end{Verbatim}
我们看到这里就有了两个列表对象，我的一个推测是可变的对象会多次生成，而不可变的对象多个变量是共用的。那么我们看一下元组的情况：
\begin{Verbatim}
>>> x = (1,2,3)
>>> y = (1,2,3)
>>> x is y
False
\end{Verbatim}
元组不可变，不过他们也不是两个共用的，打住了，这个问题到此吧，有点偏题了。



\subsection{增强赋值语句}
x=x+y可以写作x += y。类似的还有：
\begin{tabular}{|c|c|c|}
\hline 
+= & \&{}= & >>= \\ 
\hline 
-= & |= & <<= \\ 
\hline 
*= & \^{}= & **= \\ 
\hline 
/= & \%{}= & //= \\ 
\hline 
\end{tabular} 

\subsection{序列解包赋值}
具体内容请参看后面的序列解包赋值这一小节\ref{sec:序列解包赋值}。

\subsection{可迭代对象的迭代赋值}
在我们对python语言有了深入的了解之后，我们发现python中迭代思想是深入骨髓的。我们在前面接触了序列的赋值模式之后，发现似乎这种赋值除了临时创建右边的序列之外，还似乎与迭代操作有关，于是我们推测python的这种平行赋值模式可以扩展到可迭代对象，然后我们发现确实如此！
\begin{Verbatim}
>>> x,y,z= map(lambda x : x+2,[-1,0,1])
>>> print(x,y,z)
1 2 3
\end{Verbatim}

最后要强调一点的是确保变量名和后面的可迭代对象的输出元素数目是一致的，当然进一步扩展的序列解包赋值也是支持的：
\begin{Verbatim}
>>> x,y,*z= map(lambda x : x+2,[-1,0,1,2])
>>> print(x,y,z)
1 2 [3, 4]
\end{Verbatim}
通配赋值，我喜欢这样称呼了，通配之后收集的元素在列表里面；而函数参数的通配传递，收集的元素是在元组里面。

最后我们总结到，可迭代对象的赋值就是迭代操作加上各个元素的一对一的赋值操作。


\section{数值}
python的数值的内置类型有：int，float，complex等\footnote{这些int、float等命令都是强制类型转换命令}。\\python的基本算术运算操作有加减乘除（+ - * /）。然后‘=’表示赋值，类似数学书上的中缀表达式和优先级和括号法则等，这些都是一般编程语言说到烂的东西了。

\begin{Verbatim}
print((1+2)*(10-5)/2)
print(2**100)
\end{Verbatim}


\subsection{二进制八进制十六进制}
二进制的数字以0b（零比）开头，八进制的数字以0o（零哦）开头，十六进制的数字以0x（零艾克斯）开头。
\begin{Verbatim}
0b101010, 0o177, 0x9ff
\end{Verbatim}

以二进制格式查看数字使用bin命令，以十六进制查看数字使用hex命令。
\begin{Verbatim}
>>> bin(42)
'0b101010'
>>> hex(42)
'0x2a'
\end{Verbatim}

\subsubsection{进制转换小程序}

\begin{tcbpython}[]
number=input("请输入一个数字：")
number= eval(number)
#
radix= input('''请输入你想转换的进制系统
2   表示  二进制
8   表示  八进制
16  表示  十六进制
''')
radix =eval(radix)

while True:
    if radix == 2:
        print(bin(number))
        break
    elif radix == 8:
        print(oct(number))
        break
    elif radix == 16:
        print(hex(number))
        break
    else:
        print("sorry you input the wrong radix")
\end{tcbpython}
程序运行的情况如下所示：
\begin{Verbatim}
请输入一个数字：20
请输入你想转换的进制系统
2   表示  二进制
8   表示  八进制
16  表示  十六进制
8
0o24
\end{Verbatim}

此外基于字符串的进制转换可以用字符串的format方法来处理之。



\subsection{数学幂方运算}
$ x^y $，x的y次方如上面第二行所述就是用\verb+x**y+这样的形式即可。此外pow函数作用是一样的，\verb+pow(x,y)+。


\subsection{数值比较}
数值比较除了之前提及的>，<，==之外，>=，<=，!=也是有的（大于等于，小于等于，不等于）。此外python还支持连续比较，就是数学格式$a<x<b$，x在区间$(a,b)$的判断。在python中可以直接写成如下形式：\verb+a<x<b+。这实际实现的过程就是两个比较操作的进一步与操作。

\subsection{相除取商或余}
就作为正整数相除使用\verb+x//y+得到的值意义还是很明显的就是\textbf{商}。带上负号感觉有点怪了，这里先略过。相关的还有\textbf{取余}数，就是\verb+x%y+，这样就得到x除以y之后的余数了，同样带上负号情况有变，这里先略过。



\subsection{复数}
python直接支持复数， 复数的写法是类似\verb|1+2j|这样的形式，然后如果z被赋值了一个复数，这样它就是一个复数类型，那么这个类具有两个属性量，\textbf{real}和\textbf{imag}。也就是使用\verb+z.real+就给出这个复数的实数部。imag是imaginary number的缩写，虚数，想像出来的数。

\subsection{abs函数}
大家都知道abs函数是绝对值函数，这个python自带的，不需要加载什么模块。作用于复数也是可以的：
\begin{Verbatim}
z=3+4j
print(z.real,z.imag)
print(abs(z))
\end{Verbatim}

这个和数学中复数绝对值的定义完全一致，也就是复数的模：\\
$ \left| z \right| =\sqrt { a^{ 2 }+b^{ 2 } }  $

\subsection{round函数}
简单的理解就是这个函数实现了对数值的\uwave{四舍五入}功能。
\begin{Verbatim}
>>> round(3.1415926)
3
>>> round(3.1415926,0)
3.0
>>> round(3.1415926,1)
3.1
>>> round(3.1415926,2)
3.14
>>> round(3.1415926,4)
3.1416
\end{Verbatim}

这里第二个参数接受0或者负数多少有点没意义了，一般使用还是取1或大于1的数吧，意思就是保留几位小数。


\subsection{min，max和sum函数}
\label{sec:sum函数}
min，max函数的用法和sum的用法稍微有点差异，简单起见可以认为min，max，sum都接受一个元组或者列表（还有其他？），然后返回这个元组或者列表其中的最小值，最大值或者相加总和。此外min和max还支持min(1,2,3)这样的形式，而sum不支持。
\begin{Verbatim}
>>> min((1,6,8,3,4))
1
>>> max([1,6,8,3,4])
8
>>> sum([1,6,8,3,4])
22
>>> min(1,6,8,3,4)
1
\end{Verbatim}



\subsection{位操作}
python支持位操作的，这里简单说一下：位左移操作<<，位与操作\&{}，位或操作|，位异或操作\^{}。
\begin{Verbatim}
>>> x=0b0001
>>> bin(x << 2)
'0b100'
>>> bin(x | 0b010)
'0b11'
>>> bin(x & 0b1)
'0b1'
>>> bin(x ^ 0b101)
'0b100'
\end{Verbatim}




\subsection{math模块}
在\verb+from math import *+之后，可以直接用符号pi和e来引用圆周率和自然常数。此外math模块还提供了很多数学函数，比如：
\begin{description}
\item[sqrt] 开平方根函数，sqrt(x)。
\item[sin] 正弦函数，类似的还有cos，tan等，sin(x)。
\item[degrees] 将弧度转化为角度，三角函数默认输入的是弧度值。
\item[radians] 将角度转化位弧度，radians(30)。 
\item[log] 开对数，log(x,y)，即$\log_y x$，y默认是e。
\item[exp] 指数函数，exp(x)。
\item[pow] 扩展了内置方法，现在支持float了。pow(x,y)
\end{description}

这里简单写个例子：
\begin{Verbatim}
>>> from math import *
>>> print(pi)
3.141592653589793
>>> print(sqrt(85))
9.219544457292887
>>> print(round(sin(radians(30)),1))#sin(30°)
0.5
\end{Verbatim}

\begin{large}
更多内容请参见\href{http://docs.python.org/3.4/library/math.html}{官方文档}。
\end{large}



\subsection{random模块}
random模块提供了一些函数来解决随机数问题。
\begin{description}
\item[random] random函数产生0到1之间的随机实数（包括0）。\\ random()->[0.0, 1.0)。
\item[uniform] uniform函数产生从a到b之间的随机实数（a，b的值指定，包括a。）。\\ uniform(a,b)->[a.0, b.0)。
\item[randint] randint函数产生从a到b之间的随机整数，包含a和b。\\ randint(a,b)->[a,b]
\item[choice] choice随机从一个列表或者字符串中取出一个元素。
\item[randrange] randrange函数产生从a到b之间的随机整数，步长为c（a，b，c的值指定，相当于choice(range(a,b,c))。整数之间就用randint函数吧，这里函数主要是针对range函数按照步长从而生成一些整数序列的情况。
\item[sample(p,k)] sample函数从p中随机选取唯一的元素（p一般是range(n)或集合之类的，这里所谓的唯一的意思就是不放回抽样的意思，但如果p样品里面有重复的元素，最后生成的列表还是会有重复的元素的。）然后组成k长度的列表返回。
\end{description}

下面是一个简单的例子：
\begin{Verbatim}
>>> from random import *
>>> print(random())
0.36882919781549717
>>> print(uniform(1,10))
2.771065174892699
>>> print(randrange(1,6))
1
>>> print(randint(1,10))
3
>>> print(choice('abcdefghij'))
j
>>> print(choice(['①','②','③']))
①
\end{Verbatim}



作为随机实数，所谓开始包含的那个临界值可能数学意义大于实际价值，你可以写一个类似下面的小脚本看一下，随机实数是很难随机到某个具体的数的。
\begin{tcbpython}[]
from random import *
i = 0
while True:
    x = uniform(0,2)
    if x == 0:
        print(i)
        break
    else:
        print(x)
        i += 1
\end{tcbpython}

从上一个例子我们看到，虽然我不确定随具体随机到某个实数的概率是不是永远也没有可能，但肯定很小很小。所以如果我们要解决某个问题，需要某个确定的概率的话还是用随机整数好一些。


\begin{large}
更多内容请参见\href{http://docs.python.org/3.4/library/random.html}{官方文档}。
\end{large}


\subsection{statistics模块}
这个模块python3.4才加入进来。

上面的那个例子这里稍作修改，使之成为一个骰子模拟器。其中\verb+i_list+这个列表收集多次实验中掷多少次骰子才遇到6的次数。
\begin{tcbpython}[]
from random import *
i_list = []
while len(i_list) < 100:
    i = 1
    while True:#一次实验
        x = randint(1,6)
        if x == 6:
            print('times:' , i)
            break
        else:
            print(x)
            i += 1
    i_list.append(i)

print(i_list)
from statistics import *
print(mean(i_list))#平均值
print(median(i_list))#中位数，去掉最高最低...
\end{tcbpython}

statistics模块中的\textbf{mean}函数接受一组数值列表，然后返回这组数值的平均值。而\textbf{median}函数返回的是统计学上所谓的中位数，你可以简单看作一组数字不断的去掉一个最高和最低，然后剩下来的一个或者两个（两个要取平均值）的数值的值。


\begin{large}
更多内容请参见\href{https://docs.python.org/3/library/statistics.html}{官方文档}。
\end{large}


\section{序列}
字符串，列表，元组（tuple，这里最好翻译成元组，因为里面的内容不一定是数值。）都是序列（sequence）的子类，所以序列的一些性质他们都具有，最好在这里一起讲方便理解记忆。

\subsection{len函数}
len函数返回序列所含元素的个数：
\begin{xverbatim}[129]{py}
string001='string'
list001=['a','b','c']
tuple001=(1,2,3,4)

for x in [string001,list001,tuple001]:
    print(len(x))
\end{xverbatim}


\subsection{调出某个值}
对于序列来说后面跟个方括号，然后加上序号（程序界的老规矩，从0开始计数。），那么调出对应位置的那个值。还以上面那个例子来说明。
\begin{xverbatim}[129]{py}
string001='string'
list001=['a','b','c']
tuple001=(1,2,3,4)

for x in [string001,list001,tuple001]:
    print(x[2])
\end{xverbatim}

\subsubsection{倒着来}
倒着来计数-1表示倒数第一个，-2表示倒数第二个。依次类推。
\begin{xverbatim}[129]{py}
string001='string'
list001=['a','b','c']
tuple001=(1,2,3,4)

for x in [string001,list001,tuple001]:
    print(x[-1],x[-2])
\end{xverbatim}

\subsection{调出多个值}
\label{sec:调出多个值}
前面不写表示从头开始，后面不写表示到达尾部。中间加个冒号的形式表示从那里到那里。这里\textbf{注意}后面那个元素是\uwave{不包括}进来，看来python区间的默认含义都是包头不包尾。这样如果你想要最后一个元素也进去，只有使用默认的不写形式了。
\begin{xverbatim}[129]{py}
string001='string'
list001=['a','b','c']
tuple001=(1,2,3,4)

for x in [string001,list001,tuple001]:
    print(x[1:3],x[-2:-1],x[:-1],x[1:],x[1:-1])
\end{xverbatim}
用数学半开半闭区间的定义来理解这里的包含关系还是很便捷的。
\begin{enumerate}
\item 首先是数学半开半闭区间，左元素和右元素都是之前叙述的对应的定位点。左元素包含右元素不包含。
\item 其次方向应该是从左到右，如果定义的区间是从右到左，那么将产生空值。
\item 如果区间超过，那么从左到右包含的所有元素就是结果，\uwave{不会返回错误}。
\item 最后如果左右元素定位点相同，那么将产生空值，比如：\\
\verb+string001[2:-4]+，其中2和-4实际上是定位在同一个元素之上的。额外值得一提的列表插入操作，请参看列表的插入操作这一小节。\ref{sec:列表插入操作}
\end{enumerate}


\subsection{序列反转}
这是python最令人叹为观止的地方了，其他的语言可能对列表啊什么的反转要编写一个复杂的函数，我们python有一种令人感动的方法。

\begin{xverbatim}[129]{py}
string001='string'
list001=['a','b','c']
tuple001=(1,2,3,4)

for x in [string001,list001,tuple001]:
    print(x[::-1])
\end{xverbatim}


之前在range函数的介绍时提及序列的索引和range函数的参数设置很是类似，这是我们可以参考理解之，序列（列表，字符串等）的索引参数[start:end:step]和range函数的参数设置一样，第一个参数是起步值，第二个参数是结束值，第三个参数是步长。这里end不填都好理解，就是迭代完即可，不过如果step是负数，似乎起点不填默认的是-1。

然后range函数生成的迭代器对象同样接受这种索引参数语法，看上去更加的怪异了：
\begin{Verbatim}
>>> range(1,10,2)
range(1, 10, 2)
>>> range(1,10,2)[::-2]
range(9, -1, -4)

>>> list(range(1,10,2))
[1, 3, 5, 7, 9]
>>> list(range(1,10,2)[::-2])
[9, 5, 1]
\end{Verbatim}
我们可以看到对range函数进行切片操作之后返回的仍然是一个range对象，经过了一些修正。似乎这种切片操作和类的某个特殊方法有关，和python的slice对象有关。


\subsection{序列的可更改性}
字符串不可以直接更改，但可以组合成为新的字符串；列表可以直接更改；元组不可以直接更改。


\subsection{序列的加法和减法}
两个字符串相加就是字符串拼接了。乘法就是加法的重复，所以一个字符串乘以一个数字就是自己和自己拼接了几次。列表还有元组和字符串一样大致情况类似。

\begin{xverbatim}[129]{py}
print('abc'+'def')
print('abc'*3)
print([1,2,3]+[4,5,6])
print((0,'a')*2)
\end{xverbatim}


\section{字符串}
python语言不像c语言字符和字符串是不分的，用单引号或者双引号包起来就表示一个字符串了。单引号和双引号的区别是一般用单引号，如果字符串里面有单引号，那么就使用双引号，这样单引号直接作为字符处理而不需要而外的转义处理——所谓转义处理和其他很多编程语言一样用\textbackslash 符号。比如要显示\verb+'+就输入\verb+\'+。

\subsection{三单引号和三双引号}
在单引号或者双引号的情况下，你可以使用\verb+\n+来换行，其中\textbackslash n表示换行。此外还可以使用三单引号'''或者三双引号"""来包围横跨多行的字符串，其中换行的意义就是换行，不需要似前面那样的处理。

\begin{Verbatim}
print('''\
这是一段测试文字
  this is a test line
      其中空白和    换行都所见所得式的保留。''')
\end{Verbatim}


\subsection{startswith方法}
\begin{Verbatim}
>>> x = 'helloABC'
>>> x
'helloABC'
>>> x.startswith('hello')
True
>>> x.endswith('ABC')
True
\end{Verbatim}

\begin{description}
\item[startswith] 测试字符串是否以某个子字符串开始
\item[endswith] 测试某个字符串是否以某个子字符串结束
\end{description}


\subsection{find方法}
字符串的find方法可用来查找某个子字符串，没有找到返回-1，找到了返回字符串的偏移量。用法就是：\verb+s.find('d')+。


\subsection{replace方法}
字符串的replace方法进行替换操作，接受两个参数：第一个参数是待匹配的子字符串，第二个参数是要替换成为的样子。
\begin{Verbatim}
>>> print('a b 11 de'.replace('de','ding'))
a b 11 ding
>>> print('1,1,5,4,1,6'.replace('1','replaced'))
replaced,replaced,5,4,replaced,6
\end{Verbatim}




\subsection{upper方法}
将字符串转换成大写形式。
\begin{Verbatim}
>>> str='str'
>>> str.upper()
'STR'
\end{Verbatim}

类似的还有：
\begin{description}
\item[lower] 都变成小写
\item[capitalize] 首字母大写，其它都小写。
\end{description}



\subsection{isdigit方法}
\begin{description}
\item[isdigit] 测试是不是数字
\item[isalpha] 测试是不是字母
\item[isalnum] 测试是不是数字或字母
\end{description}

值得注意的是就算是字母组成的语句，如果中间有空格isalpha方法也会返回False。

\subsection{split方法}
字符串的split方法可以将字符串比如有空格或者逗号等分隔符分割而成，可以将其分割成子字符串列表。默认是空格是分隔符。
\begin{Verbatim}
>>> string='a=1,b=2,c=3'
>>> string.split(',')
['a=1', 'b=2', 'c=3']
\end{Verbatim}

\subsubsection{splitline方法}
把一个字符串按照行分开。这个可以用上面的split方法然后接受\verb+\n+参数来实现，所不同的是splitline方法不需要接受参数：
\begin{Verbatim}
>>> string
'this is line one\nthis is line two\nthis is line three'
>>> string.splitlines()
['this is line one', 'this is line two', 'this is line three']
>>> string.split('\n')
['this is line one', 'this is line two', 'this is line three']
\end{Verbatim}




\subsection{join方法}
字符串的join方法非常有用，严格来说它接受一个迭代器参数，不过最常见的是列表。将列表中的多个字符串连接起来，我们看到他采用了一种非常优雅的方式，就是只有两个字符串之间才插入某个字符，这正是我们所需要的。具体例子如下所示：
\begin{Verbatim}
>>> list001=['a','b','c']
>>> "".join(list001)
'abc'
>>> ','.join(list001)
'a,b,c'
\end{Verbatim}


\subsection{strip方法}

\subsubsection{rstrip方法}
字符串右边的空格都删除。换行符也会被删除掉。

\subsubsection{lstrip方法}
类似rstrip方法，字符串左边的空格都删除。换行符也会被删除掉。


\subsection{format方法}
字符串的format方法方便对字符串内的一些变量进行替换操作，其中花括号不带数字跟format方法里面所有的替换量，带数字0表示第一个替换量，后面类推。此外还可以直接用确定的名字引用。
\begin{Verbatim}
>>> print('1+1={0}，2+2={1}'.format(1+1,2+2))
1+1=2，2+2=4
>>> print('my name is {name}'.format(name='Jim T Kirk'))
my name is Jim T Kirk
\end{Verbatim}

\subsection{转义和不转义}
\verb+\n    \t  +这是一般常用的转义字符，换行和制表。此外还有\verb+\\+输出\textbackslash 符号。

如果输出字符串不想转义那么使用如下格式：
\begin{Verbatim}
>>> print(r'\t \n \test')
\t \n \test
\end{Verbatim}

\subsection{count方法}
统计字符串中某个字符或某一连续的子字符串出现的次数。
\begin{Verbatim}
>>> string = 'this is a test line.'
>>> string.count('this')
1
>>> string.count('t')
3
\end{Verbatim}


\section{列表}
方括号包含几个元素就是列表。


\subsection{列表的插入操作}
\label{sec:列表插入操作}
字符串和数组都不可以直接更改所以不存在这个问题，列表可以。其中列表还可以以一种定位在相同元素的区间的方法来实现插入操作，这个和之前理解的区间多少有点违和，不过考虑到定位在相同元素的区间本来就概念模糊，所以在这里就看作特例，视作在这个\uwave{定位点相同元素之前}插入吧。
\begin{xverbatim}[129]{py}
list001=['one','two','three']
list001[1:-2]=['four','five']
print(list001)
\end{xverbatim}

extend方法似乎和列表之间的加法重合了，比如list.extend([4,5,6])就和list=list+[4,5,6]是一致的，而且用加法表示还可以自由选择是不是覆盖原定义，这实际上更加自由。

insert方法也就是列表的插入操作：
\begin{Verbatim}
>>> list = [1,2,3,4]
>>> list.insert(0,5)
>>> list
[5, 1, 2, 3, 4]
>>> list.insert(2,'a')
>>> list
[5, 1, 'a', 2, 3, 4]
\end{Verbatim}


\subsection{append方法}
python的append方法就是在最后面加\textbf{一个元素}，如果你append一个列表那么这一个列表整体作为一个元素。然后append方法会永久的改变了该列表对象的值。

\uwave{记住，append等等原处修改列表的方法都是没有返回值的。}
\begin{Verbatim}
>>> list = [1,2,3,4]
>>> list.append(5)
>>> list
[1, 2, 3, 4, 5]
\end{Verbatim}

如果你希望不改动原列表的附加，请使用加法来操作列表。

\subsection{reverse方法}
reverse方法不接受任何参数，直接将一个列表\uwave{永久性地}翻转过来。如果你希望不改变原列表的翻转，有返回值，请使用如下方法：
\begin{Verbatim}
>>> list
[1, 2, 3, 4, 5]
>>> listNew = list[::-1]
>>> list
[1, 2, 3, 4, 5]
>>> listNew
[5, 4, 3, 2, 1]
\end{Verbatim}

\subsection{copy方法}
copy方法复制返回本列表。


\subsection{sort方法}
也就是排序，\uwave{永久性}改变列表。默认是递增排序，可以用\textbf{reverse=True}来调成递减排序。

默认的递增排序顺序如果是数字那么意思是数字越来越大，如果是字符那么（似乎）是按照ACSII码编号递增来排序的。如果列表一些是数字一些是字符会报错。
\begin{Verbatim}
>>> list = ['a','ab','A','123','124','5']
>>> list.sort()
>>> list
['123', '124', '5', 'A', 'a', 'ab']
\end{Verbatim}

sort方法很重要的一个可选参数\textbf{key=function}，这个function函数就是你定义的函数（或者在这里直接使用lambda语句。），这个函数只接受一个参数，就是排序方法（在迭代列表时）接受的当前的那个元素。下面给出一段代码，其中tostr函数将接受的对象返回为字符，这样就不会出错了。
\begin{xverbatim}[129]{py}
def tostr(item):
    return str(item)

list001 = ['a','ab','A',123,124,5]

list001.sort(key=tostr)

print(list001)
\end{xverbatim}

\subsubsection{sorted函数}
sorted函数在这里和列表的sort方法最大的区别是它返回的是\uwave{一个新的列表}而不是原处修改。其次sorted函数的第一个参数严格来说是所谓的可迭代对象，也就是说它还可以接受除了列表之外的比如\uwave{元组字典}等可迭代对象。至于用法他们两个差别不大。

\begin{Verbatim}
>>> sorted((1,156,7,5))
[1, 5, 7, 156]
>>> sorted({'andy':5,'Andy':1,'black':9,'Black':55},key=str.lower)
['Andy', 'andy', 'black', 'Black']
\end{Verbatim}

上面第二个例子调用了\textbf{str.lower}函数，从而将接受的item，这里比如说'Andy'，转化为andy，然后参与排序。也就成了对英文字母大小写不敏感的排序方式了。

\paragraph{字典按值排序}
同样类似的有字典按值排序的方法\footnote{\href{http://www.cnpythoner.com/post/266.html}{参考网站}}：

\begin{Verbatim}
>>> sorted({'andy':5,'Andy':1,'black':9,'Black':55}.items(),key=lambda i: i[1])
[('Andy', 1), ('andy', 5), ('black', 9), ('Black', 55)]
\end{Verbatim}

这个例子先用字典的items方法处理返回(key,value)对的可迭代对象，然后用后面的lambda方法返回具体接受item的值，从而根据值来排序。


\paragraph{中文排序}
下面这个例子演示了如何对中文名字排序。整个函数的思路就是用\href{https://github.com/mozillazg/python-pinyin}{pypinyin}（一个第三方模块），将中文姓名的拼音对应出来，然后组成一个列表，然后根据拼音对这个组合列表排序，然后生成目标列表。
\begin{tcbpython}[]
list001=['张三','李四','王二','麻子','李二','李一']
def zhsort(lst):
    from pypinyin import  lazy_pinyin
    pinyin=[lazy_pinyin(lst[i]) for i in range(len(lst))]
    lst0=[(a,b) for (a,b) in zip(lst,pinyin)]
    lst1= sorted(lst0, key=lambda d:d[1])
    return [x[0] for x in lst1]
print(zhsort(list001))
\end{tcbpython}
\begin{Verbatim}
['李二', '李四', '李一', '麻子', '王二', '张三']
\end{Verbatim}



\subsection{删除某个元素}
\begin{itemize}
\item 赋空列表值，相当于所有元素都删除了。 
\item pop方法：接受一个参数，就是列表元素的定位值，然后那个元素就删除了，方法并返回那个元素的值。如果不接受参数默认是删除最后一个元素。
\item remove方法：移除第一个相同的元素，如果没有返回相同的元素，返回错误。
\item del函数：删除列表中的某个元素。
\end{itemize}

\begin{Verbatim}
>>> list001=['a','b','c','d','e']
>>> list001.pop(2)
'c'
>>> list001
['a', 'b', 'd', 'e']
>>> list001.pop()
'e'
>>> list001
['a', 'b', 'd']
>>> list001.remove('a')
>>> list001
['b', 'd']
>>> del list001[1]
>>> list001
['b']
\end{Verbatim}


\subsection{count方法}
统计某个元素出现的次数。
\begin{Verbatim}
>>> list001=[1,'a',100,1,1,1]
>>> list001.count(1)
4
\end{Verbatim}


\subsection{index方法}
index方法返回某个相同元素的偏移值。
\begin{Verbatim}
>>> list001=[1,'a',100]
>>> list001.index('a')
1
\end{Verbatim}


\subsection{列表解析}
\label{sec:列表解析}
我们来看下面这个例子：
\begin{xverbatim}[129]{py}
def square(n):
    return n*n
    
print(list(map(square,[1,2,3,4,5])))
print([square(x) for x in [1,2,3,4,5]])
\end{xverbatim}
map函数将某个函数应用于某个列表的元素中并生成一个map对象（可迭代对象），需要外面加上list函数才能生成列表形式。第二种方式更有python风格，是推荐使用的列表解析方法。

在python中推荐多使用迭代操作和如上的列表解析风格，因为python中的迭代操作是直接用c语言实现的。

\subsubsection{列表解析加上过滤条件}
for语句后面可以跟一个if子句表示过滤条件，看下面的例子来理解吧：
\begin{Verbatim}
>>> [s*2 for s in ['hello','abc','final','help'] if s[0] == 'h']
['hellohello', 'helphelp']
\end{Verbatim}

这个例子的意思是列表解析，找到的元素进行乘以2的操作，其中过滤条件为字符是h字母开头的，也就是后面if表达式不为真的元素都被过滤掉了。


\subsubsection{完整的列表解析结构}
下面给出一个完整的列表解析结构，最常见的情况一般就一两个for语句吧，这里if外加个括号是可选项的意思。
\begin{Verbatim}
[ expression for var1 in iterable1 [if condition1 ]
                    for var2 in iterable2 [if condition2 ]
                    ........
                            ]
\end{Verbatim}

这里的逻辑是从左到右第一个for语句就是最先执行的for语句，然后是第二个for语句跟着执行。

这里的iterable1是指某个可迭代对象，也就是说那些能够返回可迭代对象的函数比如map，filter，zip，range等函数都可以放进去。不过我们要克制自己在这里别写出太过于晦涩的程序了。还有for循环语句也别嵌套太多了，这样就极容易出错的。

下面这个程序大家看看：
\begin{Verbatim}
>>> [x+str(y) for x in ['a','b','c'] for y in [1,2,3,4,5,6] if y & 1]
['a1', 'a3', 'a5', 'b1', 'b3', 'b5', 'c1', 'c3', 'c5']
>>> [x+str(y) for x in ['a','b','c'] for y in [1,2,3,4,5,6] if not  y & 1]
['a2', 'a4', 'a6', 'b2', 'b4', 'b6', 'c2', 'c4', 'c6']
\end{Verbatim}

\subsubsection{列表解析的好处}
在熟悉列表解析的语句结构之后，一两个for语句不太复杂的情况下，还是很简单明了的。同时语法也更加精炼，同时运行速度较for循环要至少快上一倍。最后python的迭代思想深入骨髓，以后python的优化工作很多都围绕迭代展开，也就是多用列表解析会让你的代码以后可能运行的更快。

有这么多的好处，加上这么cool的pythonic风格，推荐大家多用列表解析风格解决问题。


\subsubsection{元组的生成}
这个时候需要明确加个括号表示这是一个元组对象。
\begin{Verbatim}
>>> [(x,x**2) for x in range(5)]
[(0, 0), (1, 1), (2, 4), (3, 9), (4, 16)]
\end{Verbatim}



\subsection{for语句中列表可变的影响}
一般情况for迭代某个可迭代对象就是可迭代对象返回一个值然后利用这个值赋值并进行下面的操作，但是列表却是一个可变的东西，如果列表在操作中被修改了，情况会怎样呢？

\begin{tcbpython}[]
lst = [1,2,3,4,5]
index = 0
for x in lst:
    lst.pop(index)
    print(x)
\end{tcbpython}

\begin{Verbatim}
1
3
5
\end{Verbatim}

具体这个过程的细节我不清楚，但确定的是在这里for语句并没有记忆原列表，而只是记忆了返回次数或者偏移值。

\subsection{列表元素替换}
推荐用列表解析方法来实现列表元素的替换功能。
\begin{tcbpython}[]
def replace(x,a,b):
    if x == a:
        return b
    else:
        return x

lst=[1,5,4,1,6]
\end{tcbpython}
\begin{Verbatim}
>>> [replace(i,1,'replaced') for i in lst]
['replaced', 5, 4, 'replaced', 6]
\end{Verbatim}

\subsection{列表元素去重}
列表元素去重推荐用后来的set集合对象来处理之，其会自动去除重复的元素。请参看下面的集合一小节\ref{sec:集合}。
\begin{Verbatim}
>>> lst = [1,2,3,4,5,1,2,3,4,5]
>>> [i for i in set(lst)]
[1, 2, 3, 4, 5]
\end{Verbatim}


\section{字典}
与列表一样字典是可变的，可以像列表一样引用然后原处修改，del语句也适用。

\subsection{创建字典}
字典是一种映射，并没有从左到右的顺序，只是简单地将键映射到值。字典的声明格式如下：
\begin{Verbatim}
dict001={'name':'tom','height':'180','color':'red'}
dict001['name']
\end{Verbatim}

或者创建一个空字典，然后一边赋值一边创建对应的键：
\begin{Verbatim}
dict002={}
dict002['name']='bob'
dict002['height']=195
\end{Verbatim}

所以对字典内不存在的键赋值是可行的。

\subsubsection{根据列表创建字典}
如果是[['a',1],['b',2],['c',3]]这样的形式，那么直接用dict函数处理就变成字典了，如果是['a','b','c']和[1,2,3]这样的形式那么需要用zip函数处理一下，然后用dict函数处理一次就变成字典了：
\begin{Verbatim}
>>> lst
[['a', 1], ['b', 2], ['c', 3]]
>>> dict001=dict(lst)
>>> dict001
{'a': 1, 'b': 2, 'c': 3}
\end{Verbatim}

zip函数的例子请参看后面的\ref{sec:字典解析}。



\subsection{字典里面有字典}
和列表的不同就在于字典的索引方式是根据“键”来的。
\begin{Verbatim}
dict003={'name':{'first':'bob','second':'smith'}}
dict003['name']['first']
\end{Verbatim}

\subsection{字典遍历操作}
字典特定顺序的遍历操作的通用做法就是通过字典的keys方法收集键的列表，然后用列表的sort方法处理之后用for语句遍历，如下所示：
\begin{Verbatim}
dict={'a':1,'c':2,'b':3}
dictkeys=list(dict.keys())
dictkeys.sort()
for key in dictkeys:
    print(key,'->',dict[key])
\end{Verbatim}

\emph{警告}：上面的例子可能对python早期版本并不使用，因为python中一大规则是对对象的原处修改的函数并没有返回值。上面的语句只是到了python3后期才能适用，保险起见，推荐使用sorted函数，sorted函数是默认对字典的键进行排序并返回键的值组成的列表。
\begin{Verbatim}
dict={'a':1,'c':3,'b':2}
>>> for key in sorted(dict):
...   print(key,'->',dict[key])
... 
a -> 1
b -> 2
c -> 3
\end{Verbatim}


如果你对字典遍历的顺序没有要求，那么就可以简单的这样处理：
\begin{Verbatim}
>>> for key in dict:
...     print(key,'->',dict[key])
... 
c -> 2
a -> 1
b -> 3
\end{Verbatim}


\subsubsection{keys方法}
收集键值，返回\uwave{可迭代对象}。

\subsubsection{values方法}
和keys方法类似，收集的值，返回\uwave{可迭代对象}。
\begin{Verbatim}
>>> dict001.values()
dict_values([3, 1, 2])
>>> list(dict001.values())
[3, 1, 2]
\end{Verbatim}

\subsubsection{items方法}
和keys和values方法类似，不同的是返回的是(key,value)对的\uwave{可迭代对象}。
\begin{Verbatim}
>>> dict001.items()
dict_items([('c', 3), ('a', 1), ('b', 2)])
>>> list(dict001.items())
[('c', 3), ('a', 1), ('b', 2)]
\end{Verbatim}



\subsection{字典的in语句}
可以看到in语句只针对字典的键，不针对字典的值。
\begin{Verbatim}
>>> dict001={'a':1,'b':2,'c':3}
>>> 2 in dict001
False
>>> 'b' in dict001
True
\end{Verbatim}

\subsection{字典对象的get方法}
get方法是去找某个键的值，为什么不直接引用呢，get方法的好处就是某个键不存在也不会出错。
\begin{Verbatim}
>>> dict001={'a':1,'b':2,'c':3}
>>> dict001.get('b')
2
>>> dict001.get('e')
\end{Verbatim}

\subsection{update方法}
感觉字典就是一个小型数据库，update方法将另外一个字典里面的键和值覆盖进之前的字典中去，称之为更新，没有的加上，有的覆盖。
\begin{Verbatim}
>>> dict001={'a':1,'b':2,'c':3}
>>> dict002={'e':4,'a':5}
>>> dict001.update(dict002)
>>> dict001
{'c': 3, 'a': 5, 'e': 4, 'b': 2}
\end{Verbatim}

\subsection{pop方法}
pop方法类似列表的pop方法，不同引用的是键，而不是偏移地址，这个就不多说了。



\subsection{字典解析}
\label{sec:字典解析}
这种字典解析方式还是很好理解的。
\begin{Verbatim}
>>> dict001={x:x**2 for x in [1,2,3,4]}
>>> dict001
{1: 1, 2: 4, 3: 9, 4: 16}
\end{Verbatim}

\subsubsection{zip函数创建字典}
可以利用zip函数来通过两个可迭代对象平行合成一个配对元素的可迭代对象，然后用dict函数将其变成字典对象。具体的理解请参看深入理解python3的迭代这一章\ref{sec:深入理解python3的迭代}。
\begin{Verbatim}
>>> dict001=zip(['a','b','c'],[1,2,3])
>>> dict001
<zip object at 0xb7055eac>
>>> dict001=dict(dict001)
>>> dict001
{'c': 3, 'b': 2, 'a': 1}
\end{Verbatim}




\section{集合}
\label{sec:集合}
python实现了数学上的无序不重复元素的集合概念，在前面讨论列表去重元素的时候我们提到过正好可以利用集合的这一特性。

\begin{Verbatim}
>>> list001=[1,2,3,1,2,4,4,5,5,5,7]
>>> {x for x in list001}
{1, 2, 3, 4, 5, 7}
>>> set(list001)
{1, 2, 3, 4, 5, 7}
\end{Verbatim}
用集合解析的形式表示出来就是强调set命令可以将任何可迭代对象都变成集合类型。当然如果我们希望继续使用列表的话使用list命令强制类型转换为列表类型即可，不过如果我们在应用中确实一致需要元素不重复这一特性，就可以考虑直接使用集合作为主数据操作类型。

集合也是可迭代对象。关于可迭代对象可以进行的列表解析操作等等就不啰嗦了。下面介绍集合的一些操作。

\subsection{集合添加元素}
值得一提的是如果想创建一个空的集合, 需要用set命令，用花括号{}系统会认为你创建的是空字典。然后我们看到用集合的\textbf{add}方法添加，那些重复的元素是添加不进来的。

\emph{警告}：值得一提的是集合只能包括不可变类型，因此列表和字典不能作为集合内部的元素。元组不可变，所以可以加进去。还有\uwave{集合也是不可以包括进去的}，觉得这点好逊啊，数学里面的集合概念能够包含集合那是基本的特性啊，感觉这点不修正好还是用列表方便些。

\begin{Verbatim}
>>> set001=set()
>>> set001.add(1)
>>> set001
{1}
>>> set001.add(2)
>>> set001
{1, 2}
>>> set001.add(1)
>>> set001
{1, 2}
\end{Verbatim}

或者使用update方法一次更新多个元素：
\begin{Verbatim}
>>> set001=set('a')
>>> set001.update('a','b','c')
>>> set001
{'b', 'a', 'c'}
\end{Verbatim}


\subsection{集合去掉某个元素}
有两个集合对象的方法可以用于去掉集合中的某个元素，discard方法和remove方法，其中discard方法如果删除集合中没有的元素那么什么都不会发生，而remove方法如果删除某个不存在的元素那么会产生KeyError。

\begin{Verbatim}
>>> set001=set('hello')
>>> set001.discard('h')
>>> set001
{'e', 'o', 'l'}
>>> set001.discard('l')
>>> set001
{'e', 'o'}
\end{Verbatim}

remove方法与之类似就不做演示了。

\subsection{两个集合之间的关系}

\subsubsection{子集判断}
集合对象有一个issubset方法用于判断这个集合是不是那个集合的子集。
\begin{Verbatim}
>>> set001=set(['a','b'])
>>> set002=set(['a','b','c'])
>>> set001.issubset(set002)
True
\end{Verbatim}

还有更加简便的方式比较两个集合之间的关系，那就是>，<，>=，<=，==这样的判断都是适用的。也就是set001是set002的子集，它的元素set002都包含，那么set001<=set002，然后真子集的概念就是set001<set002即不等于即可。


\subsection{两个集合之间的操作}
下面的例子演示的是两个集合之间的交集：\emph{\&{}}，并集：\emph{|}，差集：\emph{-}。
\begin{Verbatim}
>>> set001=set('hello')
>>> set002=set('hao')
>>> set001 & set002 #交集
{'o', 'h'}
>>> set001 | set002 #并集
{'h', 'l', 'a', 'e', 'o'}
>>> set001 - set002 #差集
{'e', 'l'}
\end{Verbatim}


类似的集合对象还有intersection方法，union方法，difference方法：
\begin{Verbatim}
>>> set001=set('hello')
>>> set002=set('hao')
>>> set001.intersection(set002) #交集
{'h', 'o'}
>>> set001.union(set002) #并集
{'e', 'a', 'h', 'o', 'l'}
>>> set001.difference(set002) #差集
{'e', 'l'}
\end{Verbatim}


\subsection{clear方法}
将一个集合清空。

\subsection{copy方法}
类似列表的copy方法，制作一个集合copy备份然后赋值给其他变量。

\subsection{pop方法}
无序弹出集合中的一个元素，直到没有然后返回KeyError错误。



\section{元组}
圆括号包含几个元素就是元组(tuple)。元组和列表的不同在于元组是不可改变。元组也是从属于序列对象的，元组的很多方法之前都讲了。而且元组在使用上和列表极其接近，有很多内容这里也略过了。

值得一提的是如果输入的时候写的是\textit{x,y}这样的形式，实际上表达式就加上括号了，也就是一个元组了\textit{(x,y)}。

\subsection{生成器表达式}
类似列表解析，如果元组在这里解析也是返回的元组吗？这里并不是如此，前面谈到python中一般表达式的圆括号是忽略了的，所以这里的元组解析表示式有个更专门的名字叫做生成器表达式，它返回的是生成器对象，和生成器函数具体调用之后返回的对象是一样的。生成器对象具有\verb+__next__+方法，可以调用next函数。
\begin{Verbatim}
>>> x = [i for i in [1,2,3]]
>>> x
[1, 2, 3]
>>> y = (i for i in [1,2,3])
>>> y
<generator object <genexpr> at 0xb70dbe8c>
\end{Verbatim}



\section{bytes类型}
一般就使用str字符串类型然后使用默认的utf-8编码，然后大部分情况下不会有任何问题。不过在对于某些文件操作（比如处理图像或者声音文件等）和网络通信等领域，还是需要接触字节流这个概念的。

python3为了真正支持二进制数据的处理，引入了一个新的类型bytes。bytes字节类型的定义是8位整数的不可变序列，表示绝对的字节值。bytes类型支持之前谈论的str也就是常用的字符串类型的几乎所有的操作：包括类型内部的方法，序列操作，re模块匹配等，但不包括字符串的格式化（也就是format方法）。

虽然bytes类型也可以打印，因为8位整数正好对应ASCⅡ的编码，但这只是使用方便罢了，最好还是把bytes看作纯数值没有任何字符含义的二进制数据。我们在读取文件的时候也分为常规读取和以二进制形式读取（需要加个b字符），这些都涉及到编码问题。

bytes类型有一个decode方法，可以把自己按照某种编码方式（比如'big5'或'utf-8'等）进行解码\footnote{二进制数据难读，相当于密码。}。字符串类型有一个encode方法，就是把这个字符串按照某种编码方式进行编码。
\begin{Verbatim}
>>> string001='你好'
>>> bytes001=string001.encode('utf-8')
>>> bytes001
b'\xe4\xbd\xa0\xe5\xa5\xbd'
>>> bytes002=string001.encode('big5')
>>> bytes002
b'\xa7A\xa6n'
>>> string002=bytes002.decode('utf-8')
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
UnicodeDecodeError: 'utf-8' codec can't decode byte 0xa7 in position 0: invalid start byte
>>> string002=bytes002.decode('big5')
>>> string002
'你好'
\end{Verbatim}

我们看到不同编码解码弄混了会出问题，本来想找个例子然后出现字符混乱的情况的。


\section{bytearray类型}


\section{文件}
文件对象是可迭代对象。

\subsection{写文件}
对文件的操作首先需要用\textbf{open}函数创建一个文件对象，简单的理解就是把相应的接口搭接好。文件对象的\textbf{write}方法进行对某个文件的写操作，最后需要调用\textbf{close}方法写的内容才真的写进去了。

\begin{Verbatim}
file001 = open('test.txt','w')
file001.write('hello world1\n')
file001.write('hello world2\n')
file001.close()
\end{Verbatim}

如果你们了解C语言的文件操作，在这里会为python语言的简单便捷赞叹不已。就是这样三句话：创建一个文件对象，然后调用这个文件对象的wirte方法写入一些内容，然后用close方法关闭这个文件即可。


\subsection{读文件}
一般的用法就是用\textbf{open}函数创建一个文件对象，然后用\textbf{read}方法调用文件的内容。最后记得用\textbf{close}关闭文件。
\begin{Verbatim}
file001 = open('test.txt')
filetext=file001.read()
print(filetext)
file001.close()
\end{Verbatim}

此外还有\textbf{readline}方法是一行一行的读取某文件的内容。


\subsection{open函数的处理模式}
open函数的处理模式如下：
\begin{description}
\item['r'] 默认值，read，读文件。
\item['w'] wirte，写文件，如果文件不存在会创建文件，如果文件已存在，文件原内容会清空。
\item['a'] append，附加内容，也就是后面用write方法内容会附加在原文件之后。
\item['b'] 处理模式设置的\uwave{附加}选项，'b'不能单独存在，要和上面三个基本模式进行组合，比如'rb'等，意思是二进制数据格式读。
\item['+'] 处理模式设置的\uwave{附加}选项，同样'+'不能单独存在，要和上面三个基本模式进行组合，比如'r+'等，+是updating更新的意思，也就是既可以读也可以写，那么'r+'，'w+'，'a+'还有什么区别呢？区别就是'r+'不具有文件创建功能，如果文件不存在会报错，然后'r+'不会清空文件，如果'r+'不清空文件用write方法情况会有点复杂；而'w+'具有文件创建功能，然后'w+'的write方法内容都是重新开始的；而'a+'的write方法内容是附加在原文件上的，然后'a+'也有文件创建功能。
\end{description}



\subsection{用with语句打开文件}
类似之前的例子我们可以用with语句来打开文件，这样就不用close方法来关闭文件了。然后with语句来提供了类似try语句的功能可以自动应对打开文件时的一些异常情况。

\begin{tcbpython}[]
with open('test.txt','w') as file01:
    file01.write('hello world1\n')
    file01.write('hello world2\n')

with open('test.txt','r') as file01:
    filetext=file01.read()
    print(filetext)
\end{tcbpython}



\subsection{除字符串外其他类型的读取}
文本里面存放的都是字符串类型，也就是写入文件需要用str函数强行将其他类型转变成字符串类型，而读取进来想要进行一些操作则需要将字符串类型转变回去。比如用int或者float等，不过列表和字典的转变则需要\textbf{eval}函数。

eval这个函数严格来讲作用倒不是为了进行上面说的类型转换的，它就是一个内置函数，一个字符串类型python代码用eval函数处理了之后就能转变为可执行代码。
\begin{Verbatim}
>>> eval('1+1')
2
>>> eval('[1,2,3]')
[1, 2, 3]
>>> eval("{'a':1,'b':2,'c':3}")
{'c': 3, 'b': 2, 'a': 1}
\end{Verbatim}

推荐使用pickle模块来处理其他类型的文件读写问题，相对来说更简单更安全。请参看pickle模块这一小节\ref{sec:pickle模块}。





\chapter{程序中的逻辑}
\section{布尔值}
\label{sec:布尔值}
boolean类型，和大多数语言一样，就两个值：\textbf{True}，\textbf{False}。然后强制类型转换使用函数\textbf{bool}。

\subsection{其他逻辑小知识}
在python中，有些关于逻辑真假上的小知识，需要简单了解下。
\begin{itemize}
\item 数0、空对象或者其他特殊对象None值都认为是假\sidenote{比如列表都是真，但空列表是假。}
\item 其他非零的数字或非空的对象都认为是真
\item 前面两条用bool函数可以进行强制类型转换
\item 比较和相等测试会递归作用在数据结构中
\item 比较和相等测试会返回True或False（1和0的custom version（翻译为定制版？））
\end{itemize}

\subsection{None}
有些函数没有return的值就会返回None值，None值是NoneType对象中的一个值，和列表的空值等是不同的，它和其他任何值都不一样的。比如re.search如果没有找到匹配就会返回None值。这个时候需要知道得是None值在逻辑上是逻辑假，not None是逻辑真。
\begin{Verbatim}
>>> def f():
...  pass
... 
>>> y = f()
>>> y
>>> type(y)
<class 'NoneType'>
\end{Verbatim}

（is 和 == 的区别对None的影响？） 这里 y is None 和y == None 都返回True。没看出区别。


\section{if条件判断}
python中的条件语句基本格式如下：
\begin{Verbatim}
if  test:
    条件判断执行区块
\end{Verbatim}

也就是if命令后面跟个条件判断语句，然后记住加个冒号，然后后面缩进的区块都是条件判断为真的时候要执行的语句。

\begin{Verbatim}
if  test:
    do something001
else :
    do something002
\end{Verbatim}

这里的逻辑是条件判断，如果真，do something001；如果假，do something002。

\begin{Verbatim}
if  test001:
    do something001
elif test002:
    do something002
\end{Verbatim}

显然你一看就明白了，elif是else和if的结合。


\subsection{逻辑与或否}
and表示逻辑与，or表示逻辑或，not表示逻辑否。

下面编写一个逻辑，判断一个字符串，这个字符串开头必须是a或者b，结尾必须是s，倒数第二个字符不能是单引号'。在这里就演示一下逻辑。。
\begin{xverbatim}[129]{py}
x='agais'
if ((x[0] == 'a' or x[0] == 'b')
    and x[-1] =='s'
    and (not x[-2] =="'")):
    print('yes it is..')
\end{xverbatim}



\subsection{稍复杂的条件判断}
现在我们了解了if，elif和else语句，然后还了解了逻辑与或非的组合判断。那么在实际编程中如何处理复杂的条件逻辑呢？

首先能够用逻辑语句“与或非”组合起来的就将其组合起来，而不要过分使用嵌套。如下面代码所示，如果一个情况分成两部分，那么就用if...else...语句，
\begin{tcbpython}[]
x=-2
if x>0:
    print('x大于0')
else:
    print('x小于0')
\end{tcbpython}

而如果一个情况分成三部分，那么就用if...elif...else语句。同一深度的这些平行语句对应的是“或”逻辑，或者说类似其他编程语言的switch语句。
\begin{tcbpython}
x=2
if x>0:
    print('x大于0')
elif x<0:
    print('x小于0')
else:
    print('x等于0')
\end{tcbpython}

我们再看一看下面的代码，这个代码是\emph{错误的}，两个if语句彼此并不构成逻辑分析关系。\footnote{四个甚至更多的平行或逻辑就用更多的elif，读者请自己实验一下。}
\begin{tcbpython}
x=2
if x>0:
    print('x大于0')
if x<0:
    print('x小于0')
else:
    print('x等于0')
\end{tcbpython}


然后我们看到下面的代码，这个例子演示的是在加深一个深度的条件判断语句它当时处于的逻辑判断情况，这个语句的条件判断逻辑是本语句的判断逻辑再和左边（也就是前面）的判断逻辑的“与”逻辑，或者说成是“交集”。比如说\textit{print('0<x<2')}这个语句就是本语句的判断逻辑\textit{x<2}和上一层判断逻辑\textit{x>0}的“交集”，也就是\textit{0<x<2}。

\begin{tcbpython}
x=-2
if x>0:
    print('x大于0')
    if x>2:
        print('x>2')
    elif x<2:
        print('0<x<2')
    else:
        print('x=2')
elif x<0:
    print('x小于0')
else:
    print('x等于0')
\end{tcbpython}


整个过程的情况如下图所示：
\begin{linefig}{复杂条件判断}
\caption{复杂条件判断}
\label{fig:复杂条件判断}
\end{linefig}
为了在编程的时候对处于何种判断逻辑之下有一个清晰的认识，强烈建议读者好好思考一下。毕竟磨刀不误砍柴功。


\subsection{try语句捕捉错误}
try语句是编程中用来处理可能出现的错误或者已经出现但并不打算应付的错误最通用的方式。比如一个变量你预先想的是接受一个数值，但是用户却输入了一个字符，这个时候你就可以将这段语句包围在try里面；或者有时你在编程的时候就发现了这种情况，只是懒得理会他们，那么简单的把这块出错的语句包围在try里面，然后后面跟个except语句，打印出一个信息“出错了”，即可。用法如下所示：
\begin{tcbpython}
while True:
    x=input('请输入一个数，将返回它除以2之后的数值\n输入"quit"退出\n')
    if x=='quit':
        break
    try :
        num=float(x)
        print(num/2)
    except:
        print('出错了')
\end{tcbpython}

\subsubsection{异常处理完整语句}
\begin{Verbatim}
try:
    yourCode
except yourError:
    do something
except yourError2:
    do something2
......
else:
    do somethingN
finally:
    do the funallystuff
\end{Verbatim}

这个语句的逻辑是试着执行try区块下的语句，如果出现异常，那么看是不是异常yourError，如果是则执行do something，如果是yourError2，则执行do something2 ......等等，如果没有异常，则do somethingN，如果还有异常，则这个异常将会返回（更上面的控制程序）。

那么finally语句的作用是什么呢，finally语句实际上和整个语句中异常判断情况没有关系，不管有没有异常发生，最后它都将被执行。和简单地不缩进直接写在下面的语句比起来，finally语句的特点就是就算程序发生异常了，它也会先被执行，然后将异常上传给上面的控制程序。

else语句和finally语句是可选的，根据具体情况来看。

\subsection{in语句}
in语句对于可迭代对象都可以做出是否某个元素包含在某个对象之中的判断。
\begin{Verbatim}
>>> 'a' in ['a',1,2]
True
>>> dict
{'a': 1, 'c': 2, 'b': 3, 'd': 4}
>>> 'e' in dict
False
>>> '2' in dict
False
\end{Verbatim}
从上面例子可以看到，一般的列表判断元素是否存在和我们之前预料的一致，关于字典需要说的就是in语句\uwave{只判断键}，不判断值。


\section{for迭代语句}
一般有内部重复操作的程序可以先考虑for迭代结构实现，实在不行才考虑while循环结构，毕竟简单更美更安全。

python的for迭代语句有点类似lisp语言的dolist和dotimes函数，具体例子如下：
\begin{xverbatim}[129]{py}
for x in 'abc':
    print(x)
\end{xverbatim}
in后面跟的是\textbf{序列}类型，也就是字符串，列表，数组都是可以的。这个语句可以看作先执行x='a'或者类似的匹配赋值操作，然后执行缩进的区块，后面依次类推。（所以for语句也支持序列解包赋值，请参看：\ref{sec:序列解包赋值}）

\subsection{else分句}
\begin{Verbatim}
for x in 'abc':
    if x == 'b':
        print(x)
        break
else:
    print('test')
\end{Verbatim}

for语句加上else分句这种形式，如果for迭代完了就会执行else分句。但如果for语句还在迭代过程中，break或者return出来了，那么else分句将不会被执行。


\subsection{range函数}
range函数常和for迭代语句一起使用，其返回一个可迭代对象。

\begin{Verbatim}
range(1,10,2)
\end{Verbatim}

range函数的用法如上，表示从1开始到10，步长为2，如果用list函数将其包裹，将会输出[1,3,5,7,9]。如果不考虑步长的话，这个range函数就有点类似于在序列调出多个值那一小节\ref{sec:调出多个值}谈论的区间的情况。所以range(10)就可以看作[0,10)，range(1,10)就可以看作[1,10)。但是在这里再加上步长的概念和区间的概念又有所不同了。

\begin{xverbatim}[129]{py}
for x in range(-10,-20,-3):
    print(x)
\end{xverbatim}
上面例子还演示了range的负数概念，这里如果用区间概念来考察的话，是不能理解的，之所以行得通，是因为它的步长是负数，如果不是负数，那么情况就会和之前讨论的结果类似，将是一个空值。


\subsection{迭代加上操作}
迭代产生信息流并经过某些操作之后生成目标序列，更多内容请参见列表解析一节\ref{sec:列表解析}。
\begin{Verbatim}
>>> squares=[x**2 for x in [1,2,3,4,5]]
>>> squares
[1, 4, 9, 16, 25]
\end{Verbatim}


\subsection{enumerate函数}
enumerate函数返回一个enumerate对象，这个对象将偏移值和元素组合起来，成为一个可迭代对象了。

\begin{Verbatim}
>>> enu = enumerate('abcd')
>>> [i for i in enu]
[(0, 'a'), (1, 'b'), (2, 'c'), (3, 'd')]
\end{Verbatim}


\section{while循环}
while语句用法和大多数编程语言类似，就是条件控制，循环结构。
\begin{Verbatim}
while test:
    do something
else :
    do something
\end{Verbatim}

值得一提的是else语句和while语句属于一个整体，通常情况下while执行完了然后执行下面的语句似乎不需要加上else来控制\footnote{最后一下while是False所以会跳转到执行else的语句那里。}。不过else语句的一个功用就是如果while循环的时候遇到break那么else语句也不会执行而是直接跳过去了，见下面。

\subsection{break命令}
break跳出最近的while或者for循环结构。前面谈到了else和while语句构成一个整体的时候，break可以跳过else语句。

\subsection{continue命令}
continue命令接下来的循环结构的执行区块将不执行了，跳到条件判断那里看看是不是继续循环。如果是，那么继续循环。同样在for语句中continue命令的意思也是一样的。


\subsection{pass命令}
pass命令就是什么都不做。pass命令即可用于循环语句也可用于条件语句。

pass命令什么都不做似乎没有什么意义，不过作为一个空占位符还是很有用的。比如你编写一个大型的GUI程序，信号－槽机制都构思好了，只是对应的函数暂时还没写好，这个时候你可以将对应的函数，只是空的函数名加上pass语句写上，这样整个程序就可以继续边编写边调试了。







\chapter{操作或者函数}
函数也是一个对象，叫函数对象。函数名和变量名一样都是引用，函数名后面带个括号才真正实际执行。比如下面不带括号就只是返回了对这个函数对象的引用地址。
\begin{Verbatim}
>>> print
<built-in function print>
\end{Verbatim}

要理解函数也是一个对象，比如在下面的例子中，fun刚开始是一个函数列表，然后在for的迭代语句里，意思具体就是multiply这个函数对象，然后接下来又是plus这个函数对象。整个过程是对x*a然后再加上b。即$ a*x +b $

\begin{tcbpython}[]
x = 3

def multiply(x,a):
    return x*a

def plus(x,b):
    return x+b

fun = [multiply , plus]
para = [3,2]
for fun,para in zip(fun,para):
    x = fun(x,para)
print(x)
\end{tcbpython}



\section{自定义函数}
定义函数用def命令，语句基本结构如下：
\begin{Verbatim}
def yourfunctionname(para001,para002...):
    do something001
    do something002
\end{Verbatim}



\section{参数传递问题}
函数具体参数的值是通过赋值形式\footnote{整个过程有点类似前面讨论的一般赋值语句，但又有点区别的。}来传递的，这有助于理解后面的不定变量函数。而函数的参数名是没有意义的，这个可以用lambda函式来理解之，def定义的为有名函数，有具体的引用地址，但内部作用原理还是跟lambda无名函式一样，形式参数名是x啊y啊都无所谓。为了说明这点，下面给出一个古怪的例子：

\begin{xverbatim}[129]{py}
y=1
def test(x,y=y):
    return x+y
print(test(4))
\end{xverbatim}

输出结果是5。我们看到似乎函数的形式参数y和外面的y不是一个东西，同时参数的传递是通过赋值形式进行的，那么具体是怎样的呢？具体的解释就是函数的形式参数y是这个函数自己内部的\textbf{本地变量}y，和外面的y不一样，更加深入的理解请看下面的变量作用域问题。

然后还有：
\begin{Verbatim}
>>> x=[1,2,3]
>>> for x in x:
...  print(x)
... 
1
2
3
\end{Verbatim}
我们知道for语句每进行一次迭代之前也进行了一次赋值操作，所以for语句里面刚开始定义的这个x和外面的x也不是一个东西，刚开始定义的x也是for语句内部的\textbf{本地变量}。更加深入的理解请看下面的变量作用域问题。

想到这里我又想起之前编写removeduplicate函数遇到的一个问题，那就是for语句针对列表这个可变的可迭代对象的工作原理是如何的？具体请看下面的例子：
\begin{Verbatim}
>>> lst=[1,2,3,4]
>>> for x in lst:
...  print(x,lst)
...  del lst[-1]
... 
1 [1, 2, 3, 4]
2 [1, 2, 3]
\end{Verbatim}
可迭代对象的惰性求值内部机制在我看来很神奇，目前还不太清楚，但从这个例子看来列表的惰性求值并没有记忆内部的数值，只是记忆了\uwave{返回返回值的次数}（合情合理），然后如果迭代产生了StopIteration异常就终止。



\section{变量作用域问题}
python的变量作用域和大部分语言比如c语言或lisp语言的概念都类似，就是函数里面是局部变量，一层套一层，里面可以引用外面，外面不可以引用里面。

具体实现机制是每个函数都有自己的命名空间，（和模块类似）就好像一个盒子一样封装着内部的变量。所谓的本地变量和函数有关，或者其他类似的比如for语句；所谓的全局变量和模块有关，更确切的表述是和文件有关，比如说在现在这个文件里，你可以通过导入其他模块的变量名，但实际上模块导入之后那些变量名都引入到这个文件里面来了。

具体实现和类的继承类似也是一种搜索机制，先搜索本地作用域\sidenote{函数就是有函数作用域的情况也是盒子里面有盒子}，然后是上一层(def，lambda，for)的本地作用域，然后是全局作用域，然后是内置作用域。更加的直观的说明如下图所示：
\begin{fig}{python的变量作用域}
\caption{python的变量作用域}
\label{fig:python的变量作用域}
\end{fig}

简单来说python的变量作用域问题就是：盒子套盒子，搜索是从盒子最里面然后往外面寻找，里面可以用外面的变量，外面的不可以用里面的。


\subsection{内置作用域}
内置作用域就是由一个\verb+__builtin+模块来实现的，python的作用机制最后会自动搜索这个内置模块的变量。这个内置模块里面就是我们前面学习的那些可以直接使用的函数名，比如print，range等等之类的，然后还有一些内置的异常名。

所以我们想到即使对于这些python的内置函数我们也是可以覆盖定义的，事实确实如此：
\begin{Verbatim}
>>> abs(-3)
3
>>> def abs(x):
...  print(x)
... 
>>> abs(3)
3
>>> abs(-3)
-3
\end{Verbatim}


\subsection{global命令}
如果希望函数里面定义的变量就是全局变量，在变量声明的时候前面加上\textbf{global}命令即可。

通常不建议这么做，除非你确定需要这么做，然后你需要写两行代码才能实现，意思也是不推荐你这么做。
\begin{tcbpython}
def test():
    global var
    var= 'hello'
test()
print(var)
\end{tcbpython}

而且就算你这样做了，这个变量也只能在本py文件中被引用，其他文件用不了。推荐的做法是另外写一个专门用于配置参数的config.py文件，然后那些全局变量都放在里面，如果某个文件要用，就import进来。而对与这个config.py文件的修改会影响所有的py文件配置，这样让全局变量可见可管可控更加通用，才是正确的编程方式。


\subsection{nonlocal命令}
nonlocal命令python3之后才出现，这里实现的概念有点类似于lisp语言的闭包(closure技术)，就是如果你有某个需要，需要函数记忆一点自己的状态，同时又不想这个状态信息是全局变量，也不希望用类的方式来实现，那么就可以用nonlocal命令来简单地完成这个任务。

global意味着命名只存在于一个嵌套的模块中，而nonlocal的查找只限于嵌套的def中。要理解nonlocal首先需要理解函数里面嵌套函数的情况——也就是所谓的工厂函数，一个函数返回一个函数对象。比如说
\begin{tcbpython}
def add(x):
    x=x
    def action(y):
        return x+y
    return action
\end{tcbpython}
\begin{Verbatim}
>>> add1=add(1)
>>> add1(5)
6
>>> add2=add(2)
>>> add2(5)
7
\end{Verbatim}
这里的return action是返回一个函数对象，这样add1的实际接口是def action那里。熟悉lisp语言的明白，action外面的那个函数的变量叫做自由变量，不过嵌套函数在这里可以引用自由变量\footnote{如果自己定义那么就是自己的本地变量了，这里的自由变量的意思是嵌套函数自己没有定义，引用母函数的变量。}但\uwave{不能直接修改}自由变量。如果我们声明nonlocal x，那么就可以修改嵌套函数外面声明的变量了。

\begin{tcbpython}
def add(x):
    x=x
    def action(y):
        nonlocal x
        x=x+1
        return x+y
    return action
\end{tcbpython}
\begin{Verbatim}
>>> add2=add(2)
>>> add2(5)
8
>>> add2(5)
9
>>> add2(5)
10
\end{Verbatim}
然后我们看到这个生产出来的函数具有了运行上的状态性，实际上通过类也能构建出类似的效果，不过对于某些问题可能闭包方式处理显得更适合一些。

下面给出一个稍微合理点的例子：
\begin{tcbpython}
def myrange(n):
    i=n
    def action():
        nonlocal i
        while i>0:
            i=i-1
            return i
    return action
\end{tcbpython}

\begin{Verbatim}
>>> myrange5=myrange(5)
>>> myrange5()
4
>>> myrange5()
3
>>> myrange5()
2
>>> myrange5()
1
>>> myrange5()
0
>>> myrange5()
>>> 
\end{Verbatim}

下面给出类似的类的实现方法：
\begin{tcbpython}
class myrange:
    def __init__(self,n):
        self.i=n
    def action(self):
        while self.i > 0:
            self.i -= 1
            return self.i
\end{tcbpython}
\begin{Verbatim}
>>> myrange5=myrange(5)
>>> 
>>> myrange5.action()
4
>>> myrange5.action()
3
>>> myrange5.action()
2
>>> myrange5.action()
1
>>> myrange5.action()
0
>>> myrange5.action()
>>> 
\end{Verbatim}
我们看到从编码思路上基本上没什么差异，可以说稍作修改就可以换成类的实现版本。推荐一般使用类的实现方法。但有的时候可能用类来实现有点不伦不类和大材小用了。这里就不做进一步讨论了，闭包思想是函数编程中很重要的一个思想，学习了解一下也好。



\section{参数和默认参数}
定义的函数圆括号那里就是接受的参数，如果参数后面跟个等号，来个赋值语句，那个这个赋的值就是这个参数的默认值。比如下面随便写个演示程序：
\begin{xverbatim}[129]{py}
def test(x='hello'):
    print(x)
test()
test('world')
\end{xverbatim}


\section{不定参量函数}
我们在前面谈到sum函数\ref{sec:sum函数}只接受一个列表，而不支持这样的形式：sum(1,2,3,4,5)。现在我们设计这样一个可以接受不定任意数目参量的函数。首先让我们看看一种奇怪的赋值方式。

\subsection{序列解包赋值}
\label{sec:序列解包赋值}
\begin{Verbatim}
>>> a,b,*c=1,2,3,4,5,6,7,8,9
>>> print(a,b,c,sep=' | ')
1 | 2 | [3, 4, 5, 6, 7, 8, 9]
>>> a,*b,c=1,2,3,4,5,6,7,8,9
>>> print(a,b,c,sep=' | ')
1 | [2, 3, 4, 5, 6, 7, 8] | 9
>>> *a,b,c=1,2,3,4,5,6,7,8,9
>>> print(a,b,c,sep=' | ')
[1, 2, 3, 4, 5, 6, 7] | 8 | 9
\end{Verbatim}
带上一个星号*的变量变得有点类似通配符的味道了，针对后面的序列\footnote{似乎序列赋值内置迭代操作}（数组，列表，字符串），它都会将遇到的元素收集在一个列表里面，然后说是它的。

for语句也支持序列解包赋值，也是将通配到的的元素收集到了一个列表里面，如：
\begin{xverbatim}[129]{py}
for (a,*b,c) in [(1,2,3,4,5,6),(1,2,3,4,5),(1,2,3,4)]:
    print(b)
\end{xverbatim}


\subsection{函数中的通配符}
\begin{Verbatim}
>>> def test(*args):
...  print(args)
... 
>>> test(1,2,3,'a')
(1, 2, 3, 'a')
\end{Verbatim}
我们看到类似上面序列解包赋值中的带星号表通配的概念，在定义函数的时候写上一个带星号的参量（我们可以想象在函数传递参数的时候有一个类似的序列解包赋值过程），在函数定义里面，这个args就是接受到的参量组成的\emph{元组}。


\subsection{mysum函数}
\begin{xverbatim}[129]{py}
def mysum(*args):
    return sum(args[:])

print(mysum(1,2,3,4,5,6))
\end{xverbatim}
这样我们定义的可以接受任意参数的mysum函数，如上所示。具体过程就是将接受到的args（已成一个元组了），然后用sum函数处理了一下即可。


\subsection{任意数目的可选参数}
在函数定义的写上带上两个星号的变量**args，那么args在函数里面的意思就是接受到的可选参数组成的一个字典值。
\begin{Verbatim}
>>> def test(**args):
...  return args
... 
>>> test(a=1,b=2)
{'b': 2, 'a': 1}
\end{Verbatim}

我们看到利用这个可以构建出一个简单的词典对象生成器。

\subsection{解包可迭代对象传递参数}
之前*args是在函数定义中，然后通配一些参数放入元组中。这里是在函数调用中，针对可迭代对象，可以用一个*星号将其所包含的元素迭代出来，然后和参数一一对应赋值。
\begin{Verbatim}
>>> map = map(lambda x:x+2,[1,2,3])
>>> print(*map)
3 4 5
>>> print(*[1,2,3])
1 2 3
\end{Verbatim}

\subsubsection{最简单的打印文件命令}
前面说到文件也是一个可迭代对象，然后如果在这里解包文件对象将是一个最简单的打印文件命令，简单得惊天地泣鬼神了...
\begin{tcbpython}[]
print(*open('test.py'))
\end{tcbpython}



\subsection{解包字典成为关键字参数}
和上面的类似，通过**args语法可以将某个字典对象解包成为某个函数的关键字参数。还是以上面那个函数f为例子：
\begin{Verbatim}
>>> def f(a,b,c=3):
...  print(a,b,c)
>>> f(**{'c':6,'b':4,'a':2})
2 4 6
>>> f(1,2,5)
1 2 5
\end{Verbatim}

这个例子也告诉我们不是可选参数的a和b同样也可以通过这种字典形式复制。


\section{参数的顺序}
老实说一般参数，可选参数（关键字参数），任意（通配）参数，任意（通配）关键字参数所有这些概念混在一起非常的让人困惑。就一般的顺序是：
\begin{enumerate}
\item 一般参数，这个如果有一定要在第一位，然后通过位置一一对应分配参数。
\item 关键字参数，关键字参数跟在一般参数后面，通过匹配变量名来分配。
\item 通配一般参数，其他额外的非关键字的参数分配到*args元组里面。
\item 通配关键字参数，其他额外的关键字参数分配到**args字典里面，这个必须在最后面。
\end{enumerate}
一般的情况就是这些吧，可能你会遇到更加困难的情况，到时候再说吧。



\section{递归函式}
\label{sec:递归函式}
虽然递归函式能够在某种程度上取代前面的一些循环或者迭代程序结构，不过不推荐这么做。这里谈及递归函式是把某些问题归结为数学函数问题，而这些问题常常用递归算法更加直观（不一定高效）。比如下面的菲波那奇函数：
\begin{xverbatim}[129]{py}
def fib(n):
    if n==0:
        return 1
    if n==1:
        return 1
    else:
        return fib(n-1)+fib(n-2)
        
for x in range(5):
    print(fib(x))
\end{xverbatim}
我们可以看到，对于这样专门的数学问题来说，用这样的递归算法来表述是非常简洁易懂的。至于其内部细节，我们可以将上面定义的fib称之为函式，函式是一种操作的模式，然后具体操作就是复制出这个函式（函数或者操作都是数据），然后按照这个函式来扩展生成具体的函数或者操作。

下面看通过递归函式来写阶乘函数，非常的简洁，我以为这就是最好最美的方法了。
\begin{xverbatim}[129]{py}
def fact(n):
    if n == 0:
        return 1
    else:
        return n*fact(n-1)
        
print(fact(0),fact(10))
\end{xverbatim}

\subsection{什么时候用递归？}
最推荐使用递归的情况是这样的情况，那就是一份工作（或函数）执行一遍之后你能够感觉到虽然所有的工作没有做完，但是已经做了一小部分了，有了一定的进展了，就好比是蚂蚁吞大象一样，那么这个时候你就可以使用递归思想了。其次有的时候有那么一种情况虽然表面上看似乎并没有什么进展，但事情在发展，你能感受到有一个条件最终将会终止程序从而得到一个输出，那么这个时候就可以用递归。

递归思想最核心的两个概念就是一做了一小部分工作，你能感觉到做着做着事情就会做完了；二有一个终止判断最终将会起作用。

其实通过递归函式也可以实现类似for的迭代结构\sidenote{这种情况不推荐使用递归}，不过我觉得递归函式还是不应该滥用。比如下面通过递归函式生成一种执行某个操作n次的结构：

\begin{xverbatim}[129]{py}
def dosomething(n):
    if n==0:
        pass
    elif n==1:
        print('do!')
    else:
        print('do!')
        return dosomething(n-1)

print(dosomething(5))
\end{xverbatim}
可以看到，如果把上面的print语句换成其他的某个操作，比如机器人向前走一步，那么这里dosomething换个名字向前走(5)就成了向前走5步了。

\subsection{lisp的car-cdr递归技术}
在lisp语言中， car-cdr递归技术是很重要的一门技术，它的特长就是遍历随意嵌套的列表结构可以同一对列表中的每一个元素执行某种操作。

首先我们来看下面的例子，一个把任意嵌套列表所有元素放入一个列表中的函数：
\begin{xverbatim}[129]{py}
lst = [[1,2,[3]],[4,[5,[[[[10],11]]]],(1,2,3)],[{'a','b','c'},8,9]]

def is_list(thing):
    return isinstance(thing, list)

def flatten(iter):
    templst = []
    for x in iter:
        if not is_list(x):
            templst.append(x)
        else:
            templst += flatten(x)
    return templst

print(flatten(lst))
\end{xverbatim}

这个函数的逻辑是如果是最小元素对象不是列表，那么收集进列表；如果不是，那么把它展开，这里就是调用的原函数继续展开函式。

上面的例子严格意义上来讲还不算lisp的经典car-cdr递归技术，下面给出一个典型的例子，就是复制任意嵌套结构的列表。当然列表的copy方法就可以做这个工作，这里主要通过这个例子来进一步深入car-cdr技术。

\begin{tcbpython}[]
def is_list(thing):
    return isinstance(thing, list)

def copy_list(lst):
    if  not  is_list(lst):
        return lst
    elif lst == []:
        return []
    else:
        return [copy_list(lst[0])] + copy_list(lst[1:])

print(copy_list([1,[2,6],3]))
\end{tcbpython}


这种嵌套列表的复制以及后面的修改等等操作，最合适的就是lisp的car-cdr技术了，但我不得不承认，这种递归写法是递归函式里面最难懂的了。

不管怎么严格，在这个基础之上，因为第一个if not的语句中传递下来的lst实际上已经是非列表的其他元素了，然后我们可以进行一些其他修改操作，这样在保持原列表的复杂嵌套的基础上，等于遍历的对列表中的所有元素进行了某种操作。

比如所有元素都平方：
\begin{tcbpython}[]
def square(x):
    return x**2

def square_list(lst):
    if  not  is_list(lst):
        return square(lst)
    elif lst == []:
        return []
    else:
        return [square_list(lst[0])] + square_list(lst[1:])

print(square_list([1,[2,6],3]))
\end{tcbpython}

我们可以想像更加复杂功能的函数作用于列表中所有的元素同时又不失去原列表复杂的嵌套结构，lisp的car-cdr这种技术了解一下吧，但是不是一定要使用复杂的嵌套结构呢？也许没有必要吧。。


\section{lambda函式}
lambda
λ表达式这个在刚开始介绍lisp语言的时候已有所说明，简单来说就是函数只是一个映射规则，变量名，函数名都无所谓的。这里就是没有名字的函数的意思。

具体的样子如下面所示：
\begin{xverbatim}[129]{py}
f=lambda x,y,z:x+y+z
print(f(1,2,3))
\end{xverbatim}

lanmbda函式在有些情况下要用到，比如pyqt里面的信号－槽机制用connect方法的时候，槽比如是函数名或者无参函数，如果用户想加入参量的话，可以使用lamba函式引入。

读者如果对lambda函式表达不太熟悉强烈建议先简单学一学\textbf{scheme}语言。

\section{print函数}
print函数因为很常用和基础，就放在这里了。

print函数接受任意的参量，逐个打印出来。然后它还有一些关键字参数，\textbf{sep}：默认值是' '，也就是一个空格，如果修改为空字符串，那么逐个打印出来的字符之间就没有间隔了。\textbf{end}：默认值是'\textbackslash{}n'，\textbf{file}默认值是sys.stdout，也就是在终端显示，你可以修改为某个文件变量，这样直接往某个文件里面输出内容。





\chapter{类}
在python中一切皆对象。前面学的那些操作对象都是python程序语言自己内部定义的对象（Object），而接下来介绍的类的语法除了更好的理解之前的那些对象之外，再就是可以创造自己的操作对象。一般面向对象(OOP)编程的基本概念这里不重复说明了，如有不明请读者自己随便搜索一篇网页阅读下即可。

\section{python中类的结构}
python中的类就好像树叶，所有的类就构成了一棵树，而python中超类，子类，实例的重载或继承关系等就是由一种搜索机制实现的：
\begin{fig}{类搜索结构图}
\label{fig:类搜索结构图}
\end{fig}
python首先搜索self有没有这个属性或者方法，如果没有，就向上搜索。比如说实例l1没有，就向上搜索C1，C1没有就向上搜索C2或C3等。

实例继承了创造他的类的属性，创造他的类上面可能还有更上层的超类，类似的概念还有子类，表示这个 类在树形层次中比较低。

well，简单来说类的结构和搜索机制就是这样的，很好地模拟了真实世界知识的树形层次结构。

上面那副图实际编写的代码如下：
\begin{Verbatim}
class C2: ...
class C3: ...
class C1(C2,C3): ...
l1=C1()
l2=C1()
\end{Verbatim}
其中class语句是创造类，而C1继承自C2和C3，这是多重继承，从左到右是内部的搜索顺序（会影响重载）。l1和l2是根据类C1创造的两个实例。

对于初次接触类这个概念的读者并不指望他们马上就弄懂类这个概念，这个概念倒并一定要涉及很多哲学的纯思考的东西，也可以看作一种编程经验或技术的总结。多接触也许对类的学习更重要，而不是纯哲学抽象概念的讨论，毕竟类这个东西创造出来就是为了更好地描述现实世界的。

最后别人编写的很多模块就是一堆类，你就是要根据这些类来根据自己的情况情况编写自己的子类，为了更好地利用前人的成果，或者你的成果更好地让别人快速使用和上手，那么你需要好好掌握类这个工具。

\section{类的最基础知识}
\subsection{类的创建}
\begin{Verbatim}
class MyClass:
    something
\end{Verbatim}
类的创建语法如上所示，然后你需要想一个好一点的类名。类名规范的写法是首字母大写，这样好和其他变量有所区分。

\subsection{根据类创建实例}
按照如下语句格式就根据MyClass类创建了一个实例myclass001。
\begin{Verbatim}
myclass001=MyClass()
\end{Verbatim}

\subsection{类的属性}
\begin{Verbatim}
>>> class MyClass:
...  name='myclass'
... 
>>> myclass001=MyClass()
>>> myclass001.name
'myclass'
>>> MyClass.name
'myclass'
>>> myclass001.name='myclass001'
>>> myclass001.name
'myclass001'
>>> MyClass.name
'myclass'
\end{Verbatim}
如上代码所示，我们首先创建了一个类，这个类加上了一个name属性，然后创建了一个实例myclass001，然后这个实例和这个类都有了name属性。然后我们通过实例加上点加上name的这种格式引用了这个实例的name属性，并将其值做了修改。

这个例子简单演示了类的创建，属性添加，实例创建，多态等核心概念。后面类的继承等概念都和这些大同小异了。


\subsection{类的方法}
类的方法就是类似上面类的属性一样加上def语句来定义一个函数，只是函数在类里面我们一般称之为方法。这里演示一个例子，读者看一下就明白了。
\begin{Verbatim}
>>> class MyClass:
...  name='myclass'
...  def double(self):
...   self.name=self.name*2
...   print(self.name)
... 
>>> myclass001=MyClass()
>>> myclass001.name
'myclass'
>>> myclass001.double()
myclassmyclass
>>> myclass001.name
'myclassmyclass'
\end{Verbatim}

这里需要说明的是在类的定义结构里面，self代表着类自身，self.name代表着对自身name属性的引用。然后实例在调用自身的这个方法时用的是myclass001.double()这样的结构，这里double函数实际上接受的第一个参数就是自身，也就是myclass001，而不是无参数函数。所以类里面的方法（被外部引用的话）至少有一个参数self。





\section{类的继承}
实例虽然说是根据类创建出来的，但实际上实例和类也是一种继承关系，实例继承自类，而类和类的继承关系也与之类似，只是语法稍有不同。下面我们来看这个例子：
\begin{xverbatim}[129]{py}
class Hero():
    def addlevel(self):
        self.level=self.level+1
        self.hp=self.hp+self.addhp

class Garen(Hero):
    level=1
    hp=455
    addhp=96

garen001=Garen()
for i in range(6):
    print('级别:',garen001.level,'生命值：' ,garen001.hp)
    garen001.addlevel()
\end{xverbatim}

\begin{fig}[0.5]{类的继承示例}
\caption{类的继承示例}
\label{fig:类的继承示例}
\end{fig}

这里就简单的两个类，盖伦Garen类是继承自Hero类的，实例garen001是继承自Garen类的，这样garen001也有了addlevel方法，就是将自己的level属性加一，同时hp生命值也加上一定的值，整个过程还是很直观的。


\section{类的内置方法}
如果构建一个类，就使用pass语句，什么都不做，python还是会为这个类自动创建一些属性或者方法。
\begin{Verbatim}
>>> class TestClass:
...  pass
... 
>>> dir(TestClass)
['__class__', '__delattr__', '__dict__', '__dir__', '__doc__',
 '__eq__', '__format__', '__ge__', '__getattribute__',
  '__gt__',  '__hash__', '__init__', '__le__', '__lt__',
   '__module__', '__ne__', '__new__', '__reduce__', 
   '__reduce_ex__', '__repr__', '__setattr__', 
   '__sizeof__', '__str__', '__subclasshook__',
    '__weakref__']
\end{Verbatim}

这些变量名字前后都加上双下划线是给python这个语言的设计者用的，一般应用程序开发者还是不要这么做。

这些内置方法用户同样也是可以重定义他们从来覆盖掉原来的定义，其中特别值得一讲的就是\verb+__init__+方法或者称之为构造函数。

\subsection{\_\_init\_\_{}方法}
\verb+__init__+方法对应的就是该类创建实例的时候的构造函数。比如：
\begin{Verbatim}
>>> class Point:
...  def __init__(self,x,y):
...   self.x=x
...   self.y=y
... 
>>> point001=Point(5,4)
>>> point001.x
5
>>> point001.y
4
\end{Verbatim}
这个例子重载了\verb+__init__+函数，然后让他接受三个参数，self等下要创建的实例，x，还有y通过下面的语句给这个待创建的实例的属性x和y赋了值。


\subsection{self意味着什么}
self在类中是一个很重要的概念，当类的结构层次较简单时还容易看出来， 当类的层次结构很复杂之后，你可能会弄糊涂。\uwave{self就是指现在引用的这个实例}。比如你现在通过调用某个实例的某个方法，这个方法可能是一个远在天边的某个类给出的定义，就算如此，那个定义里面的self还是指调用这个方法的那个实例，这一点要牢记于心。

比如下面这个例子：
\begin{tcbpython}[]
class Test():
    x = 5
    def __init__(self):
        self.x = 10

test = Test()
\end{tcbpython}
\begin{Verbatim}
>>> test.x
10
>>> Test.x
5
\end{Verbatim}

其中self.x就是对应的创建的实例的属性x，而前面定义的x则是类Test的属性x。

\subsection{类的操作第二版}
现在我们可以写出和之前那个版本相比更加专业的类的使用版本了。
\begin{xverbatim}[129]{py}
class Hero():
    def addlevel(self):
        self.level=self.level+1
        self.hp=self.hp+self.addhp

class Garen(Hero):
    def __init__(self):
        self.level=1
        self.hp=455
        self.addhp=96
        self.skill=['不屈','致命打击','勇气','审判','德玛西亚正义']

garen001=Garen()
for i in range(6):
    print('级别:',garen001.level,'生命值：' ,garen001.hp)
    garen001.addlevel()
print('盖伦的技能有：',"".join([x + '  ' for x in garen001.skill]))
\end{xverbatim}

似乎专业的做法类里面多放点方法，最好不要放属性，不太清楚是什么。但确实这样写给人感觉更干净点，方法是方法，如果没有调用代码就放在那里我们不用管它，后面用了构造函数我们就去查看相关类的构造方法，这样很省精力。


\section{类的操作第三版}
\label{sec:类的操作第三版}
\begin{xverbatim}[129]{py}
class Unit():
    def __init__(self,hp,atk,color):
        self.hp=hp
        self.atk=atk
        self.color=color
    def __str__(self):
        return '生命值：{0}，攻击力：{1}，颜色：\
        {2}'.format(self.hp,self.atk,self.color)

class Hero(Unit):
    def __init__(self,level,hp,atk,color):
        Unit.__init__(self,hp,atk,color)
        self.level=level
    def __str__(self):
        return '级别：{0},生命值：{1}，攻击力：{2}，\
        颜色：{3}'.format(self.level,self.hp,self.atk,self.color)

    def addlevel(self):
        self.level=self.level+1
        self.hp=self.hp+self.addhp
        self.atk=self.atk+self.addatk

class Garen(Hero):
    def __init__(self,color='blue'):
        Hero.__init__(self,1,455,56,color)
        self.name='盖伦'
        self.addhp=96
        self.addatk=3.5
        self.skill=['不屈','致命打击','勇气','审判','德玛西亚正义']

if __name__ == '__main__':
    garen001=Garen('red')
    garen002=Garen()
    print(garen001)
    unit001=Unit(1000,1000,'gray')
    print(unit001)
    for i in range(6):
        print(garen001)
        garen001.addlevel()
    print('盖伦的技能有：',"".join([x + '  ' for x in garen001.skill]))
\end{xverbatim}
现在就这个例子相对于第二版所作的改动，也就是核心知识点说明之。其中函数参量列表中这样表述\verb+color='blue'+表示blue是color变量的备选值，也就是color成了可选参量了。


\subsection{构造函数的继承和重载}
上面例子很核心的一个概念就是\verb+__init__+构造函数的继承和重载。比如我们看到garen001实例的创建，其中就引用了Hero的构造函数，特别强调的是\uwave{只有创造实例的时候比如这样的形式Garen()才叫做调用了Garen类的构造方法}， 比如这里\\
\verb+Hero.__init__(self,1,455,56,color)+就是调用了Hero类的构造函数，这个时候需要把self写上，因为self就是最终创建的实例garen001，而不是Hero，而且调用Hero类的构造函数就必须按照它的参量列表形式来。这个概念需要弄清楚！

理解了这一点，在类的继承关系中的构造函数的继承和重载就好看了。比如这里Hero类的构造函数又是继承自Unit类的构造函数，Hero类额外有一个参量level接下来也要开辟存储空间配置好。

\subsection{\_\_str\_\_{}函数的继承和重载}
第二个修改是这里重定义了一些类的\verb+__str__+函数，通过重新定义它可以改变默认print某个类对象是的输出。默认只是一段什么什么类并无具体内容信息。具体就是return一段你想要的字符串样式即可。




\subsection{类的高级知识}
更多类的高级知识的讨论参见“类的高级知识”这一章\ref{sec:类的高级知识}。





\chapter{模块}
现在让我们进入模块基础知识的学习吧，建立编写自己的模块，这样不断积累自己的知识，不断变得更强。

实际上之前我们已经接触过很多python自身的标准模块或者其他作者写的第三方模块，而import和from语句就是加载模块用的。这里我们主要讨论如何自己编写自己的模块。

from语句和import语句内部作用机制很类似，只是在变量名的处理方式上有点差异（from会把变量名复制过来）。这里重点就import的工作方式说明如下：
\begin{enumerate}
\item 首先需要找到模块文件。
\item 然后将模块文件编译成位码（需要时，根据文件的时间戳。），你会看到新多出来一个\verb+__pycache__+文件夹。
\item 执行编译出来的位码，创建该py文件定义的对象。
\end{enumerate}
这三个步骤是第一次import的时候会执行的，第二次import的时候会跳过去，而直接引用内存中已加载的对象。



\section{找到模块文件}
python模块的搜索路径会搜索几个地方，这些地方最后都会放在sys.path这个列表里面，所以在你的py文件刚开始修改这个sys.path，append上你想要的地址也是可以的。我在这里选择了这种简单的方法，除此之外还有很多方法这里先不涉及。

比如主文件一般如下：
\begin{Verbatim}
import os,sys
sys.path.append(os.environ['HOME']+'/pymf')
from pyconfig import *
\end{Verbatim}
这里为什么使用\verb+from pyconfig import *+这样的语句而不是import语句呢？因为我决定整个项目的主py文件除了这一个from语句之外不会再import或者from其他模块了，其他所有模块的引用都放在pyconfig.py这个主配置文件里面。

pyconfig.py任务就是加载最常用最通用的一些模块，如果你实际编写的另外一个项目通用pyconfig文件满足不了你的要求了，那么你可以把那个pyconfig文件复制过来，然后放在你的项目文件夹里面，然后继续衍化修改。这个经验是我从\LaTeX 文档的编写中总结出来的，既满足了共性又满足了个性。

那么为什么要用from语句，很简单。如果用import语句，那么pyconfig.py文件里面import math模块，在主py文件里面引用就要使用这样的格式\verb+pyconfig.math.pi+，这既不方便而且违背大家平时惯用的那种math.pi格式。


现在我们让可以开始编写自己的模块吧。

\section{编写模块}
well，编写模块就是一些py文件，然后模块的名字和py文件里面的内容编写好就是了。

我现在编写了一个pyconfig.py文件，放在主文件夹（ubuntu系统）的pymf文件里面的。里面定义了一个斐波拉契函数，如下所示：
\begin{Verbatim}
#菲波那奇数列
def fib(n):
    if n==0:
        return 1
    if n==1:
        return 1
    else:
        return fib(n-1)+fib(n-2)
\end{Verbatim}

然后我们的测试小脚本如下：

\begin{tcbpython}[]
import os,sys
sys.path.append(os.environ['HOME']+'/pymf')
from pyconfig import *

print([fib(n) for n in range(10)])
\end{tcbpython}



\section{import语句}
import语句的一般使用方法之前已有接触，比如import math，然后要使用math模块里面的函数或者类等需要使用这样的带点的变量名结构：math.pi。

此外import语句还有一个常见的缩写名使用技巧，比如import numpy as np，那么后面就可以这样写了， np.array，而不是numpy.array。


\section{from语句}
from语句的使用有以下两种情况：

\begin{tcbpython}[]
from this import this
from what import *
\end{tcbpython}

第一种形式是点名只导入某个变量，第二种形式是都导入进来。我想读者肯定知道这点，使用第二种导入形式的时候要小心变量名覆盖问题，这个自己心里有数即可。



\section{reload函数}
reload函数可以重新载入某个模块，reload函数的优点就是不需要重新启动应用程序，更加合理的动态重载一些模块。reload只能用于python编写的模块，在python3中，reload函数被移到imp模块里面去了，因此首先需要import imp才能使用了。比如说：

\begin{tcbpython}[]
from imp import reload
reload(somemodule)
\end{tcbpython}





\part{python3进阶}
\chapter{类的高级知识}
\label{sec:类的高级知识}
\section{类内部的字典}
\subsection{\_{}\_{}dict\_{}\_{}值}
类和模块都支持对其内部属性或者方法的点的引用方式，这种引用是根据类和模块的\verb+__dict__+这个字典值来的，然后属性继承就是向上搜索链接的字典。python中的类和实例实际就是带有链接的字典，其内的方法和属性都是字典值，其都可以通过\verb+__dict__+的字典索引语法来引用。如这样的语法：\verb+X.__dict__['data']+，

类的字典比如下面这个：
\begin{tcbpython}[]
class A():
    def __init__(self,a):
        self.a=a

    def fun2(self,what):
        print('fun',what)

class B(A):
    def __init__(self):
        self.d=5
    b=2
    def fun3(self):
        print('fun3')
\end{tcbpython}
其\verb+__dict__+值如下所示：
\begin{Verbatim}
>>> B.__dict__
mappingproxy({'__doc__': None, '__init__': <function B.__init__ at 
0xb7096adc>, 'fun3': <function B.fun3 at 0xb7096a4c>, 
'__module__': '__main__', 'b': 2})
\end{Verbatim}

我们看到除了class定义的继承关系之外，类B内部定义的所有属性都存储在\verb+__dict__+字典值里面了。我们可以猜测类的继承关系python是通过另外一种机制管理的，而且有一个通用类，这个通用类上有很多方法就是后面要谈到的那些内置的方法。

点运算索引是加上继承搜索机制了的，这里的\verb+__dict__+的值只是本实例或者本类存储的属性。

\verb+__dict__+这个字典值对于描述类或实例的存在状态很重要，下面有三个python的内置的类的方法，你可以通过重新定义它们来获得你想要的效果。

\subsection{类按键取值}
\verb+__getitem__+方法支持类或实例以Class['x']这样的格式引用其内字典某个（或者某一些）索引的值。



\subsection{类按键赋值}
\verb+__setitem__+方法支持类或实例以Class['x']=3这样的格式修改其内字典的某个（或者某一些）索引的值。

\subsection{字典的索引删除}
\verb+__delitem__+方法支持类或实例以del Class['x']这样的格式删除字典的某个（或者某一些）索引。

关于上面三个内置方法都以下面这个例子来讲解了：
\begin{tcbpython}[]
class GClass():
    def __getitem__(self,key):
        return self.__dict__[key]
    def __setitem__(self,key,value):
        self.__dict__[key] = value
    def __delitem__(self,key):
        del self.__dict__[key]

    def __repr__(self):
        return str(self.__dict__)
\end{tcbpython}

\begin{Verbatim}
>>> test = GClass()
>>> print(test)
{}
>>> test['a'] = 1
>>> print(test)
{'a': 1}
>>> test['a'] = 2
>>> print(test)
{'a': 2}
>>> del test['a']
>>> print(test)
{}
\end{Verbatim}

实际上上面三个内置方法不一定是对类内部字典的操作，也可以是类其中其他数据的操作，而且经过修改它们也支持如同列表的切片操作。



\section{属性管理}
\verb+__getattr__(self,name)+  返回self.name的值。 

\subsection{属性赋值}
\verb+__setattr__(self,name,value)+  和self.name = value动作关联。
\subsection{属性删除}
\verb+__delattr__(self,name)+  del self.name


\subsection{属性获取}
\verb+__getattribute__(self,name)+ 不推荐使用。

\section{数学运算}
\subsection{一般加法}
X + other , \verb+__add__(self,other)+

\subsection{右侧加法}
所谓加法是X+other，如果是右侧加法，则为radd，然后公式是：other+X。一般不区分左右的就用上面的一般加法。

other + X , \verb+__radd__(self,other)+
\subsection{增强加法}
X +=other ，\verb+__iadd__(self.other)+

\subsection{一般减法}
X - other , \verb+__sub__(self,other)+

同上面情况一样类似的还有rsub和isub。

\subsection{其他数学运算符一览}
然后其他数学运算符下面简要列表之：
\begin{description}
\item[*] 乘法，\verb+__mul__(self,other)+，下面的类似的都有右侧运算和增强运算，不再赘述了。
\item[//] 整除，\verb+__floordiv__+，下面类似的参数都是self和other，不再赘述了。
\item[/] 除法 ，\verb+__div__+
\item[\%{}] 取余，\verb+__mod__+
\item[**] 开方，\verb+__pow__+
\item[<<] 左移运算，\verb+__lshift__+
\item[>>] 右移运算，\verb+__rshift__+
\item[\&{}] 位与，\verb+__and__+
\item[|] 位或，\verb+__or__+
\item[\^{}] 位异或\footnote{异或的逻辑是相同取0，不同取1。}，\verb+__xor__+
\end{description}

类似的右侧运算名字前面加上r，增强运算名字前面加上i，不赘述了。


\section{逻辑运算}
\subsection{bool函数支持}
bool(X)  \verb+__bool__(self)+


\subsection{类之间的相等判断}
\href{http://www.informit.com/articles/article.aspx?p=453682}{参考网站}。

这里先总结下is语句和==判断和isinstance和id还有type函数，然后再提及python类的内置方法\verb+__eq__+。

python是一个彻头彻尾的面向对象的语言，python内部一切数据都是对象，对象就有类型type的区别。比如内置的那样对象类型：
\begin{Verbatim}
>>> type('abc')
<class 'str'>
>>> type(123)
<class 'int'>
>>> type([1,2,3])
<class 'list'>
\end{Verbatim}

对象除了有type类型之外，还有id属性，id就是这个对象具体在内存中的存储位置。

当我们说lst=[1,2,3]的时候，程序具体在内存中创建的对象是[1,2,3]，而lst这个变量名不过是一个引用。然后我们看下面的例子：
\begin{Verbatim}
>>> x=[1,2,3]
>>> y=[1,2,3]
>>> type(x)
<class 'list'>
>>> type(y)
<class 'list'>
>>> id(x)
3069975884
>>> id(y)
3062209708
>>> x==y
True
>>> x is y
False
\end{Verbatim}

type函数返回对象的类型，id函数返回对象具体在内存中的存储位置，而==判断只是确保值相等，is语句返回True则更加严格，需要对象在内存上（即id相等）完全是同一个东西。

对象之间的类型比较可以用如下语句来进行比较：
\begin{Verbatim}
>>> x=10
>>> type(x) == int
True
>>> type(x) == type(0)
True
\end{Verbatim}

不过不是特别好用，比如假设fun是你自己定义的一个函数，用type(fun) == function就会出错，然后type比较还要小心NoneType和其他空列表类型不同，而且type比较并没有将类的继承考虑进去。

一般推荐isinstance函数来进行类型比较，请参考\href{http://stackoverflow.com/questions/1549801/differences-between-isinstance-and-type-in-python}{这个网站}的说明。推荐使用types模块的特定名字来判断类型，具体如下：
\begin{description}
\item[types.NoneType] None这个值的类型
\item[types.TypeType] type对象。
\item[types.BooleanType] 还可以使用\textbf{bool}。
\item[types.IntType] 还可以使用\textbf{int}，类似的有\textbf{long}，\textbf{float}。
\item[types.ComplexType] 复数类型
\item[types.StringType] 字符串类型，还可以使用\textbf{str}。
\item[types.TupleType] 元组，还可以使用\textbf{tuple}，类似的有\textbf{list}，\textbf{dict}。
\item[types.FunctionType] 定义的函数类型，此外还有\textbf{types.LambdaType}。

值得一提的是print等内置函数不是FunctionType而是BuiltinFunctionType。
\begin{Verbatim}
>>> import types
>>> isinstance(print,types.FunctionType)
False
>>> isinstance(print,types.BuiltinFunctionType)
True
\end{Verbatim}

\end{description}

\begin{large}
更多内容请参见\href{https://docs.python.org/3.4/library/types.html}{types模块的官方文档}。
\end{large}

\subsubsection{\_{}\_{}eq\_{}\_{}方法}
\verb+__eq__+方法定义了两个对象之间A == B的行为。
比如下面：
\begin{tcbpython}[]
def __eq__(self,other):
    if self.__dict__.keys() == other.__dict__.keys():
        for key in self.__dict__.keys():
            if  not self.__dict__.get(key)==other.__dict__.get(key):
                return False
        return True
    else:
        return False
\end{tcbpython}
定义了这样的\verb+__eq__+方法之后，我们运行==语句，如果两个对象之间内置字典键和值都是一样的，那么就返回True。
\begin{Verbatim}
>>> test=GClass()
>>> test.a=1
>>> test2=GClass()
>>> test2.a=1
>>> test == test2
True
>>> test is test2
False
\end{Verbatim}
如果我们不重定义\verb+__eq__+方法，似乎test和test2会从原始的object类继承\verb+__eq__+方法，然后它们比较返回的是False，我想可能是这两个实例内部某些值的差异吧，但应该不是基于id。


\subsection{比较判断操作}
类似上面的==比较操作，还有如下比较判断操作和对应的内置方法可以重定义。
\begin{itemize}
\item X != Y ，行为由\verb+__ne__(self,other)+定义。
\item X >= Y ，行为由\verb+__ge__(self,other)+定义。
\item X <= Y ，行为由\verb+__le__(self,other)+定义。
\item X > Y ，行为由\verb+__gt__(self,other)+定义。
\item X < Y ，行为由\verb+__lt__(self,other)+定义。
\end{itemize}


\subsection{in语句}
如下所示：
\begin{tcbpython}[]
    def __in__(self,other):
        for key in self.__dict__.keys():
            if not self.__dict__.get(key) == other.__dict__.get(key):
                return False
        return True
\end{tcbpython}
提供了what in X语句的支持，上面的例子是基于类其内字典的内容而做出的判断。

\section{强制类型变换}
所包含的内置方法有：
\begin{Verbatim}
__int__(self)   返回整型
__long__(self)  长整型
__float__(self)  浮点型
__complex__(self)  复数型
__str__(self)  字符型
__oct__(self)  八进制
__hex__(self) 十六进制
__index__(self) 切片操作
\end{Verbatim}


\section{len函数}
由\verb+__len__(self)+提供支持。

\section{copy方法和deepcopy方法}
X.copy()  由\verb+___copy__(self)+提供。

X.deepcopy()  由\verb+___deepcopy__(self)+提供。
\section{with语句支持}
在打开文件那里谈及的with open(...) as f的这类语句是由以下两个内置方法提供的：\verb+__enter__(self)+和\verb+__exit__(self,...)+，exit的还有其他一些参数这里忽略了，enter的返回值会赋值给with中的as后面的变量。

\section{函数调用}
请看下面的例子：
\begin{tcbpython}[]
class Position():
    def __init__(self,x=0,y=0):
        self.x = x
        self.y = y
    def __call__(self,x,y):
        self.x = x
        self.y = y
    def __repr__(self):
        return '('+str(self.x)+ ',' + str(self.y)+')'
\end{tcbpython}
\begin{Verbatim}
>>> p1=Position()
>>> print(p1)
(0,0)
>>> p1(4,5)
>>> print(p1)
(4,5)
>>> 
\end{Verbatim}
\verb+__call__(self,args)+方法支持类或者实例以X(args)或者instance(args)这样的形式调用这个函数。


\section{和迭代操作有关}
\subsection{\_{}\_{}next\_{}\_{}方法}
比如文件对象本身就是可迭代的，调用\verb+__next__+方法就返回文件中下一行的内容，到达文件尾也就是迭代越界了返回：\textbf{StopIteration}异常。

\subsection{next函数}
next函数比如next(f)等价于\verb+f.__next__()+，其中f是一个文件对象。

\begin{Verbatim}
>>> for line in open('removeduplicate.py'):
...  print(line,end='')
... 
#!/usr/bin/env python3
#-*-coding:utf-8-*-
#此处一些内容省略。
    
>>> f=open('removeduplicate.py')
>>> next(f)
'#!/usr/bin/env python3\n'
\end{Verbatim}

所以你可以通过定义类的\verb+__next__+方法来获得这个类对于next函数时的反应。


\subsection{iter函数}
\uwave{文件对象}，\uwave{map对象}，\uwave{zip对象}，\uwave{filter对象}，\uwave{生成器对象}自身已经带有了\verb+__next__+方法，所以可以直接用next函数。不过虽然序列（列表，元组，字典，ranges对象\footnote{range函数的返回，也属于序列类型。}）等是可迭代对象，但是没有\verb+__next__+方法。

iter函数可以让序列们拥有\verb+__next__+方法，这样的它们就可以使用next函数了。

\begin{Verbatim}
>>> list=[1,2,3]
>>> next(list)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'list' object is not an iterator
>>> i=iter(list)
>>> next(i)
1
>>> i.__next__()
2
\end{Verbatim}

下面是for语句的while实现版本：
\begin{Verbatim}
>>> list=[1,2,3]
>>> iter=iter(list)
>>> while True:
...    try:
...        x=next(iter)
...    except StopIteration:
...        break
...    print(x)
... 
1
2
3
\end{Verbatim}

range对象也可以通过iter函数来生成一个可迭代对象。

\subsection{重构字典的iter函数}
我们可以通过重新定义字典类的\verb+__iter__+函数来获得一个新类，这个类用iter函数处理之后的迭代器返回的是经过排序的字典的键。
\begin{tcbpython}[]
class SortedDict(dict):
    def __init__(self,dict={}):
        super().__init__(dict)

    def __iter__(self):
        self._keys = sorted(self.keys())
        for i in self._keys:
            yield i

dict02 = SortedDict()
dict02['a'] = 1
dict02['b'] = 1
dict02['c'] = 1
dict02['d'] = 1
x = iter(dict02)
\end{tcbpython}
这个\verb+__iter__+函数就是所谓的生成器函数，需要返回一个生成器对象。然后经过iter函数处理之后就能调用next函数来逐渐获得经过排序之后的值了。





\section{当对象内存存储回收时的操作}
当对象内存存储被回收时，python最后将执行一个内置方法\verb+__del__+，这个一般不推荐使用。

\section{静态方法}
\begin{Verbatim}
class Test:
#    @staticmethod
    def hello():
        print('aaa')

test=Test()
test.hello()
\end{Verbatim}
在上面的例子中，我们希望创造一个函数，这个函数和self实例没有关系（这里指这个函数将不接受self这个默认参数了）。如上所示，hello函数只是希望简单打印一小段字符，如上面这样的代码是错误的，如果我们在这个函数上面加上\textbf{@staticmethod}，那么上面这段代码就不会出错了，

\begin{Verbatim}
class Test:
    @staticmethod
    def hello():
        print('aaa')

test=Test()
test.hello()
\end{Verbatim}
这样在类里面定义出来的函数叫做这个类的静态方法，静态方法同样可以继承等等，而静态方法通常使用最大的特色就是不需要建立实例，即可以直接从类来调用，如下所示：
\begin{Verbatim}
class Test:
    @staticmethod
    def hello():
        print('aaa')

Test.hello()
\end{Verbatim}

静态方法的使用比如pyqt中的
\begin{Verbatim}
QtGui.QFileDialog.getOpenFileName(......)
\end{Verbatim}
就是一个静态方法，可以通过直接调用这个方法来弹出询问打开文件的窗口，并不需要先实例化一个对象，然后通过self.what等类似的形式来调用。



\section{多重继承的顺序问题}
我们来看下面这个例子：
\begin{tcbpython}[]
class B1():x='B1'
class B2():x='B2'
class B3():x='B3'
class B(B1,B2,B3):x='B'
class A1():x='A1'
class A2():x='A2'
class A(A1,A2):x='A'
class D(B,A):x='D'
test=D()
print(test.x)
\end{tcbpython}

\begin{fig}{多重继承}
\caption{多重继承}
\label{fig:多重继承}
\end{fig}

你可以测试一下上面这个例子，首先当然结果是D自己的x被先查找，然后返回\emph{'D'}，如果你把类D的x定义语句换成pass，结果就是\emph{'B'}。这说明这里程序的逻辑是如果test实例找不到x，那么再找D，D找不到再接下来找D继承自的父类，首先是B，到目前为止，没什么新鲜事发生。

然后我们再把B的x赋值语句换成pass，这时的结果是\emph{'B1'}，也没什么好惊讶的。然后类似的一致操作下去，我们会发现python的值的查找顺序在这里是：D，B，B1，B2，B3，A，A1，A2。

于是我们可以总结道：恩，类的多重继承就是深度优先法则，先把子类或者子类的子类都查找完，确认没有值之后再继续从左到右的查找。


一般情况来说这么理解是没有问题的，但是在编程界多重继承中有个有名的问题——菱形难题。

\subsection{菱形难题}
参考资料： \href{http://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem}{维基百科菱形难题}

\begin{fig}{菱形难题}
\caption{菱形难题}
\label{fig:菱形难题}
\end{fig}

菱形难题即在如上的类的继承中，如果C和A都有同名属性x，那么D会调用谁的呢？读者测试下面的例子：
\begin{tcbpython}[]
class E():x='E'
class F():x='F'
class G():x='G'
class A(F,G):x='A'
class B(E,F):x='B'
class D(B,A):pass
test=D()
print(test.x)
\end{tcbpython}
此时运行结果到DBE都没有什么出奇的， 接下来要某是DBEF\footnote{E当然也检查过了，否则E有没有值是无法确认的。}，要某是DBEA，这里程序的结果是\emph{'A'}。这里的情况确实比较纠结，如果没有这个F作为菱形难题的交叉点，似前面的层次分明，那么简单的理解为深度优先即可，这里python3的选择是\emph{'A'}，不清楚为什么要这么选择。

我们再来看这个例子：
\begin{tcbpython}[]
class E():x='E'
class F():x='F'
class G():x='G'
class A(F,G):x='A'
class B(F,E):pass
class D(B,A):pass
test=D()
print(test.x)
\end{tcbpython}
此时结果是\emph{'A'}，连E都被跳过去了，变成了彻底的横向优先原则。

程序出现菱形难题之后，情况变得不可琢磨了。上面的三个情况
\begin{Verbatim}
D(B(B1 B2 B3) A(A1 A2)) → D B B1 B2 B3 A A1 A2

D(B(E F) A(F G)) → D B E A F G

D(B(F E) A(F G)) → D B A F E G
\end{Verbatim}
就是这样的，总之这是很冷门的领域了。。简单的理解就是深度搜索，类似flatten函数处理过，然后如果遇到某个子元在下一个平行级别的子元中也含有，那么本子元会被略过，做个记号，分叉跳过去跑到A那里，执行完那个子元之后，又会重新调到之前的操作点上。python怎么弄这么古怪的逻辑。。



\subsection{super()}
super是python3新加入的特性，按照官方文档，有两种用法：

第一种是如果是单继承的类的系统，super()这种形式就直接表示父类的意思。然后用super().什么什么的来引用父类的某个变量或方法，\uwave{值得一提的是原父类的self参量会默认加进去了}，详细请看下面的调试例子。

第二种是多重继承的，搜索顺序和多重继承的搜索顺序相同，也就是从左到右。请注意调试下面的例子，如果调用c.d就会返回错误，说明调用的是类A的构造函数。

\begin{xverbatim}[129]{py}
class A():
    def __init__(self,a):
        self.a=a

    def fun(self):
        print('fun')

    def fun2(self,what):
        print('fun',what)

class B():
    def __init__(self):
        self.d=5
    b=2
    def fun3(self):
        print('fun3')

class C(A,B):
    def __init__(self):
        super().__init__(3)
        super().fun()
        super().fun2('what')
        super().fun3()
        print(super().b)

c=C()
print(c.a,c.b)
\end{xverbatim}

其中A类定义的fun函数在写的函数上通常有个self参数，而\emph{super()}这种调用形式在意义上表示其的父类，同时默认第一个参数就是self。为了理解你可以和self做个比较，比如self.fun()就是调用的实例的fun函数，默认的第一个参数是self。使用super()在类的编写中引用本类的父类的属性和方法是很便捷的，自带支持类的多重继承功能。比如上面的例子中fun3能被调用是因为多重继承的机制在这里，所以它会逐个找父类。然后c.d会出错，因为这里初始化是用的A类的构造函数。


\section{装饰器}
python语言的装饰器概念算是比较高级的概念了，不过并不是那种冷门的用的很少的概念，比如在前面的静态方法中就使用装饰器的概念：
\begin{tcbpython}[]
    @staticmethod
    def what():
        pass
\end{tcbpython}


装饰器的作用机制就是对接下来的函数进行进一步的封装，比如上面的例子就是：
\begin{tcbpython}[]
    def what():
        pass
    what = staticmethod(what)
\end{tcbpython}

可见装饰器并不是一个什么神秘的难懂的概念，同样你可以定义自己的函数，这个函数处理某个函数对象，并对其进行某种封装。

类似的装饰器还有类的方法装饰器\verb+@classmethod+，在pyqt中有槽的装饰器\verb+@pyqtSlot()+和\verb+@pyqtSlot(int, str)+等，第一个例子接下来你定义的槽只接受self这个参数，第二个例子接下来你定义的槽除了接受self参数外，还接受一个int类型参数和一个str类型参数。




\chapter{深入理解python3的迭代}
\label{sec:深入理解python3的迭代}
在python中一般复杂的代码运算效率就会低一点，如果完成类似的工作但你可以更简单的语句那么运算效率就会高一点。当然这只是python的一个设计理念，并不尽然，但确实很有意思。

程序结构中最有用的就是多个操作的重复，其中有迭代和递归还有一般的循环语句。递归函式感觉对于某些特殊的问题很有用，然后一般基于数据结构的不是特别复杂的操作重复用迭代语句即可，最后才考虑一般循环语句。

迭代语句中for语句运算效率最低，然后是map函数（不尽然），然后是列表解析。所以我们在处理问题的时候最pythonic的风格，运算效率最高的就是列表解析了，如果一个问题能够用列表解析解决那么就用列表解析解决，因为python的设计者的很多优化工作都是针对迭代操作进行的，然后python3进一步深化了迭代思想，最后python中的迭代是用c语言来实现的（你懂的）。

可是让我们反思一下为什么列表解析在问题处理的时候如此通用？比如说range函数或者文件对象或者列表字符串等等，他们都可以称之为可迭代对象。可迭代对象有内置方法\verb+__next__+这个我们之前有所谈及，可迭代对象最大的特色就是有一系列的元素，然后这一系列的元素可以通过上面的内置方法逐个调出来，而列表解析就是对这些调出来的元素进行了某个表达式操作，然后将其收集起来。这是什么？我们看下面这张图片：
\begin{fig}{列表解析}
\caption{列表解析}
\label{fig:列表解析}
\end{fig}

这张图片告诉我们列表解析和数学上所谓的集合还有函数的定义非常的类似，可迭代对象就好像是一个集合（有顺序或者没顺序都行），然后这些集合中的所有元素经过了某个操作，这个操作似乎就是我们数学中定义的函数，然后加上过滤条件，某些元素不参加运算，这样就生成了第二个可迭代对象（一般是列表也可以是字典什么的。）

有一个哲学上的假定，那就是我们的世界一切问题都可以用数学来描述，而一些数学问题都可以用函数即如上的信息操作过滤流来描述之。当然这不尽然，但我们可以看到列表解析在一般问题处理上是很通用的思想。

不过我们看到有限的元素的集合问题适合用迭代，但无限元素的集合问题也许用递归或者循环更适合一些。然后我们又想到集合的描述分为列举描述（有限个元素的列举）和定义描述。比如说1<x<10，x属于整数，这就定义了一个集合。那么我们就想到python存在这样的通过描述而不是列举（如列表一样）的集合吗？range函数似乎就是为了这样的目的而生的，比如说range(10)就定义了[0,10)这一系列的整数集合，range函数生成一个range对象，range对象是一个可迭代对象，我们可以把它看作可迭代对象中的描述集合类型吧。这时我们就问了，既然0<=x<10这样的整数集合可以通过描述来实现，那么更加复杂的函数描述可不可以实现呢？我们可不可以建立更加复杂的类似range对象的描述性可迭代对象呢？

\section{生成器函数}
一般函数的定义使用return语句，如果使用yield语句，我们可以构建出一个生成器函数，
\begin{Verbatim}
>>> def test(x):
...    for i in range(x):
...        yield 2*i+ 1
... 
>>> test(3)
<generator object test at 0xb704348c>
>>> [x for x in test(3)]
[1, 3, 5]
>>> [x for x in test(5)]
[1, 3, 5, 7, 9]
\end{Verbatim}

这个test函数叫做什么生成器函数，返回的是什么generator object，生成器对象？anyway，通过yield这样的形式定义出来的生成器函数返回了一个生成器对象和range对象类似，都是描述性可迭代对象，里面的元素并不立即展开，而是请求一次运算一次，所以这种编程风格对内存压力很小，主要适合那些迭代元素特别多的时候的情况吧。

上面的test函数我们就可以简单理解为2x+1，其中0<=x<n（赋的值）。

下面给出一个问题作为练习：描述素数的生成器函数。
这是网上流行的素数检验函数，效率还是比较高的了。
\begin{tcbpython}
def isprime(n):
    if n ==2:
        return True
    #按位与1，前面一定都是0个位数如果是1则
    #是奇数则返回1则真则假，如果是偶数则返回
    #0则假则真
    elif n<2 or not n & 1:
        return False
    #埃拉托斯特尼筛法...
#查一个正整数N是否为素数，最简单的方法就是试除法，
#将该数N用小于等于N**0.5的所有素数去试除，
#若均无法整除，则N为素数
    for x in range(3,int(n**0.5)+1,2):
        if n % x == 0:
            return False
    return True
\end{tcbpython}

然后我们给出两种形式的素数生成器函数，其中prime2的意思是范围到（to）那里。而prime(n)的意思是到第几个素数。我们知道生成器函数是一种惰性求值运算，然后yield每迭代一次函数运算一次（即产生一次yield），但这种机制还是让我觉得好神奇。

\begin{tcbpython}
def prime2(n):
    for x in range(n):
        if isprime(x):
            yield x

def prime(n):
    i=0
    x=1
    while i<n:
        if isprime(x):
            i +=1
            yield x
        x +=1
\end{tcbpython}

在加载这些函数之后我们可以做一些检验：
\begin{Verbatim}
>>> isprime(479)
True
>>> [x for x in prime2(100)]
[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, ........]
>>> [x for x in prime2(1000) if 100< x < 200]
[101, 103, 107, 109, 113, 127, 131, 137, 139, 149, .......]
>>> len([x for x in prime2(10000) if -1 < x < 3572])
500
>>> [x for x in prime(1)]
[2]
>>> [x for x in prime(2)]
[2, 3]
\end{Verbatim}



\section{map和filter函数}
按照之前的迭代模式的描述，虽然使用常见的列表解析格式(for 语句)就可以完成对某个集合中各个元素的操作或者过滤，不过python中还有另外两个函数来实现类似的功能，map对应对集合中各个元素进行某个函数操作（可以接受lambda函式），而filter则实现如上所述的过滤功能。然后值得一提的是python3之后map函数和filter函数返回都是一个可迭代对象而不是列表，和range函数等其他可迭代对象一样可用于列表解析结构。

\subsection{map函数}
这里列出一些例子，具体编程还是先考虑列表解析模式，可能会在某些情况下需要用到map函数？

\begin{Verbatim}
>>> map(abs, [-2,-1,0,1,2])
<map object at 0xb707dccc>
>>> [x for x in map(abs, [-2,-1,0,1,2])]
[2, 1, 0, 1, 2]
>>> [x for x in map(lambda x : x+2, [-2,-1,0,1,2])]
[0, 1, 2, 3, 4]
\end{Verbatim}


map函数还可以接受两个可迭代对象的协作参数模式，这个学过lisp语言的会觉得很眼熟，不过这里按照我们的理解也是很便捷的。具体就是第一个可迭代对象取出一个元素作为map的函数的第一个参数，然后第二个可迭代对象取出第二个参数，然后经过函数运算，得到一个结果，这个结果如果不列表解析的话就是一个map对象（可迭代对象），然后展开以此类推。值得一提的是两个可迭代对象的深度由\uwave{最短}的那个决定，请看下面的例子：
\begin{Verbatim}
>>> [x for x in map(lambda x,y : x+y, [-2,-1,0,1,2],[-2,-1,0,1,2])]
[-4, -2, 0, 2, 4]
>>> [x for x in map(lambda x,y : x+y, [-2,-1,0,1,2],[-2,-1,0,1])]
[-4, -2, 0, 2]
\end{Verbatim}

\subsection{filter函数}
同样和上面的谈及的类似，filter函数过滤一个可迭代对象然后产生一个可迭代对象。类似的功能可以用列表解析的后的if语句来实现。前面谈到map函数的时候提及一般还是优先使用列表解析模式，但filter函数这里有点不同，因为列表解析后面跟个if可能有时会让人困惑，这时推荐还是用filter函数来进行可迭代对象的过滤操作。

filter函数的基本逻辑是只有return True（用lambda表达式就是这个表达式的值为真，具体请参看python的逻辑小知识和布尔值的一些规则\ref{sec:布尔值}）的时候元素才被收集起来，或者说是过滤出来。这里强调True是因为如果你的函数没有return值那么默认的是return None，这个时候元素也是不会过滤出来的。

请参看下面的例子来理解：\sidenote{这里位运算与就是控制个位数是1那么就是奇数，这种方式更加的节省计算。}
\begin{Verbatim}
>>> [x for x in filter(lambda x:x&1,[1,2,3,5,9,10,155,-20,-25])]
[1, 3, 5, 9, 155, -25]
>>> [x for x in filter(lambda x:not x&1,[1,2,3,5,9,10,155,-20,-25])]
[2, 10, -20]
\end{Verbatim}


当然你也可以传统的编写函数：
\begin{Verbatim}
>>> def even(n):
...    if n % 2 ==0:
...         return True

>>> [x for x in filter(even,[1,2,3,5,9,10,155,-25])]
[2, 10]
\end{Verbatim}

\subsection{zip函数}
这里就顺便把zip函数也一起提了，zip函数同样返回一个可迭代对象，它接受任意数目的可迭代对象，然后逐个取出可迭代对象元素构成一个元组成为自己的一个元素（待迭代出来）。和map函数类似迭代深度由\uwave{最短}的那个可迭代对象决定。
\begin{Verbatim}
>>> zip(['a','b','c'],[1,2,3,4])
<zip object at 0xb7055e6c>
>>> [x for x in zip(['a','b','c'],[1,2,3,4])]
[('a', 1), ('b', 2), ('c', 3)]
>>> list(zip(['a','b','c'],[1,2,3,4]))
[('a', 1), ('b', 2), ('c', 3)]
>>> dict(zip(['a','b','c'],[1,2,3,4]))
{'c': 3, 'b': 2, 'a': 1}
\end{Verbatim}

\subsubsection{字典到列表}
这个例子似乎使用价值不大，只是说明zip函数接受任意数目参数的情况。y.items()解包之后是4个参数传递给zip函数，而zip函数的封装逻辑就是如果有人问我，我就把你们这些迭代对象每个取出一个元素，然后用元组包装之后返回。
\begin{xverbatim}[129]{py}
x1 = ['a','b','c','e']
x2 = [1,2,3,4]
y = dict(zip(x1,x2))
print('列表到字典：',y)
new_x1,new_x2 = zip(*y.items())
print(new_x1,new_x2)
\end{xverbatim}

这个例子如果到更加复杂的情况，我们可以跳过字典形式，来个数据映射对：
\begin{Verbatim}
>>> x1 = ['a','b','c','e']
>>> x2 = ['red','yellow','red','blue']
>>> x3 = [1,2,3,4]
>>> list(zip(x1,x2,x3))
[('a', 'red', 1), ('b', 'yellow', 2), ('c', 'red', 3), ('e', 'blue', 4)]
>>> new_x1,new_x2,new_x3 = zip(*list(zip(x1,x2,x3)))
>>> new_x1
('a', 'b', 'c', 'e')
>>> new_x2
('red', 'yellow', 'red', 'blue')
>>> new_x3
(1, 2, 3, 4)
\end{Verbatim}

当然对于多属性数据问题一般还是推荐使用类来处理，不过某些情况下可能不需要使用类，就这样简单处理之。

值得一提的是这种数据存储形式和sql存储是一致的，而且不知道你们注意到没有，这似乎实现了矩阵的转置功能。







\chapter{模块包}
---------------------------------------
随着python学习的深入，对这章和初学的时候见解很不相同了，获得了很多有价值的经验。下面内容较陈旧了，有时间还需要大量的修改一下。






多个模块py文件组成一个多文件夹目录的整体就是一个模块包。

模块包这部分知识是我们理解前人编写的各个有用的模块包的基础，同时以后我们自己要编写大型的项目也是一个人编写一个模块，一个模块对应一个任务或者一个功能的形式展开的，然后多个模块合并成一个大型的模块包。以前我们都是编写的不超过一百行的小python代码，不过就是对于大型的项目也不意味着我们要找一个大型的编辑器，然后一写就是上万行。在模块包的合理布局下，我们完全还可以轻松的一次编写也就那么一两百行的小代码，最后各个模块组合起来，就是一个宏大的系统了。

\section{\_{}\_{}init\_{}\_{}文件}
well，模块包和简单的模块在管理上多出来的唯一的一个内容就是你需要在每个文件夹里面加一个\verb+__init__.py+文件，文件的内容就是空白都没关系，但必须要有。

现在我们新建一个文件夹，\verb+mymodule+。然后进入mymodule文件夹，新建一个空白文件\verb+__init__.py+，然后新建一个文件\verb+mymod.py+，然后里面定义了一个简单的myfun函数，没什么意义，就是打印了一段信息。然后我们在当前目录下进入python3的eval模式就可以开始测试你的这个新模块包了，因为sys.path是默认自带搜索当前工作目录的。

你的模块包必须要有一个\verb+__init__.py+文件，这个文件实际上就是暗指的你的这个模块，比如说这里是mymodule。不管你是import还是使用from语句，只要调用mymodule，你的\verb+__init__.py+都将执行一次。

你的模块包如果还有其他py文件\footnote{这个py文件就是子模块的概念。}，那么这个文件在你的\verb+__init__.py+文件没有任何配置的情况下只能通过：
\begin{tcbpython}[]
import mymodule.mymod
\end{tcbpython}
这样的语句来引入进来。

在一般情况下，\verb+__init__.py+文件是空白的或者里面填上一些类和函数来表示mymodule自身的配置，这满足了一般的需求了。然后模块包里面的py文件在使用时都用mymodule.mymod来引用进来。

\verb+__init__.py+文件如果是空白我们不用关心它到底起了什么作用，但如果它不是空白，里面有一些代码，比如定义了一些函数和类，因为每个模块包下的\verb+__init__.py+在python首次导入时都会执行一次这个文件内部的代码。所以当你import mymodule之后，mymodule里面的函数和类就可以通过mymodule.what来使用了。

\subsection{如果里面有import语句}
如果import的是外部的模块方面本文件某些函数或类的调用这自不必说。这里讨论的是这种情况，有的时候你的模块包的某些子模块，你不希望import mymodule之后还需要import mymodule.mymod才能使用mymod.py文件里面的内容，你希望马上就能够使用，那么你需要在\verb+__init__.py+文件里面使用import语句了。

比如在这里\verb+__init__.py+文件加上一句话：
\begin{tcbpython}
import mymodule.mymod
\end{tcbpython}

这样在简单的import mymodule之后，你就可以直接使用mymodule.mymod.myfun来引用mymod.py文件里面的myfun函数了，而之前还需要额外的执行import mymodule.mymod命令一次。


\subsection{如果里面有from语句}
前面谈到from语句的前面和import语句是没有区别的，除了额外的引入变量名操作。在这里就是你厌倦了mymodule.mymod.myfun这类常常的引用的方式，你就想简单点就是mymodule.myfun，那么你可以在\verb+__init__.py+文件中加上如下语句：
\begin{tcbpython}[]
from mymodule.mymod import myfun
\end{tcbpython}
这样就把myfun这个变量名引入到mymodule（也就是\verb+__init__.py+文件）里面去了。此时mymodule点的下面引用就多了一些函数和类的定义了，在你简单import mymodule之后。

读者应该猜到了，如果现在你在外面eval模式下使用from mymodule import *，那么就可以直接调用myfun命令了。


\subsection{\_{}\_{}all\_{}\_{}变量}
\verb+__init__.py+文件还有一个高级功能，这个高级功能多少取代了前面谈论的一切，是一种新的管理模式。

如果外围eval调用使用的import mymodule语句，那么\_{}\_{}all\_{}\_{}变量将不会被读取。只有在外围eval调用使用from mymodule import *这样的语句情况下，\_{}\_{}all\_{}\_{}变量才会被读取。同时要特别提醒的是，如果\verb+__init__.py+文件里面没有\_{}\_{}all\_{}\_{}变量，那么情况就是我们上面讨论的，如果有\_{}\_{}all\_{}\_{}变量，并且使用了from mymodule import *语句，那么\verb+__init__.py+文件里面的其他import和from语句都将失效（其他语句还是有效的）。

表面上看\_{}\_{}all\_{}\_{}变量的引入似乎使得事情变得混乱不堪了，不过我们外围可以使用这样的语法：
\begin{tcbpython}[]
import mymodule
from mymodule import *
\end{tcbpython}
这样from*语句就负责\_{}\_{}all\_{}\_{}变量部分，import mymodule则负责其他import和from语句的管理，两者并无冲突。此时mymodule，mymodule.mymod和mymod2都是可以引用的。

但是在这里最大的问题是当你使用from mymodule import *之后，mymod2被提到和mymodule同等级的状态，这多少不够美观，我们宁愿用mymodule.myfun或者mymodule.mymod2这样的形式，单独使用mymod2多少有点主次不分了。总的说来不推荐使用\_{}\_{}all\_{}\_{}变量，当然也不推荐使用from mymodule import *这样的语法。

\emph{例外}：在保证mymodule这个主入口不被侵犯的情况下，某些子模块的子模块（这里我们在mymodule文件夹里面新建一个mymod3文件夹，然后新建文件\verb+__init__.py+，这个\verb+__init__.py+里面通过\verb+__all__+代入了mymod4，然后新建mymod4.py，里面定义一个简单地打印函数。）的情况可以使用。

如上面说明的，在我们对项目模块包内部文档管理更加美观的要求下，现在在import mymodule之后，模块的模块的模块......都可以通过\_{}\_{}all\_{}\_{}变量来优化，从而外围可以直接通过mymodule.mymod4这样的二级引用格式来引用，如果我们不使用这种技术，按照常规手段，那么我们需要mymodule.mymod3.mymod4这样的格式来引用，这太过于复杂了。


\section{模块中的帮助信息}
well，大家都知道，我们编写的模块主要是给别人看得，给别人用的，所以多写点帮助信息吧，这个没人嫌你写得多的。其他\#{}下的注释就不用说了，这里主要讲一下其他的帮助信息。

还是跟着上面的例子来：
\begin{tcbpython}
"""mymod.py
这是一个测试模块"""

def myfun():
    """myfun函数
    用于打印测试"""

    print('myfun is found')
\end{tcbpython}

\begin{tcbpython}
"""mymodule
我在mymodule文件夹的__init__.py文件里面"""

print('mymodule already import')

from mymodule import mymod
__all__ = ['mymod']
\end{tcbpython}

然后是测试代码：
\begin{tcbpython}
import os,sys
sys.path.append(os.environ['HOME']+'/pymf')
from pyconfig import *

import  mymodule
\end{tcbpython}


具体测试查看情况如下所示，其中help命令显示的内容就不粘贴在这里了，请读者自己查看之，还是很有意思的。
\begin{Verbatim}
mymodule already import
>>> dir(mymodule)
['__all__', '__builtins__', '__cached__', '__doc__', ......]
>>> dir(mymodule.mymod)
['__builtins__', '__cached__', '__doc__', '__file__', ......, 'myfun']
>>> print(mymodule.__doc__)
mymodule
我在mymodule文件夹的__init__.py文件里面
>>> print(mymodule.mymod.__doc__)
mymod.py
这是一个测试模块
>>> print(mymodule.mymod.myfun.__doc__)
myfun函数
    用于打印测试
>>> help(mymodule)

>>> help(mymodule.mymod)

>>> help(mymodule.mymod.myfun)

\end{Verbatim}

类和模块的这些文档信息都存放在\verb+__doc__+变量里面的。




\chapter{文件处理高级知识}
接下来的例子如果涉及到文件的请自己随便创建一个对应文件名的文件，内容随意了。

\section{一行行的操作}
因为文件对象本身是可迭代的，我们简单迭代文件对象就可以对文件的一行行内容进行一些操作。比如：
\begin{tcbpython}
f = open('removeduplicate.py')

for line in f:
    print(line,end='')
\end{tcbpython}
这个代码就将打印这个文件，其中end=''的意思是取消\verb+\n+，因为原来的行里面已经有\verb+\n+了。

然后代码稍作修改就可以在每一行之前加上>>>这个符号了。 
\begin{tcbpython}
f = open('removeduplicate.py')

for line in f:
    print('>>>',line,end='')
\end{tcbpython}

什么？这个输出只是在终端，没有到某个文件里面去，行，加上file参数。然后代码变成如下：
\begin{tcbpython}
import sys

f = open('removeduplicate.py')
pyout=open(sys.argv[1] ,"w")

for line in f:
    print('>>>',line,end='',file=pyout)

pyout.close()
f.close()
\end{tcbpython}
这样我们就制作了一个小python脚本，接受一个文件名然后输出这个文件，这个文件的内容就是之前我们在终端中看到的。

\section{整个文件的列表解析}
python的列表解析（迭代）效率是很高的，我们应该多用列表解析模式。

\subsection{readlines方法}
文件对象有一个readlines方法，能够一次性把整个文件的所有行字符串装入到一个列表中。然后我们再对这个列表进行解析操作就可以直接对整个文件的内容做出一些修改了。不过不推荐使用readlines方法了，这样将整个文件装入内存的方法具有内存爆炸风险，而迭代版本更好一点。

\subsection{文本所有某个单词的替换}
这里举一个例子，将removeduplicate.py文件接受进来，然后进行列表解析，将文本中的newlist全部都替换为list2。

\begin{tcbpython}
import sys

pyout=open(sys.argv[1] ,"w")

print(''.join([line.replace('newlist','list2') 
for line in open('removeduplicate.py')]),file=pyout)

pyout.close()
\end{tcbpython}

我们可以看到这种列表解析风格代码更加具有python风格和更加的简洁同时功能是异常的强大的。

从这里起我们看到如果需要更加复杂的文本处理技巧就需要学习正则表达式和re模块了，请参见re模块这一小节\ref{sec:re模块}。





\chapter{与c语言或c++语言编写的模块集成}
\section{安装和配置}
\subsection{通过apt安装}
\begin{tcbbash}[]
sudo apt-get install swig
\end{tcbbash}

在Ubuntu14.04这将安装swig2.0版本。

\subsection{从github下载最新版安装}
从github上下载最新版本：
\begin{tcbbash}[]
git  clone  https://github.com/swig/swig
\end{tcbbash}

安装需要的前提软件：
\begin{tcbbash}[]
sudo apt-get install autotools-dev
sudo apt-get install automake
sudo apt-get install byacc
sudo apt-get install yodl
\end{tcbbash}

安装：
\begin{tcbbash}[]
./configure
make
sudo make install
\end{tcbbash}

\subsection{安装后的配置}
需要确认安装了python3-dev，好支持\verb+#include python.h+：
\begin{tcbbash}[]
sudo apt-get install python3-dev
\end{tcbbash}

\section{beginning}
\subsection{手工编译}
找到源码的[Examples]→[python]→[simple]文件夹。简单的编译过程如下：
\begin{tcbbash}[]
swig -python example.i

gcc -fpic -c example.c example_wrap.c -I/usr/include/python3.4m

gcc -shared example.o example_wrap.o -o _example.so
\end{tcbbash}

可以通过如下命令查看具体\textbf{-I}的引用地址：
\begin{tcbbash}[]
python3-config --includes
\end{tcbbash}

简单的使用如下：
\begin{Verbatim}
>>> import example
>>> example.gcd(100,25)
25
>>> example.cvar.Foo
3.0
>>> 
\end{Verbatim}

\subsection{通过setuptools安装}
更加简便的处理方式是用setuptools模块来自动处理这一些，包括build到安装egg文件。
\begin{tcbpython}[]
from setuptools import setup ,Extension

setup(
    name = 'example',
    version = '0.01',
    ext_modules = [Extension('_example', ['example.i','example.c'],
    swig_opts=['-modern', '-I../include'])],
    py_modules = ['example']
)
\end{tcbpython}
上面的swig\_{}opts推荐加上。

编写自己的一个函数：
\begin{tcbcode}{c}
#include <stdio.h>
void hello(){
    printf("hello, world\n");
}
\end{tcbcode}

修改example.i文件：
\begin{tcbcode}{c}
%module example

%inline %{
extern int    gcd(int x, int y);
extern double Foo;
extern void hello();
%}
\end{tcbcode}

重新用setuptools安装一下。
\begin{Verbatim}
>>> import example
>>> example.hello()
hello, world
\end{Verbatim}





\part{常用的模块}
这些常用的模块都是python3语言自带的模块。

\chapter{pickle模块}
\label{sec:pickle模块}
pickle模块可以将某\uwave{一个}复杂的对象永久存入\uwave{一个}文件中，以后再导入这个文件，这样自动将这个复杂的对象导入进来了。

\section{将对象存入文件}
\begin{Verbatim}
import pickle

class Test:
    def __init__(self):
        self.a=0
        self.b=0
        self.c=1
        self.d=1

    def __str__(self):
        return str(self.__dict__)

if __name__ == '__main__':
    test001=Test()
    print(test001)
    testfile=open('data.pkl','wb')
    pickle.dump(test001,testfile)
    testfile.close()
\end{Verbatim}




\section{从文件中取出对象}
值得一提的是从文件中取出对象，原来的类的定义还是必须存在，也就是声明一次在内存中的，否则会出错。
\begin{Verbatim}
import pickle

class Test:
    def __init__(self):
        self.a=0
        self.b=0
        self.c=1
        self.d=1

    def __str__(self):
        return str(self.__dict__)

if __name__ == '__main__':
    testfile=open('data.pkl','rb')
    test001=pickle.load(testfile)
    print(test001)
    testfile.close()
\end{Verbatim}

pickle模块的基本使用就是用dump函数将某个对象存入某个文件中，然后这个文件以后可以用load函数来加载，然后之前的那个对象会自动返回出来。

\begin{Large}
更多内容请参见\href{https://docs.python.org/3/library/pickle.html}{官方文档}。
\end{Large}

\chapter{shelve模块}
shelve模块是基于pickle模块的，也就是只有pickle模块支持的对象它才支持。 之前提及pickle模块只能针对一个对象，如果你有多个对象要处理，可以考虑使用shelve模块，而shelve模块就好像是自动将这些对象用字典的形式包装起来了。除此之外shelve模块的使用更加简便了。

\section{存入多个对象}
我们根据类的操作第三版中定义的类（\ref{sec:类的操作第三版}）建立了一个Hero.py文件，就是将那些类的定义复制进去。然后我们新建了几个实例来存入test.db文件中。

\begin{tcbpython}
import shelve
from Hero import Garen

if __name__ == '__main__':
    garen1=Garen()
    garen2=Garen('red')
    garen3=Garen('yellow')
    db=shelve.open('test.db')
    for (key,item) in [('garen1',garen1),('garen2',garen2),('garen3',garen3)]:
        db[key]=item
    db.close()
\end{tcbpython}

我们看到整个过程的代码变得非常的简洁了，然后一个个对象是以字典的形式存入进去的。

\section{读取这些对象}
读取这些对象的代码也很简洁，就是用shelve模块的open函数打开数据库文件，open函数会自动返回一个字典对象，这个字典对象里面的数据就对应着之前存入的键值和对象。

同时通过这个例子我发现，如果自己定义的类，将他们提取出来放入另外一个文件，那么shelve模块读取文件时候是不需要再引入之前的定义。这一点值得我们注意，因为shelve模块内部也采用的是pickle的机制，所以可以猜测之前pickle的那个例子类的定义写在写入文件代码的里面，所以不能载入数据库；而如果将这些类的定义放入一个文件，然后这些类以模块或说模块载入的形式引入，那么读取这些对象就可以以一种更优雅的形式实现。如下所示：
\begin{tcbpython}
import shelve

if __name__ == '__main__':
    db=shelve.open('test.db')
    for key in sorted(db):
        print(db[key])
    db.close()
\end{tcbpython}

我们看到就作为简单的程序或者原型程序的数据库，shelve模块已经很好用而且够用了。


\begin{large}
更多内容请参见\href{https://docs.python.org/3/library/shelve.html}{官方文档}。
\end{large}


\chapter{time模块}
time模块提供了一些和时间相关的函数，更加的底层，不过有些函数可能在某些平台并不适用。类似的模块还有datetime模块，datetime是以类的框架来解决一些时间问题的。所以如果只是需要简单的调用一下时间，那么用time模块，如果是大量和时间相关的问题，推荐使用datetime模块。

\section{time函数}
\begin{Verbatim}
>>> import time
>>> time.time()
1404348227.07554
\end{Verbatim}
time函数返回一个数值，这个数值表示从1970年1月1号0时0分0秒到现在的时间过了多少秒。

\section{gmtime函数}
这个函数可以接受一个参数，这个参数是多少秒，然后返回一个特定格式的时间数组\verb+struct_time+。如果不接受参数，那么默认接受的秒数由time函数返回，也就是从那个特定时间到现在过了多少秒，这样这个特定格式的时间数组对应的就是当前时间。

\begin{Verbatim}
>>> time.gmtime()
time.struct_time(tm_year=2014, tm_mon=7, tm_mday=3, tm_hour=0, 
tm_min=53, tm_sec=0, tm_wday=3, tm_yday=184, tm_isdst=0)
>>> time.gmtime(0)
time.struct_time(tm_year=1970, tm_mon=1, tm_mday=1, tm_hour=0, 
tm_min=0, tm_sec=0, tm_wday=3, tm_yday=1, tm_isdst=0)
\end{Verbatim}

\section{localtime函数}
此外类似的还有\textbf{localtime}函数，和gmtime用法和返回完全一模一样，唯一的区别就是返回的是当地的时间。
\begin{Verbatim}
>>> time.strftime('%Y-%m-%d %H:%M:%S',time.localtime())
'2014-07-03 09:19:40'
>>> time.strftime('%Y-%m-%d %H:%M:%S',time.gmtime())
'2014-07-03 01:19:49'
\end{Verbatim}


\section{ctime函数}
\begin{Verbatim}
>>> time.ctime()
'Thu Jul  3 08:54:54 2014'
>>> time.ctime(0)
'Thu Jan  1 07:00:00 1970'
\end{Verbatim}
和gmtime类似，不过返回的是字符串格式的时间。我们看到ctime默认设置的时间是根据localtime函数来的。


\section{strftime函数}
接受那个特定格式的时间数组\verb+struct_time+作为参数，然后返回一定字符串格式的时间。具体例子请参看前面的例子。

其中最常用的格式符有：
\begin{Verbatim}
%Y，多少年；%m，多少月；%d，多少日；
%H，多少小时；%M，多少分；%S，多少秒。
\end{Verbatim}

\%{}X直接输出09:27:19这样的格式，也就是前面的多少小时多少分多少秒可以用一个\%{}X表示即可。

还有一些，比如：\%{}I表示多少小时，不过是[0-12]的形式；\%{}y表示多少年，不过是[00-99]的格式，比如2014年就输出14；\%{}p，本地的AM或PM文字。等等。


\section{sleep函数 }
sleep函数有时需要用到，将程序休眠个几秒的意思。需要接受一个数值参数，单位是秒，可以是零点几秒。但sleep函数只是大概休眠几秒的意思，最好不去用来计时，因为它不大精确。



\begin{large}
更多内容请参见\href{https://docs.python.org/3/library/time.html}{官方文档}。
\end{large}


\chapter{sys模块}
sys模块有一些功能很常用，其实在前面我们就看到过一些了。

\section{sys.argv}
在刚开始说明python执行脚本参数传递的问题时就已经讲了sys.argv这个变量。这是一个由字符串组成的列表。
\begin{tcbpython}
import sys

print(sys.argv)
for i in range(len(sys.argv)):
    print(sys.argv[i])
\end{tcbpython}
比如新建上面的一个test.py文件，然后执行：
\begin{Verbatim}
python3 test.py test1 test2
['test.py', 'test1', 'test2']
test.py
test1
test2
\end{Verbatim}
我们可以看到sys.argv[0]就是这个脚本的文件名，然后后面依次是各个参数。

\section{exit函数}
这个我们在编写GUI程序的时候经常看到，在其他脚本程序中也很常用。如果不带参数的话那么直接退出程序，还可以带一个字符串参数，返回错误提示信息，或者带一个数字，这里的详细讨论略过。

\begin{tcbbash}[]
>>> import sys
>>> sys.exit('出错了')
出错了
wanze@wanze-ubuntu:~$ 
\end{tcbbash} 
%$

\section{sys.platform}
返回当前脚本执行的操作系统环境。

Linux 返回字符串值：linux；Windows返回win32；Mac OS X 返回darwin。

\section{sys.path}
一连串字符串列表，是python脚本模块的搜索路径，所以我们自定义的python模块，只需要在sys.path这个列表上新加一个字符串路径即可。

\section{标准输入输出错误输出文件}
sys.stdin，sys.stdout，sys.stderr这三个文件对象对应的就是linux系统所谓的标准输入标准输出和错误输出文件流对象。

\section{sys.version}
sys.version输出当前python的版本信息和编译环境的详细信息。

\mint{bash}+sys.version_info[0]+返回当前python主版本的标识，比如python3就返回数字3。

\section{sys.maxsize}
返回当前计算环境下整数(int)类型的最大值，32位系统是$2**31-1$。
\begin{Verbatim}
>>> 2**31-1
2147483647
>>> import sys
>>> sys.maxsize
2147483647
\end{Verbatim}




\begin{large}
更多内容请参见\href{https://docs.python.org/3/library/sys.html}{官方文档}。
\end{large}


\chapter{fileinput模块}
fileinput模块提供了便捷的多文件处理方案。

\section{input函数}
\begin{Verbatim}
fileinput.input(files=None, inplace=False)
\end{Verbatim}
input函数最常用的两个参数如上所示，如果不带参数，那么就是默认的命令行的sys.argv[1:]接受到的一系列文件。如果命令行也没有输入文件参数，那么就是默认的sys.stdin标准输入。特定的文件输入用\textbf{files}来指定，参数为文件名字符值的列表。

\textbf{inplace}默认是False，也就是原文件没有被修改，如果设置为True，那么对于line的一些操作是会原地修改原文件的。具体请看下面的例子：
\begin{tcbpython}[]
allfile = [os.path.join(path,f) for path,dirs,files in os.walk('.')
        if files for f in files]
def process(line):
    return line.replace('skeleton',project_name)
with fileinput.input(files=allfile,inplace=1) as f:
    for line in f:
        print(process(line),end='')
\end{tcbpython}
上面代码第一行使用用os.walk来生成本文件夹下所有的文件名路径。然后作为参数输入给files，这里一般定义一个process函数来处理每一行，然后返回处理后的值。用print函数打印具体的处理的效果。如果这里inpalce没有设置为True那么结果只是打印在终端上，设置为True之后，原文件对应行将被修改。inplace参数很有用\footnote{\href{http://ruslanspivak.com/2010/10/20/in-place-file-rewrite-with-fileinput/}{参考网站}}，在你确认操作结果的情况下慎重使用。


\chapter{os.path模块}
前面提到sys.argv只能返回当前python脚本的文件名，而我们常常需要这个python脚本在系统中的具体位置。前面如os.getcwd等也能获得当前python脚本的所在目录，不过os.path模块的一个有点就是跨平台特性支持很好，也就是一般我们通过其他方式获得的path路径都会用这个模块的函数辅助处理一下。

我们来看下面的例子：
\begin{tcbpython}[]
import os

print(os.path.abspath(__file__))
print(os.path.dirname(os.path.abspath(__file__)))

print(os.path.basename(__file__))
print(os.path.basename(os.environ['HOME']))

\end{tcbpython}
\begin{Verbatim}
/home/wanze/桌面/test.py
/home/wanze/桌面
test.py
wanze
\end{Verbatim}

其中\verb+__file__+表示当前脚本文件，然后接下来的一些命令我们后面慢慢讲。

\section{abspath函数}
abspath函数接受一个path路径值然后返回一个正规的普适的路径地址。比如对于当前文件来说\footnote{文件名也是一个路径}，就是当前文件的具体路径地址，这个和getcwd的python的当前工作目录是不同的，这里的\verb+__file__+就是命令所在的具体的当前的文件地址。

再看下面的例子演示了空字符串默认当前工作目录，然后也接受绝对路径等。
\begin{Verbatim}
>>> import os
>>> os.path.abspath('')
'/home/wanze'
>>> os.path.abspath('test')
'/home/wanze/test'
>>> os.path.abspath('/test')
'/test'
>>> os.path.abspath('test/')
'/home/wanze/test'
\end{Verbatim}

\section{dirname函数}
dirname函数接受一个路径值然后返回这个路径除开最后一个元素的前面的路径值。比如上面的例子，路径指向文件，那么dirname函数返回的是除开这个文件名的前面的路径；而如果接受的路径指向目录，那么返回的是除开最后一个文件夹名的前面的路径值。

\section{basename函数}
如上面例子所示，basename函数接受一个路径值然后返回路径的最后一个元素，如果路径指向文件，那么返回的是文件名；如果路径指向目录，那么返回的是最后那个目录的文件夹名。比如下面实现了从绝对路径提取出文件名的功能。
\begin{Verbatim}
>>> import os.path
>>> string = '/home/wanze/test.txt'
>>> fileName,fileExtension = os.path.splitext(os.path.basename(string))
>>> fileName
'test'
\end{Verbatim}




\section{split函数}
将路径path字符串分割，可以视作dirname和basename的组合。
\begin{Verbatim}
>>> os.path.split('/usr/local/bin/test.txt')
('/usr/local/bin', 'test.txt')
>>> os.path.dirname('/usr/local/bin/test.txt')
'/usr/local/bin'
>>> os.path.basename('/usr/local/bin/test.txt')
'test.txt'
\end{Verbatim}



\section{splitext函数}
将某个路径path的后缀分开，这里主要是针对文件名为输入的时候，那么第一个为该文件的名字，输出数组的第二个值是该文件的后缀。这个函数在提取文件名后缀和前面的名字的时候很有用，方便组合出新的文件名。
\begin{Verbatim}
>>> import os
>>> fileName, fileExtension = os.path.splitext('/path/to/somefile.ext')
>>> fileName
'/path/to/somefile'
>>> fileExtension
'.ext'
\end{Verbatim}


\section{join函数}
用于连接多个路径值合并成一个新的路径值，同样相对于简单的字符串拼接，用这个函数处理路径组合具有操作系统普适性和灵活性。
\begin{Verbatim}
>>> os.path.join(os.path.expanduser('~'),'test','lib')
'/home/wanze/test/lib'
\end{Verbatim}

上面join函数多个参数生成的新path在windows下又是不同的输出的。



\section{expanduser函数}
\begin{Verbatim}
>>> import os
>>> os.path.expanduser('~')
'/home/wanze'
>>> os.path.expanduser('~/pymf')
'/home/wanze/pymf'
>>> os.path.join(os.path.expanduser('~'),'pymf','mymodule')
'/home/wanze/pymf/mymodule'
\end{Verbatim}

\verb+~+这个符号可以在这里使用，从而展开为以/home/wanze为基础的绝对路径，兼容大部分系统（在windows下也可以使用。）

同时我们看到join函数可以接受很多不定量的参数，然后将他们组合成为一个新的路径，而且不用你费心是\verb+/+还是\verb+\+，你不需要写这些了，用join函数自然料理好一切。



\section{exists函数}
os.path.exists(path)：测试路径或文件等是否存在。如果存在返回True，否则返回False。

\section{isfile和isdir还有islink}
os.path.isfile(path)：接受一个字符串路径变量，如果是文件那么返回True，否则返回False（也就是文件不存在或者不是文件是文件夹等情况都会返回False）。

类似的有isdir和islink函数。


\section{samefile函数}
os.path.samefile(path1,path2)：如果两个文件或路径相同则返回True\\，否则返回False。



\begin{large}
更多内容请参见\href{https://docs.python.org/3/library/os.path.html}{官方文档}。
\end{large}


\chapter{glob模块}
glob模块用法很简单，初步学习就是一个glob函数，接受一个pathname路径值，然后返回这个路径下某些文件名组成的列表。支持\verb+* ? +，意思是任意数量的字符或者任意的一个字符，然后\verb+[?]+明确表示问号。
\begin{Verbatim}
>>> import glob
>>> glob.glob('*.py')
['re_subst.py', 're_sub.py', 'test2.py']
\end{Verbatim}




\chapter{subprocess模块}
我想大家都注意到了现在的计算机都是多任务的，这种多任务的实现机制就是所谓的多个进程同时运行，因为计算机只有一个CPU（现在多核的越来越普及了，它们内部的工作原理我没了解过。）所有计算机一次只能处理一个进程，而这种多进程的实现有点类似你人脑（当然不排除某些极个别现象），你不能一边看电影一边写作业，但是可以写一会作业然后再看一会电影（当然不推荐这么做、），计算机的多进程实现机制也和这个类似，就是一会干这个进程，一会儿做那个进程。

计算机的一个进程里面还可以分为很多个线程，这个较为复杂，就不谈了。比如你编写的一个脚本程序，系统就会给它分配一个进程号之类的，然后cpu有时就会转过头来执行它一下（计算机各个进程之间的切换很快的，所以才会给我们一种多任务的错觉。）而你的脚本程序里面还可以再开出其他的子进程出来， python的subprocess模块主要负责这方面的工作。

\section{call函数}
\begin{tcbpython}[]
import subprocess

# Command with shell expansion
subprocess.call(["echo", "hello world"])
subprocess.call(["echo", "$HOME"])
subprocess.call('echo $HOME',shell=True)
\end{tcbpython}
\begin{Verbatim}
hello world
$HOME
/home/wanze
\end{Verbatim}
%$

其中使用shell=True选项后用法较简单较直观，但网上提及安全性和兼容性可能有问题，他们推荐一般不适用shell=True这个选项。\sidenote{\href{http://stackoverflow.com/questions/3172470/actual-meaning-of-shell-true-in-subprocess}{参考网站}}

如果不使用shell=True这个选项的，比如这里\verb+$HOME+这个系统变量就无法正确翻译过来，如果实在需要home路径，需要使用os.path的expanduser函数。



\section{getoutput函数}
取出某个进程命令的输出，返回的是字符串形式。
\begin{Verbatim}
import subprocess

name=subprocess.getoutput('whoami')
print(name)
\end{Verbatim}



\section{getstatusoutput函数}
某个进程执行的状态。



\section{Popen类}
根据Popen类创建一个进程管理实例，可以进行进程的沟通，暂停，关闭等等操作。前面的函数的实现是基于Popen类的，这是较高级的课题，这里暂时略过。



\begin{large}
更多内容请参见\href{https://docs.python.org/3/library/subprocess.html}{官方文档}。
\end{large}



\chapter{os模块}
\section{getcwd函数}
不管你在终端运行python还是运行某个python脚本，总有一个变量存储着当前工作目录的位置。你可以通过getcwd命令来查看当前工作目录。

\begin{xverbatim}[129]{py}
import os
print(os.getcwd())
\end{xverbatim}
上面是通过\LaTeX 文件运行的python小脚本，当你以python命令来运行某个脚本的时候，你调用python命令的地方就是当前的工作目录\footnote{这里在\LaTeX 文档下的情况有点小复杂，通过我编写的xverbatim.sty我们可以看到当时运行python3命令的当前工作目录就在这个tex文档所在的目录下。}。然后加载的其他模块的各个py文件运行时的当前工作目录和主py文件脚本的当前目录是一样的，都是你运行python命令的地方。

如果是终端调用python就是你终端的当前工作目录所在，你可以用pwd命令来查看。如下所示：
\begin{Verbatim}
=>pwd
/home/wanze
=>python3
>>> import os
>>> print(os.getcwd())
/home/wanze
\end{Verbatim}

\section{mkdir函数}
新建一个文件夹。
\begin{Verbatim}
os.mkdir(str)
\end{Verbatim}


\section{chdir函数}
os模块里有一个chdir函数来更改当前工作目录所在地。

可以使用\emph{.}和\emph{..}语法，也可以使用简单的"test"调转到test文件夹。
\begin{Verbatim}
>>> os.chdir('/home/wanze/pymf')
>>> print(os.getcwd())
/home/wanze/pymf
\end{Verbatim}

\section{删除文件}
os.remove(path)

支持相对路径表达。如果路径是目录将会抛出一个OSError异常。

\section{os.rename}
\begin{Verbatim}
os.rename(src, dst)
\end{Verbatim}

第一个参数是目标文件或目录，第二个参数是要替换成为的名字。这个命令一方面可以重命名文件，此外可以移动文件。
 
支持相对路径语法表达，rename在windows下不一定替换原文件，repalce一定替换文件。

\section{os.repalce}
\begin{Verbatim}
os.replace(src, dst)
\end{Verbatim}

rename在windows下不一定替换原文件，repalce一定替换文件。

支持相对路径语法表达。

\section{删除空目录}
os.rmdir(path)

支持相对路径语法表达，只能删除空目录。如果要删除整个目录，请使用shutil.rmtree(path)。

\section{listdir命令}
\begin{Verbatim}
os.listdir(path='.')
\end{Verbatim}

相当于简单的ls命令，将返回一个字符串列表，其内包含本path下所有的文件和文件夹名（包括链接文件）。

可以结合前面介绍的os.path模块的isfile等函数新建一个函数listdir\_{}file，listdir\_{}dir和listdir\_{}link，将普通文件，目录和链接文件区分开来。

\begin{tcbpython}[]
import os

def listdir_dir(path='.'):
    '''os的listdir函数加强，只返回文件夹。'''
    return [dir for dir in os.listdir(path) if os.path.isdir(dir) ]
def listdir_file(path='.'):
    '''os的listdir函数加强，只返回普通文件'''
    return [file for file in os.listdir(path) if os.path.isfile(file)
     and  not os.path.islink(file)]
def listdir_link(path='.'):
    '''os的listdir函数加强，只返回链接文件'''
    return [link for link in os.listdir(path) if os.path.islink(link) ]
\end{tcbpython}




\section{遍历目录树}
\begin{tcbpython}[]
os.walk('.')
\end{tcbpython}

产生一个生成器对象，具体数值含义如下：（dirpath, dirnames, filenames），其中dirpath和filenames可以合并出本目录下所有文件的具体文件名路径，而dirpath和dirnames可以合并出本目录下所有目录的具体路径名。

\section{environ函数}
os.environ，返回一个字典值，这个字典值里面存储着当前shell的一些变量和值。比如系统中“HOME”所具体的路径名是：
\begin{tcbpython}[]
import os
print(os.environ['HOME'])
\end{tcbpython}
\begin{Verbatim}
/home/wanze
>>> 
\end{Verbatim}

\section{getpid函数}
os.getpid函数，返回当前运行的进程的pid。

\section{stat函数}
返回文件的一些信息。比如st\_{}size是文件的大小，单位是字节。

\begin{tcbpython}[]
import os
import glob

print([os.path.abspath(f) for f in glob.glob('*.py')])

print([f for f in glob.glob('*.py') if os.stat(f).st_size > 400])
\end{tcbpython}
\begin{Verbatim}
['/home/wanze/桌面/test.py', '/home/wanze/桌面/flatten.py']
['flatten.py']
\end{Verbatim}

\subsection{文件大小单位优化}
\begin{tcbpython}[]
import os
import sys

filename = sys.argv[1]
filesize = os.stat(filename).st_size

for unit in ['字节','KB','MB','GB','TB']:
    if filesize > 1024:
        filesize = filesize/1024
    else:
        break

print(filename + '大小是' +str(int(filesize)) + unit)
\end{tcbpython}
这个python小脚本自动输出合适的单位，具体程序逻辑还是很简单的。


\begin{large}
更多os模块内容请参见\href{https://docs.python.org/3.4/library/os.html}{官方文档}。
\end{large}

\chapter{shutil模块}
相当于os模块的补充，shutil模块进一步提供了一些系统级别的文件或文件夹的复制，删除，移动等等操作。

\section{复制文件}
\begin{Verbatim}
shutil.copyfile(src, dst)
shutil.copy(src, dst)
shutil.copy2(src, dst)
\end{Verbatim}
其中\textbf{copyfile}的src和dst两个参量都是完整文件路径名，第一个参量是待复制的文件，第二个参量是复制后的文件名；而\textbf{copy}函数的第一个参量是待复制的文件，但是第二个参量是目标文件夹路径；\textbf{copy2}函数和copy函数类似，不同的是它能尝试保留文件的所有元信息metadata（模块开头有说明是理论上但不尽然）。

\section{复制文件夹}
\begin{Verbatim}
shutil.copytree(src, dst)
\end{Verbatim}

\textbf{copytree}函数第一个参量是待复制的文件夹路径名，第二个参量是目标文件夹路径名，其将被创建不应该存在。

\section{删除整个目录}
\begin{Verbatim}
shutil.rmtree(path)
\end{Verbatim}

\textbf{rmtree}函数用于删除整个文件夹，path就是目标文件夹的路径名。

\section{移动文件夹}
\begin{Verbatim}
shutil.move(src,dst)
\end{Verbatim}
\textbf{move}函数把一个文件或者一个文件夹移动到一个文件夹内。



\section{chown函数}
\begin{Verbatim}
shutil.chown(path, user=None, group=None)
\end{Verbatim}

\textbf{chown}函数类似的linux系统下的chown函数，这个函数基于os.chown函数，不过接口更友好。


\section{which函数}
\begin{Verbatim}
shutil.which(cmd)
\end{Verbatim}

\textbf{which}函数类似的linux系统下的which函数。



\begin{large}
更多shutil模块内容请参见\href{https://docs.python.org/3.4/library/shutil.html}{官方文档}。
\end{large}


\chapter{tarfile和zipfile模块}
tarfile是gzip，bz2和lzma压缩文件读写的解决方案，zipfile模块是zip压缩文件的解决方案，\uwave{值得一提的是pip管理的egg文件也可以通过zipfile模块来管理}。

\section{制作gz压缩文件}
请看下面的例子：
\begin{tcbpython}[]
import tarfile
with tarfile.open("skeleton.tar.gz", "w:gz") as tar:
    for name in ["setup.py","LICENSE","README.md","skeleton", "docs"]:
        tar.add(name)
\end{tcbpython}

这里首先用tarfile模块的\textbf{open}函数来返回一个TarFile对象，其中第一个参数是你的压缩文件的名字，第二个参数是处理模式。

模式可接受的参数如下：
\begin{description}
\item[r] 默认值是r，就是只读某个压缩文件。类似有\textbf{r:gz}，\textbf{r:bz2}和\textbf{r:xz}，这里的意思就是具体设置好要读的压缩文件的格式（gzip，bzip2和lzma）。
\item[w] 类似的还有\textbf{w:gz}，\textbf{w:bz2}，\textbf{w:xz}。这里\textbf{w}或者\textbf{w:}官方文档的说明是（Open for uncompressed writing），我对这个无压缩方式写不是很理解。
\item[a] 还有\textbf{a:}， 	Open for appending with no compression. 文件如果不存在将被创建。
\end{description}

\subsection{TarFile的add方法}
然后接下来就是往压缩文件里面添加内容（文件或者整个目录），具体就是用创建的TarFile对象的add方法，如上例子所示。

\section{解压缩gz压缩文件}
最简单的例子如下所示：
\begin{tcbpython}[]
with tarfile.open("skeleton.tar.gz") as tar:
    tar.extractall()
\end{tcbpython}

\subsection{TarFile的extractall方法}
用tarfile模块的open函数打开那个压缩文件，用返回的TarFile对象的extractall方法解压缩这个文件，注意用os.chdir来控制当前工作目录。


\begin{large}
更多tarfile模块内容请参见\href{https://docs.python.org/3.4/library/tarfile.html}{官方文档}。
\end{large}

\section{提取egg文件中的内容}
简单的例子如下所示：
\begin{tcbpython}[]
zip=zipfile.ZipFile("test.egg")
zip.extract('test.txt')
\end{tcbpython}
这里用zipfile模块的ZipFile构造函数创建了一个ZipFile对象，然后用ZipFile的\textbf{extract}方法提取出了test.txt文件在当前工作目录。

相关的\textbf{extractall}方法将会提取出压缩文件中所有的内容。

\section{制作zip压缩文件}
简单的示例如下：
\begin{tcbpython}[]
with zipfile.ZipFile('test.zip','w') as zip:
    zip.write('test2.png')
\end{tcbpython}
首先用zipfile模块的ZipFile构造函数创建一个ZipFile对象，这里mode需要使用\textbf{'w'}，然后使用ZipFile对象的write方法来添加内容。你可以猜到如果模式是\textbf{'a'}的话write方法是给这个压缩文件添加内容（a模式同文件操作含义如果原压缩文件不存在也是可以创建的）。



\begin{large}
更多zipfile模块内容请参见\href{https://docs.python.org/3.4/library/zipfile.html}{官方文档}。
\end{large}


\chapter{collections模块}
\section{namedtuple函数}
collections模块里面的namedtuple函数将会产生一个有名字的数组的类（有名数组），通过这个类可以新建类似的实例。比如：
\begin{xverbatim}[129]{py}
from collections import namedtuple

Point3d=namedtuple('Point3d',['x','y','z'])
p1=Point3d(0,1,2)
print(p1)
print(p1[0],p1.z)
\end{xverbatim}

\section{Counter计数类}



\begin{large}
更多内容请参见\href{https://docs.python.org/3/library/collections.html}{官方文档}。
\end{large}



\chapter{re模块}
\label{sec:re模块}
re模块提供了python对于正则表达式的支持，对于字符串操作，如果之前在介绍字符串类型的一些方法（比如split，replace等等），能够用它们解决问题就用它们，因为更快更简单。实在需要动用正则表达式理念才考虑使用re模块，而且你要克制写很多或者很复杂的（除非某些特殊情况）正则表达式的冲动，因为正则表达式的引入将会使得整个程序都更加难懂和不可捉摸。

\begin{large}
更多内容请参见\href{https://docs.python.org/3/library/re.html}{官方文档}。
\end{large}

\section{re模块中的元字符集}
\begin{description}
\item[\emph{.}] 表示一行内的任意字符，如果如果通过re.compile指定\textbf{re.DOTALL}，则表示多行内的任意字符，即包括了换行符。此外还可以通过字符串模板在它的前面加上\textbf{(?s)}来获得同样的效果。
\item[\emph{*}] 对之前的字符匹配\uwave{零次}或者多次。
\item[\emph{+}] 对之前的字符匹配\uwave{一次}或者多次。
\item[\emph{?}] 对之前的字符匹配\uwave{零次}或者\uwave{一次}。
\item[\emph{\{m\}}] 对之前的字符匹配(\uwave{exactly})m次。
\item[\emph{\{m,n\}}] 对之前的字符匹配m次到n次，其中n次可能省略，视作默认值是无穷大。
\item[\emph{\^{}}] 表示字符串的开始，如果加上\textbf{re.MULTILINE}选项，则表示行首。此外字符串模板加上\textbf{(?m)}可以获得同样的效果。
\item[\emph{\${}}] 表示字符串的结束，同\^{}类似，如果加上\textbf{re.MULTILINE}选项，则表示行尾，可以简单理解为\verb+\n+换行符。此外字符串模板加上\textbf{(?m)}可以获得同样的效果。

\${}符号在re.sub函数中可以被替换为另外一个字符串，其具体效果就是原字符串尾加上了这个字符串，类似的\^{}被替换成某个字符串，其具体效果就是原字符串头加上了这个字符串。这里显然\^{}和\${}在字符串中都不是真实存在的字符，而没有这个所谓的标记，所以这种替换总给人怪怪的感觉。
\item[\emph{[]}] [abc]字符组匹配一个字符，这个字符是a或者b或者c。类似的[a-z]匹配所有的小写字母，\verb+[\w]+匹配任意的字母或数字，具体请看下面的特殊字符类。
\item[\emph{|}] 相当于正则表达式内的匹配或逻辑。
\item[\emph{()}] 圆括号包围的部分将会记忆起来，方便后面调用。这个后面在谈及。
\end{description}



\section{re模块中的特殊字符类}
\begin{Verbatim}
\w  任意的字母或数字  [a-zA-Z0-9_]  (meaning word)
\W  匹配任何非字母非数字 [^a-zA-Z0-9_]
\d   [0-9]   (digit) 数字
\D  [^0-9] 非数字
\s   匹配任何空白字符   [ \t\n\r\f\v] 。
\S  匹配任何非空白字符
匹配中文:[\u4e00-\u9fa5]
\b  文档说严格的定义是\w 和\W 之间的边界，反之亦然。粗略的理解可以看作是英文单词头或者尾。
\end{Verbatim}

其中\^{}在方括号[]里面，只有在最前面，才表示排除型字符组的意思。


\section{转义问题}
正则表达式的转义问题有时会比较纠结。一个简单的原则是以上谈及的有特殊作用的字符有转义问题，如果python中的字符都写成\verb+r''+这种形式，也就是所谓的raw string形式，这样\verb+\n+在里面就可以直接写成\verb+\n+，而\verb+\section+可以简单写为\verb+\\section+即可，也就是\verb+\+字符需要转义一次。

然后字符组的方括号内[]有些字符有时是不需要转义的，这个实在不确定就转义吧，要不就用Kiki测试一下。


\section{re模块的使用}
compile方法生成regular expression object这一条线这里略过了，接下来的讨论全部基于（原始的）字符串模板。

字符串模板前面提及(?m)和(?s)的用法了，然后\textbf{(?i)}表示忽略大小写。

\subsection{匹配和查找}
search，match方法简单地用法就是：
\begin{Verbatim}
re.search(字符串模板, 待匹配字符串)
re.match(pattern, string)
\end{Verbatim}

它们将会返回一个match object或者none，其中match object在逻辑上就是真值的意思。match对字符串的匹配是必须从一开始就精确匹配，这对于正则表达式多少0有点突兀。推荐使用search方法，如果一定要限定行首，或者字符串开始可以用前面讨论的正则表达式各个符号来表达。请看下面的例子。

\begin{tcbpython}[]
import re
string = '''this is test line.
this is the second line.
today is sunday.'''

match = re.search('(?m)^today',string)

if match:
    print('所使用的正则表达式是：',match.re)
    print('所输入的字符串是：',match.string)
    print('匹配的结果是：',match.group(0))
    print('匹配的字符串index',match.span())
else:
    print('return the none value')
\end{tcbpython}

前面说道圆括号的部分将会记忆起来，作为匹配的结果，默认整个正则表达式所匹配的全部是group中的第0个元素，然后从左到右，子group编号依次是1，2，3......。

\begin{Verbatim}
所使用的正则表达式是： re.compile('(?m)^today', re.MULTILINE)
所输入的字符串是： this is test line.
this is the second line.
today is sunday.
匹配的结果是： today
匹配的字符串index (44, 49)
\end{Verbatim}

具体这些信息是为了说明情况，实际最简单的情况可能就需要判断一下是不是真值，字符串模板是不是匹配到了即可。


\subsection{分割操作}
re模块的split函数可以看作字符串的split方法的升级版本，对于所描述的任何正则表达式，匹配成功之后都将成为一个分隔符，从而将原输入字符串分割开来。

下面是我写的zwc小脚本的最核心的部分，用途是统计中英文文档的具体英文单词和中文字符的个数。其中最核心的部分就是用的re的split函数进行正则表达式分割，如果不用那个圆括号的话，那么分隔符是不会包含进去的，这里就是具体匹配的中文字和各个标点符号等等。用了圆括号，那么圆括号匹配的内容也会进去列表。这里就是具体的各个分隔符。

\begin{tcbpython}[]
import re

def zwc(string):
    #中英文常用标点符号
    lst = re.split('([\u4e00-\u9fa5\s，。；])',string)
    #去除 空白
    #去除\s 中英文常用标点符号
    lst = [i for i in lst if not  i in
    [""," ","\n","\t","\r","\f","\v","；","，","。"]]
    print(lst)

if __name__ == '__main__':
    string='''道可道，非常道。名可名，非常名。無名天地之始，有名萬物之母。
    故常無欲，以觀其妙；常有欲，以觀其徼。此兩者同出而異名，
    同謂之玄，玄之又玄，眾妙之門。 '''
    zwc(string)
\end{tcbpython}

字符分割之后后面做了一个小修正，将匹配到的空白字符和中英文标点符号等都删除了，这些是不应该统计入字数的。

具体这个github项目链接在这里：\href{https://github.com/a358003542/zwc}{zwc项目}。


\subsection{替换操作}
基于正则表达式的替换操作非常的有用，其实前面的search方法，再加上具体匹配字符串的索引值，然后修改原字符串，然后再search这样循环操作下去，就是一个替换操作了。re模块有sub方法来专门解决这个问题。

让我们为Linux系统写一个resub命令，这个命令的用途就是将某一个标准输入流或者utf-8文本文件按照你定义的正则表达式规则，依次完成一个\footnote{这里简单起见就是一个，多个情况可以考虑编写另外一个程序来控制之。}正则表达式文本替换工作。这个命令在我们需要对某个utf-8文本文件进行某个你想要的——非简单的精确相同匹配然后替换操作时——特别有用。

为了作为程序的检验，这里提出两个任务：第一个任务是我们在ocr PDF文档之后的输出，经常发现很多标点符号问题，这些需要人手工修改会非常的耗费精力。其中第一个问题如下，"这是一段文字"需要替换成为“这是一段文字”。这个例子之所以特别是因为中文的双引号是分左和右的，这里必须要用正则表达式匹配和替换；第二个任务更加的复杂，那就是从排版角度上讲，如果括号里面的文字都是英文或者数字，那么就使用英文的括号()，如果括号里面有中文或者全是中文\footnote{这里程序的逻辑是都换成中文的全角括号（毕竟中文unicode码具体范围的判断是不太精确的），只有那些纯英文纯数字或者基本英文标点和其他简单符号的再换成英文括号}，那么就使用中文的括号（）。ocr出来或者甚至人编写的文档都常常难以做到没有瑕疵，第二个任务就是通过resub命令来确保之后的输出文档的括号满足这一要求。

然后程序还需要建立两个选项，一个是自动替换所有，一个是对于每一个替换操作都请求确认——需要打印相关信息。

程序需要经过如下几个阶段：1.明确匹配模板  1.1写出字符串模板 匹配操作 给出匹配的所有情况，最好是行模板匹配模式。  最后明确匹配情况 2.明确匹配的文字的后给出情况 

\chapter{itertools模块}
\label{sec:itertools}
\section{repeat函数}
其定义函数如下：
\begin{Verbatim}
def repeat(object, times=None):
    # repeat(10, 3) --> 10 10 10
    if times is None:
        while True:
            yield object
    else:
        for i in range(times):
            yield object
\end{Verbatim}
也就是返回一个可迭代对象，这么封装最大的一个用处是用于填充map函数或者zip函数的某个常数值。因为你填写repeat(5)之后将一个返回一个可迭代对象，不停的返回数字5而不需要你考虑长度问题。

\section{starmap函数}
starmap函数具体定义如下所示：
\begin{tcbpython}[]
def starmap(function, iterable):
    # starmap(pow, [(2,5), (3,2), (10,3)]) --> 32 9 1000
    for args in iterable:
        yield function(*args)
\end{tcbpython}
其接受一个可迭代对象，然后逐个将可迭代对象中的元素解包之后送入函数当参数（最后当然函数也执行了）。



\chapter{multiprocessing模块}
multiprocessing为python提供了多进程（或者多线程）的解决方案。

\section{Pool类}
\begin{Verbatim}
from multiprocessing import Pool

def f(x):
    return x*x

if __name__ == '__main__':
    with Pool(5) as p:
        print(p.map(f, [1, 2, 3]))
\end{Verbatim}
这里Pool的第一个参数是可选项\textbf{processes}，如果不设置，则默认的是\verb+os.cpu_count()+，即当前系统的cpu数。

一般cpu密集型的任务推荐使用多进程处理，当然前提是你有多个cpu的情况下，如果你并没有相关硬件条件，追求时髦动用多进程还不如用单进程，集中精力用好的算法办好一件事。不过不同进程（不同程序）之间的通信还是很有用的。

这里的map是Pool对象的\textbf{map}方法，其除了接受第一个列表参数，然后用多进程分别处理这些列表中的元素之外，并不能在额外接受其他参数了。如果你想要接受一些参数，推荐使用\textbf{starmap}方法。

\subsection{starmap方法}
starmap类似map方法，不过其接受的是一系列的函数参数。值得注意的是python的itertools模块\ref{sec:itertools}里面提供的starmap，repeat还有python语言的zip和map函数等在此处有时会很有用，可能是你感兴趣的。
\begin{tcbpython}[]
from multiprocessing import Pool

def f(x,y):
    return (x*x+y*y)

if __name__ == '__main__':
    with Pool(5) as p:
        print(p.starmap(f, [(1,1),(2,2),(3,3)]))
\end{tcbpython}

在看一个有可选参数的情况：

\begin{tcbpython}[]
from multiprocessing.dummy import Pool as ThreadPool
from itertools import repeat

urls = get_all_urls(base_url,model_url)

with ThreadPool(6) as tp:
    imgs = tp.starmap(get_url_imgs,zip(urls,repeat(inclass))
\end{tcbpython}
这里的\verb+get_url_imgs+除了接受第一个url参数之外，还接受一个可选参数inclass，这里通过repeat封装之后将这两个参数用zip函数封装即能达到这样的执行效果：
\begin{Verbatim}
get_url_imgs(url,inclass)
get_url_imgs(url,inclass)
get_url_imgs(url,inclass)
.....
\end{Verbatim}
然后这些都是多线程运行的。


\section{ThreadPool类}
一般和网络相关的I/O密集型任务推荐使用多线程处理，但也不是线程设置得越多越好，一般设置为当前CPU数*2+2左右，再多并没有起到提速效果，有时反而会降低速度。

multiprocessing还有一个dummy子模块，其提供了和multiprocessing一样的API\footnote{请参看这个\href{http://segmentfault.com/blog/caspar/1190000000414339b}{网页}。}，不同的是multiprocessing作用于进程，而dummy子模块是作用于线程的。


\begin{Verbatim}
from multiprocessing.dummy import Pool as ThreadPool

with ThreadPool(6) as tp:
    imgs = tp.map(partial_get_url_imgs,urls)
\end{Verbatim}

\chapter{socket模块}
\section{setdefaulttimeout函数}
设置全局socket的timeout参数，

\section{timeout异常}
timeout异常，当套接字工作时等待时间超过timeout参数时，将触发这个timeout异常。

\chapter{urllib模块}
\section{urlopen函数}
urlopen函数在urllib模块的request子模块，其提供了简单的获取目标url网页内容的接口。一个简单的例子如下所示：

\begin{tcbpython}[]
from urllib.request import urlopen
import socket
socket.setdefaulttimeout(10)

urls = ['https://www.google.com.cn','https://www.google.com',
    'http://www.google.com.cn']

for url in urls:
    try:
        response = urlopen(url)
        html = response.read().decode('utf-8')
        print(html)
    except socket.timeout as error:
        print(error)
    except OSError as error:
        print(error)
\end{tcbpython}

为什么刚开始就用这么一个稍显复杂的例子作为演示，well，天朝网络的特色。如果你用百度的url ~http://www.baidu.com~ ，可能大部分情况下你都不用操心这些问题，但既然我们处在天朝网络这个大背景下，还是早点介绍这个。这个例子的返回的error种类似乎间接地反映了GFW的工作原理。

比如google的.com.cn的https连接还能正常工作（目前暂时。。），只是有时会有点慢，然后其http连接则会返回404错误，这是天朝网络常见的网络错误了，大家的分析是GFW进行了dns投毒。而对于google的.com连接不管是http或者https连接都会返回OSError错误，说的是：Network is unreachable，这表明GFW对于后缀google.com的url采取的完全硬件级别的网络掐断。

然后urlopen函数第一个参数是url连接这不用多说，其还有很多可选项，其中很重要的参数就是\textbf{timeout}参数，这个和socket套接字的工作模式相关。如果不加上这个timeout参数，对于某些被墙的网站就会一直尝试然后程序陷入卡死状态了。在后面会介绍\textbf{urlretrieve}函数，也在这个urllib.request模块下面，这个函数可以用于网络下载东西，其并没有内置的timeout参数，不过可以通过设置全局网络socket的timeout（前面socket模块的setdefaulttimeout函数），这个全局timeout最好设置得稍微大一点。

关于TCP/IP协议还有HTTP协议之类的我还没弄清楚，不管怎么说，似乎对于程序员来说，数据的发送和接受都是通过一个所谓的套接字来完成的。这里的套接字socket的timeout参数就是控制阻塞时间的，因为有些网络数据不可能一次就传递完，好比下载过程一样的有个时间，而这个timeout就是控制这个下载时间的，如果超过这个时间了那么直接返回错误。

这里有个问题，就是这个程序默认全局socket的timeout都设置为10秒，那么会不会以后用urlretrieve函数下载某个东西，本身就要求超过10秒？对此还不清楚。

因为网络上的情况比较复杂，关于网络的这些异常处理是不可回避的话题。上面虽然只是一个简单读取网页的程序也跟上了这么多异常捕捉，不是为了偏执的追求程序的健壮，而是必要的必须做的工作。


\section{HTTPError和URLError异常}
\begin{Verbatim}
from urllib.error import HTTPError
\end{Verbatim}
HTTPError是URLError的子类，URLError是OSError的子类，而OSError是不要加载模块就可以直接引用的，所以简单的处理就用OSError来捕捉。

\section{ContentTooShortError异常}
\begin{Verbatim}
from urllib.error import ContentTooShortError
\end{Verbatim}
当\textbf{urlretrieve}函数下载的数据量少于预期的数据量时返回这个错误。



\part{python3高级篇}




\chapter{python的元类编程}
python中的类和class自己定义的类和具体实例化的对象我们都了解了，而以上这些都是基于元类(metaclass)这个概念。

元类可以看作python中类的最底层的原子结构了，默认的元类叫做\textbf{type}。元类创造类，类创造实例。所谓的元类编程就是......读者在使用元类编程之前需要评估好是不是需要使用这么底层的概念。

\begin{tcbpython}[]
class C():
    pass
\end{tcbpython}

\begin{tcbpython}[]
C = type('C',(),{})
\end{tcbpython}



\appendix
\part{附录}
\chapter{python第三方模块参考资料}
\begin{enumerate}
\item 当然，首先是各第三方模块的官方参考tutorial或reference。
\item 我整理的一些python第三方模块的参考资料，在\href{http://www.cdwanze.org/}{这个网站}的\textbf{python第三方模块}部分。
\end{enumerate}


\chapter{linux及时了解}
\begin{enumerate}
\item 
\item 我整理的有关linux系统上的一些知识，在\href{http://www.cdwanze.org/}{这个网站}的\textbf{linux}部分。
\end{enumerate}


\chapter{古怪的python}
本附录部分写了一些python中我认为很古怪的部分，因为古怪，所以常常被人忽视。

\section{字符串比较大小}
读者可以实验一下python中字符串之间是可以比较大小的：

\begin{Verbatim}
>>> 'abc' > 'ab'
True
>>> 'fabc' > 'abc'
True
>>> '3.04' > '3'
True
\end{Verbatim}

这个特性有的时候很有用的，具体是如何比较大小的呢？按照python官方文档的描述，采用的是词典编纂顺序。具体描述信息如下：

\begin{quotation}
序列之间比较大小是，首先两个序列各自的第一个元素开始比较，如果它们相同，则进行下一个比较，直到任何一个序列被穷尽。如果两个序列各自比较的类型都是相同的，那么整个过程将一直进行下去。如果两个序列是相等的则认为它们是相等的，如果某一个序列是另外一个序列的子序列，则那个短的序列认为比长的序列要小。具体到每一个元素的大小比较，是按照ASCII顺序对其进行比较的。
\end{quotation}

\subsection{中文比较大小？}
读者这时会想到，既然python中字符串都默认是unicode编码（utf-8），那么中文应该也是能够比较大小的吧，事实确实如此：

\begin{Verbatim}
>>> '章' > '张'
True
>>> '章' < '张'
False
>>> ord('章')
31456
>>> ord('张')
24352
\end{Verbatim}

感兴趣的读者可以打开字符映射表看一下，'张'对应的unicode编号是U+5F20，你输入0x5f20，返回的正是24352。如果你输入hex(24352)，返回的就是'0x5f20'。


\subsection{ord和chr函数}
ord函数接受\textbf{一个}字符，然后返回其unicode编码，十进制的。chr函数是ord函数的反向，比如你输入24352这个十进制uniocde，就返回了对应的字符。
\begin{Verbatim}
>>> chr(24352)
'张'
\end{Verbatim}

所以我们可以总结到，python3的字符串比较大小，是基于utf-8编码的。











\addchtoc{参考文献}
\begin{thebibliography}{9}
\bibitem{python入门教程} python入门教程，python官网上的tutorial。原作者：Guido van Rossum  Fred L. Drake ；中文翻译：刘鑫等；版本：2013-10-28；pdf下载链接：\href{https://drive.google.com/open?id=0ByWxOeitx54PSW40bU5zNVhuMlU&authuser=0}{python入门教程}  。

\bibitem{learning python} learning python，主要python语言参考，我主要参看了python学习手册（第四版）。原作者：Mark Lutz，中文翻译：李军，刘红伟等。

\bibitem{programming python} programming python，作者Mark Lutz对python编程的进阶讨论；版本：第四版。

\bibitem{python官网} python\href{https://docs.python.org/3/}{官网上的资料}。

\bibitem{第三方模块参考手册} 第三方模块参考手册，如numpy, scipy, matplotlib等等第三方模块官网上发布的官方参考手册。

\bibitem{zetcode网站} zetcode网站pyqt4部分，这是\href{http://zetcode.com/gui/pyqt4/}{英文网站链接}，这是jimmykuu的\href{http://blog.cx125.com/books/PyQt4_Tutorial/}{中文翻译网站}。

\bibitem{dive into python3} dive into python3，\href{http://www.diveintopython3.net/index.html}{the english origin site} , 这是\href{http://sebug.net/paper/books/dive-into-python3/index.html}{中文网站链接}。

\bibitem{numpy beginner's guide book} numpy beginner's guide book，the pdf download link is \href{https://drive.google.com/open?id=0ByWxOeitx54PNXRIMUVybTlLZDQ&authuser=0}{here} . 

\bibitem{Introduction to Python for Econometrics, Statistics and Data Analysis} Introduction to Python for Econometrics,Statistics and Data Analysis，the pdf download link is\href{https://drive.google.com/open?id=0ByWxOeitx54PTXN6RW5ydzQ4YXc&authuser=0}{here}.

\bibitem{A Guide to Python's Magic Methods} A Guide to Python's Magic Methods，作者：Rafe Kettler ,版本：2014-01-04，github地址：\href{https://github.com/RafeKettler/magicmethods}{here}.

\bibitem{metaprogramming} metaprogramming，the website link is \href{http://python-3-patterns-idioms-test.readthedocs.org/en/latest/Metaprogramming.html}{here} .

\bibitem{matplotlib tutorial} matplotlib tutorial，author: Nicolas P. Rougier , the website is  \href{http://www.labri.fr/perso/nrougier/teaching/matplotlib/}{here}.  



\end{thebibliography}



%这里空一行

\end{common-format}
\end{document}