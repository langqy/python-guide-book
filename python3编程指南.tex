%!Mode:: "TeX:UTF-8"%確保文檔utf-8編碼
%新加入的命令如下：addchtoc addsectoc reduline showendnotes hlabel
%新加入的环境如下：common-format  fig  xverbatim

\documentclass[12pt,oneside]{book}
\newlength{\textpt}
\setlength{\textpt}{12pt}


\usepackage{myconfig}
\usepackage{mytitle}



\begin{document}
\frontmatter

\titlea{python3指南}
\titleb{用python3玩转电脑}
\author{万泽}
\authorinfo{作者：}
\editor{德山书生}
\email{a358003542@gmail.com}
\editorinfo{编者：}
\version{0.01}
\titleLB

\addchtoc{前言}
\chapter*{前言}
\begin{common-format}
需要提醒的是在本文档中不管是xverbatim环境生成的code文件还是cverbatim环境，最前面都多了一个空行，因为最前面有一个newlinechar符号最后转变成换行了，我还不知道如何避免，所以，如果你需要将代码文件以可执行模式执行（以脚本文件模式载入的没有问题），你需要进入文件按一下Backspace键将第一行消去即可。

主要参考资料：

1.python入门教程 Python 教學文件 作者：Guido van Rossum  Fred L. Drake

2.learning python v5  主要python语言参考   python学习手册（第四版） 老鼠版

3.programming python v4 蟒蛇版

4.python官网其他参考资料（遇到问题则google之，这部分不会专门学习）

5.pyqt4 tutorial \href{http://zetcode.com/gui/pyqt4/}{英文网站} 也参考了jimmykuu的中文翻译，\href{http://blog.cx125.com/books/PyQt4_Tutorial/}{中文翻译网站}

6.

ipython3部分
1.An introduction to Numpy and Scipy  2012 M. Scott Shell

2.NumPy Beginner's Guide 2013 Ivan Idris

8.其他网络资源在此一并谢谢了。

%这里空一行。

\end{common-format}


\addchtoc{目录}
\setcounter{tocdepth}{2}
\tableofcontents

\begin{common-format}
\mainmatter

\part{python3基础}

\chapter{beginning}
\section{python简介}
Python是个成功的脚本语言。它最初由Guido van Rossum开发，\sidenote{这是一段测试文字}在1991年第一次发布。Python由ABC和Haskell语言所启发。Python是一个高级的、通用的、跨平台、解释型的语言。一些人更倾向于称之为动态语言。它很易学，Python是一种简约的语言。它的最明显的一个特征是，不使用分号或括号，Python使用缩进。现在，Python由来自世界各地的庞大的志愿者维护。

python现在主要有两个版本区别，python2和python3。作为新学者推荐完全使用python3编程，本文档完全基于python3。

完全没有编程经验的人推荐简单学一下c语言和scheme语言（就简单学习一下这个语言的基本概念即可）。相信我学习这两门语言不会浪费你任何时间，其中scheme语言如果你学得深入的话甚至编译器的基本原理你都能够学到。了解了这两门语言的核心理念，基本上任何语言在你看来都大同小异了。

\section{进入python的REPL环境}
在ubuntu13.10下终端中输入python即进入python语言的REPL环境，目前默认的是python2。你可以运行：\\
\verb+python  --version+\\
来查看。要进入python3在终端中输入python3即可。


\section{python3命令行用法}
命令行的一般格式就是：\\
\verb+python3  [可选项]  test.py  [可选参数1 可选参数2]+

同样类似的运行\verb+python3  --help+即可以查看python3命令的一些可选项。比如加入\textbf{-i}选项之后，python执行完脚本之后会进入REPL环境继续等待下一个命令，这个在最后结果一闪而过的时候有用。后面的-c，-m选项还看不明白。

\subsection{python执行脚本参数的传递}
上面的命令行接受多个参数都没有问题的，不会报错，哪怕你在py文件并没有用到他们。在py文件中要使用他们，首先导入sys宏包，然后sys.argv[0]是现在这个py文件在系统中的文件名，接下来的sys.argv[1]就是之前命令行接受的第一个参数，后面的就依次类推了。


\section{geany的相关配置}
geany的其他配置这里不做过多说明，就自动执行命令默认的应该是python2，修改成为：\\
\verb+python3  -i  %f  +\\
即可。


\section{代码注释}
python语言的注释符号和bash语言（linux终端的编程语言）一样用的是\#{}符号来注释代码。然后py文件开头一般如下面代码所示：
\begin{Verbatim}
#!/usr/bin/env python3
#-*-coding:utf-8-*-
\end{Verbatim}
其中代码第一行表示等下如果py文件可执行模式执行那么将用python3来编译\footnote{也就是用chmod加上可执行权限那么可以直接执行了。第一行完整的解释是什么通过\textit{env}程序来搜索python的路径，这样代码更具可移植性。}，第二行的意思是py文件编码是utf-8编码的，python3直接支持utf-8各个符号，这是很强大的一个更新。


多行注释可以利用编辑器快速每行前面加上\#{}符号。

\section{Unicode码支持}
前面谈及python3是可以直接支持Unicode码的，如果以可执行模式加载，那么第二行需要写上：\\
\verb+#-*-coding:utf-8-*-+\\
这么一句。

\begin{Verbatim}
#!/usr/bin/env python3
#-*-coding:utf-8-*-
print('\u2460')
\end{Verbatim}
上面的数字是具体这个Unicode符号的十六进制。

\section{代码多行表示一行}
这个技巧防止代码越界所以经常会用到。用反斜线\textbackslash 即可。不过通常更常用的是将表达式用圆括号( )括起来，这样内部可以直接换行并继续。在python中任何表达式都可以包围在圆括号中。

\subsection{一行表示多行}
python中一般不用分号，但是分号的意义大致和bash或者c语言中的意义类似，表示一行结束的意思。其中c语言我们知道是必须使用分号的。


\section{输入和输出}
\subsection{最基本的input和print命令}
input函数请求用户输入，并将这个值赋值给某个变量。注意赋值之后类型是字符串，但后面你可以用强制类型转换——int函数（变成整数），float函数（变成实数），str函数（变成字符串）——将其转变过来。print函数就是一般的输出函数。

\begin{Verbatim}
x=input('请输入一个实数：')
string001='你输入的这个实数乘以2等于：'+ str(float(x)*2)
print(string001)
\end{Verbatim}





\chapter{程序中的逻辑}
\section{布尔值}
boolean类型，和大多数语言一样，就两个值：\textbf{True}，\textbf{False}。然后强制类型转换使用函数\textbf{bool}。

\subsection{其他逻辑小知识}
在python中，有些关于逻辑真假上的小知识，需要简单了解下。
\begin{itemize}
\item 数0、空对象或者其他特殊对象None值都认为是假\sidenote{比如列表都是真，但空列表是假。}
\item 其他非零的数字或非空的对象都认为是真
\item 前面两条用bool函数可以进行强制类型转换
\item 比较和相等测试会递归作用在数据结构中
\item 比较和相等测试会返回True或False（1和0的custom version（翻译为定制版？））
\end{itemize}

\section{条件判断}
python中的条件语句基本格式如下：
\begin{Verbatim}
if  test:
    条件判断执行区块
\end{Verbatim}
也就是if命令后面跟个条件判断语句，然后记住加个冒号，然后后面缩进的区块都是条件判断为真的时候要执行的语句。

\begin{Verbatim}
if  test:
    do something001
else :
    do something002
\end{Verbatim}
这里的逻辑是条件判断，如果真，do something001；如果假，do something002。

\begin{Verbatim}
if  test001:
    do something001
elif test002:
    do something002
\end{Verbatim}
显然你一看就明白了，elif是else和if的结合。






\subsection{逻辑与或否}
and表示逻辑与，or表示逻辑或，not表示逻辑否。

下面编写一个逻辑，判断一个字符串，这个字符串开头必须是a或者b，结尾必须是s，倒数第二个字符不能是单引号'。在这里就演示一下逻辑。。
\begin{xverbatim}[129]{py}
x='agais'
if ((x[0] == 'a' or x[0] == 'b')
    and x[-1] =='s'
    and (not x[-2] =="'")):
    print('yes it is..')
\end{xverbatim}
上面的显示效果是xverbatim环境input之后的问题，目前主要的问题就是新的一行前面的空格无法显示，想了一些方法都不行，只好作罢。


\subsection{稍复杂的条件判断}
现在我们了解了if，elif和else语句，然后还了解了逻辑与或非的组合判断。那么在实际编程中如何处理复杂的条件逻辑呢？

首先能够用逻辑语句与或非组合起来的就将其组合起来，而不要过分使用嵌套。如下面代码所示，如果一个情况分成两部分，那么就用if...eles...语句，
\begin{tcbpython}[]
x=-2
if x>0:
    print('x大于0')
else:
    print('x小于0')
\end{tcbpython}

而如果一个情况分成三部分，那么就用if...elif...else语句。同一深度的这些平行语句对应的是“或”逻辑，或者说类似其他编程语言的switch语句。
\begin{tcbpython}
x=2
if x>0:
    print('x大于0')
elif x<0:
    print('x小于0')
else:
    print('x等于0')
\end{tcbpython}

我们再看一看下面的代码，这个代码是\emph{错误的}，两个if语句彼此并不构成逻辑分析关系。\footnote{四个甚至更多的平行或逻辑就用更多的elif，读者请自己实验一下。}
\begin{tcbpython}
x=2
if x>0:
    print('x大于0')
if x<0:
    print('x小于0')
else:
    print('x等于0')
\end{tcbpython}


然后我们看到下面的代码，这个例子演示的是在加深一个深度的条件判断语句它当时处于的逻辑判断情况，这个语句的条件判断逻辑是本语句的判断逻辑再和左边（也就是前面）的深度的判断逻辑的“与”逻辑，或者说成是“交集”。比如说\textit{print('0<x<2')}这个语句就是本语句的判断逻辑\textit{x<2}和上一层判断逻辑\textit{x>0}的“交集”，也就是\textit{0<x<2}。

\begin{tcbpython}
x=-2
if x>0:
    print('x大于0')
    if x>2:
        print('x>2')
    elif x<2:
        print('0<x<2')
    else:
        print('x=2')
elif x<0:
    print('x小于0')
else:
    print('x等于0')
\end{tcbpython}


整个过程的情况如下图所示：
\begin{linefig}{复杂条件判断}
\caption{复杂条件判断}
\label{fig:复杂条件判断}
\end{linefig}
为了在编程的时候对处于何种判断逻辑之下有一个清晰的认识，强烈建议读者好好思考一下。毕竟磨刀不误砍柴功。





\subsection{try语句捕捉错误}
try语句是编程中用来处理可能出现的错误或者已经出现但并不打算应付的错误最通用的方式。比如一个变量你预先想的是接受一个数值，但是用户却输入了一个字符，这个时候你就可以将这段语句包围在try里面；或者有时你在编程的时候就发现了这种情况，只是懒得理会他们，那么简单的把这块出错的语句包围在try里面，然后后面跟个except语句，打印出一个信息“出错了”，即可。用法如下所示：
\begin{tcbpython}
while True:
    x=input('请输入一个数，将返回它除以2之后的数值\n输入"quit"退出\n')
    if x=='quit':
        break
    try :
        num=float(x)
        print(num/2)
    except:
        print('出错了')
\end{tcbpython}






\subsection{in语句}
\begin{Verbatim}
>>> 'a' in ['a',1,2]
True
>>> dict
{'a': 1, 'c': 2, 'b': 3, 'd': 4}
>>> 'e' in dict
False
>>> '2' in dict
False
\end{Verbatim}
从上面例子可以看到，一般的列表判断元素是否存在和我们之前预料的一致，关于字典需要说的就是in语句\uwave{只判断键}，不判断值。






\section{迭代}
一般有内部重复操作的程序可以先考虑for迭代结构实现，实在不行才考虑while循环结构，毕竟简单更美更安全。

python的for迭代语句有点类似lisp语言的dolist和dotimes函数，具体例子如下：
\begin{xverbatim}[129]{py}
for x in 'abc':
    print(x)
\end{xverbatim}
in后面跟的是\textbf{序列}类型，也就是字符串，列表，数组都是可以的。这个语句可以看作先执行x='a'或者类似的匹配赋值操作，然后执行缩进的区块，后面依次类推。（所以for语句也支持序列解包赋值，请参看：\ref{sec:序列解包赋值}）


\subsection{range函数}
range函数是为for迭代语句准备的，有点类似于lisp的dotimes函数，但是功能更全更接近common-lisp的loop宏了。

\verb+range(1,10,2)+\\
range函数的用法如上，表示从1开始到10，步长为2，如果用list函数将其包裹，将会输出[1,3,5,7,9]。如果不考虑步长的话，这个range函数就有点类似于在序列调出多个值那一小节\ref{sec:调出多个值}谈论的区间的情况。所以range(10)就可以看作[0,10)，range(1,10)就可以看作[1,10)。但是在这里再加上步长的概念和区间的概念又有所不同了，range函数产生的是一个什么迭代器对象，目前我只知道这个对象和之前谈论的序列对象是不同的。

\begin{xverbatim}[129]{py}
for x in range(-10,-20,-3):
    print(x)
\end{xverbatim}
上面例子还演示了range的负数概念，这里如果用区间概念来考察的话，是不能理解的，之所以行得通，是因为它的步长是负数，如果不是负数，那么情况就会和之前讨论的结果类似，将是一个空值。


\subsection{迭代加上操作}
迭代产生信息流并经过某些操作之后生成目标序列，更多内容请参见列表解析一节\ref{sec:列表解析}。
\begin{Verbatim}
>>> squares=[x**2 for x in [1,2,3,4,5]]
>>> squares
[1, 4, 9, 16, 25]
\end{Verbatim}




\section{循环}
while语句用法和大多数编程语言类似，就是条件控制，循环结构。
\begin{Verbatim}
while test:
    do something
else :
    do something
\end{Verbatim}

值得一提的是else语句和while语句属于一个整体，通常情况下while执行完了然后执行下面的语句似乎不需要加上else来控制。不过else语句的一个功用就是如果while循环的时候遇到break那么else语句也不会执行而是直接跳过去了，见下面。

\subsection{break命令}
break跳出最近的while或者for循环结构。前面谈到了else和while语句构成一个整体的时候，break可以跳过else语句。

\subsection{continue命令}
continue命令接下来的循环结构的执行区块将不执行了，跳到条件判断那里看看是不是继续循环。如果是，那么继续循环。

值得一提的是for语句也有else分句用法，虽然不常用。同样for语句也支持break命令，也一样跳出else分句。同样for语句也支持continue命令。

\subsection{pass命令}
pass命令就是什么都不做。pass命令即可用于循环语句也可用于条件语句。

pass命令什么都不做似乎没有什么意义，不过作为一个空占位符还是很有用的。比如你编写一个大型的GUI程序，信号－槽机制都构思好了，只是对应的函数暂时还没写好，这个时候你可以将对应的函数，只是空的函数名加上pass语句写上，这样整个程序就可以继续边编写边调试了。




\chapter{程序中的操作对象}
python和c语言不同，c 是什么\verb+int x = 3+ ，也就是这个变量是整数啊，字符啊什么的都要明确指定，python不需要这样做，只需要声明\verb+x ＝ 3+即可。但是我们知道任何程序语言它到最后必然要明确某一个变量（这里也包括后面的更加复杂的各个结构对象）的内存分配，只是python语言帮我们将这些工作做了，所以就让我们省下这份心吧。

\begin{Verbatim}
''' 这是一个多行注释
    你可以在这里写上很多废话
    '''
x = 10
print(x,type(x))
\end{Verbatim}

python程序由各个模块（modules）组成，模块就是各个文件。模块由声明（statements）组成，声明由表达式（expressions）组成，表达式负责创造和操作对象（objects）。在python中一切皆对象。python语言内置对象（数值、字符串、列表、数组、字典、文件、集合、其他内置对象。）后面会详细说明之。


\section{赋值}
python中的赋值语法非常的简单，x=1，就是一个赋值语句了。和c语言不同，c是必须先声明int x之类，开辟一个内存空间，然后才能给这个x赋值。而python的x=1语句实际上至少完成了三个工作：一，判断1的类型（动态类型语言必须要这步）；二，把这个类型的对象存储在内存里面；三，创建x这个名字和这个名字指向这个内存，x似乎可以称之为对应c语言的指针对象。

\subsection{序列赋值}
\begin{Verbatim}
x,y=1,'a'
[z,w]=['b',10]
print(x,y,z,w)
\end{Verbatim}

我们记得python中表达式可以加上圆括号，所以这里\verb+x,y+产生的是一个数组\verb+(x,y)+，然后是对应的数组平行赋值，第二行是列表的平行赋值。这是一个很有用的技巧。

\subsection{同时赋相同的值}
\begin{Verbatim}
x=y='a'
z=w=2
print(x,y,z,w)
\end{Verbatim}
这种语句形式c语言里面也有，不过内部实现机制就非常的不一样了。python当声明x=y的时候，x和y是相同的指针值，然后相同的指针值都指向了'a'这个字符串对象，也可以说x和y就是一个东西，只是取的名字不同罢了。

但如果写成这种形式：
\begin{Verbatim}
x=1
y=1
\end{Verbatim}
那么x和y还是指向的同一个对象，甚至是同一内存区块吗？如果是的话，那我对python内部如何处理的实现了这样的效果很感兴趣了。


\subsection{增强赋值语句}
x=x+y可以写作x += y。类似的还有：
\begin{tabular}{|c|c|c|}
\hline 
+= & \&{}= & >>= \\ 
\hline 
-= & |= & <<= \\ 
\hline 
*= & \^{}= & **= \\ 
\hline 
/= & \%{}= & //= \\ 
\hline 
\end{tabular} 




\section{数值}
python的数值的内置类型有：int，float，complex等\footnote{这些int、float等命令都是强制类型转换命令}。\\python的基本算术运算操作有加减乘除（+ - * /）。然后‘=’表示赋值，类似数学书上的中缀表达式和优先级和括号法则等，这些都是一般编程语言说到烂的东西了。

\begin{Verbatim}
print((1+2)*(10-5)/2)
print(2**100)
\end{Verbatim}

\subsection{二进制八进制十六进制}
二进制的数字以0b（零比）开头，八进制的数字以0o（零哦）开头，十六进制的数字以0x（零艾克斯）开头。
\begin{Verbatim}
0b101010, 0o177, 0x9ff
\end{Verbatim}

以二进制格式查看数字使用bin命令，以十六进制查看数字使用hex命令。
\begin{Verbatim}
>>> bin(42)
'0b101010'
>>> hex(42)
'0x2a'
\end{Verbatim}




\subsection{数学幂方运算}
$ x^y $，x的y次方如上面第二行所述就是用\verb+x**y+这样的形式即可。此外pow函数作用是一样的，\verb+pow(x,y)+。


\subsection{数值比较}
数值比较除了之前提及的>，<，==之外，>=，<=，!=也是有的（大于等于，小于等于，不等于）。此外python还支持连续比较，就是数学格式$a<x<b$，x在区间$(a,b)$的判断。在python中可以直接写成如下形式：\verb+a<x<b+。这实际实现的过程就是两个比较操作的进一步与操作。

\subsection{相除取整}
就作为正整数相除使用\verb+x//y+得到的值意义还是很明显的就是商。带上负号感觉有点怪了，这里先略过。相关的还有取余数，就是\verb+x%y+，这样就得到x除以y之后的余数了，同样带上负号情况有变，这里先略过。



\subsection{复数}
python直接支持复数， 复数的写法是类似\verb|1+2j|这样的形式，然后如果z被赋值了一个复数，这样它就是一个复数类型，那么这个类具有两个属性量，\textbf{real}和\textbf{imag}。也就是使用\verb+z.real+就给出这个复数的实数部。imag是imaginary number的缩写，虚数，想像出来的数。

\subsection{abs函数}
大家都知道abs函数是绝对值函数，这个python自带的，不需要加载什么宏包。作用于复数也是可以的：
\begin{Verbatim}
z=3+4j
print(z.real,z.imag)
print(abs(z))
\end{Verbatim}

这个和数学中复数绝对值的定义完全一致，也就是复数的模：\\
$ \left| z \right| =\sqrt { a^{ 2 }+b^{ 2 } }  $

\subsection{round函数}
简单的理解就是这个函数实现了对数值的四舍五入功能，第二个参数默认是0，即保留零位小数的意思。
\begin{Verbatim}
>>> round(3.1415926,0)
3.0
>>> round(3.1415926,1)
3.1
>>> round(3.1415926,2)
3.14
>>> round(3.1415926,3)
3.142
>>> round(3.1415926,4)
3.1416
>>> round(3.1415926,5)
3.14159
\end{Verbatim}



\subsection{min，max和sum函数}
\label{sec:sum函数}
min，max函数的用法和sum的用法稍微有点差异，简单起见可以认为min，max，sum都接受一个元组或者列表（还有其他？），然后返回这个元组或者列表其中的最小值，最大值或者相加总和。此外min和max还支持min(1,2,3)这样的形式，而sum不支持。
\begin{Verbatim}
>>> min((1,6,8,3,4))
1
>>> max([1,6,8,3,4])
8
>>> sum([1,6,8,3,4])
22
>>> min(1,6,8,3,4)
1
\end{Verbatim}



\subsection{位操作}
python支持位操作的，这里简单说一下：位左移操作<<，位与操作\&{}，位或操作|，位异或操作\^{}。
\begin{Verbatim}
>>> x=0b0001
>>> bin(x << 2)
'0b100'
>>> bin(x | 0b010)
'0b11'
>>> bin(x & 0b1)
'0b1'
>>> bin(x ^ 0b101)
'0b100'
\end{Verbatim}




\subsection{math宏包}
在\verb+from math import *+之后，可以直接用符号pi和e来引用圆周率和自然常数。此外math宏包还提供了很多数学函数，比如：
\begin{description}
\item[sqrt] 开平方根函数，sqrt(x)。
\item[sin] 正弦函数，类似的还有cos，tan等，sin(x)。
\item[degrees] 将弧度转化为角度，三角函数默认输入的是弧度值。
\item[radians] 将角度转化位弧度，radians(30)。 
\item[log] 开对数，log(x,y)，即$\log_y x$，y默认是e。
\item[exp] 指数函数，exp(x)。
\item[pow] 扩展了内置方法，现在支持float了。pow(x,y)
\end{description}

这里简单写个例子：
\begin{Verbatim}
>>> from math import *
>>> print(pi)
3.141592653589793
>>> print(sqrt(85))
9.219544457292887
>>> print(round(sin(radians(30)),1))#sin(30°)
0.5
\end{Verbatim}


更多具体细节请参看\href{http://docs.python.org/3.4/library/math.html}{官方文档}。




\subsection{random宏包}
random宏包提供了一些函数来解决随机数问题。%内容待充实
\begin{description}
\item[random] random函数产生0到1之间的随机实数（包括0）
\item[uniform] uniform函数产生从a到b之间的随机实数（a，b的值指定，包括a。）
\item[randrange] randrange函数产生从a到b之间的随机整数，步长为c（a，b，c的值指定，相当于choice(range(start,stop,step))，range(0,5)是从0到4不包括5，所以这里是从a到b不包括b。）
\item[choice] choice随机从一个列表或者字符串中取出一个元素。
\end{description}

下面是一个简单的例子：
\begin{xverbatim}[129]{py}
from random import *
print(random())
print(uniform(1,10))
print(randrange(1,6))
print(choice('abcdefghij'))
print(choice(['①','②','③']))
\end{xverbatim}

更多详细细节请参阅\href{http://docs.python.org/3.4/library/random.html}{官方帮助文档}。











\section{序列}
字符串，列表，元组（tuple，这里最好翻译成元组，因为里面的内容不一定是数值。）都是序列（sequence）的子类，所以序列的一些性质他们都具有，最好在这里一起讲方便理解记忆。

\subsection{len函数}
len函数返回序列所含元素的个数：
\begin{xverbatim}[129]{py}
string001='string'
list001=['a','b','c']
tuple001=(1,2,3,4)

for x in [string001,list001,tuple001]:
    print(len(x))
\end{xverbatim}


\subsection{调出某个值}
对于序列来说后面跟个方括号，然后加上序号（程序界的老规矩，从0开始计数。），那么调出对应位置的那个值。还以上面那个例子来说明。
\begin{xverbatim}[129]{py}
string001='string'
list001=['a','b','c']
tuple001=(1,2,3,4)

for x in [string001,list001,tuple001]:
    print(x[2])
\end{xverbatim}

\subsubsection{倒着来}
倒着来计数-1表示倒数第一个，-2表示倒数第二个。依次类推。
\begin{xverbatim}[129]{py}
string001='string'
list001=['a','b','c']
tuple001=(1,2,3,4)

for x in [string001,list001,tuple001]:
    print(x[-1],x[-2])
\end{xverbatim}

\subsection{调出多个值}
\label{sec:调出多个值}
前面不写表示从头开始，后面不写表示到达尾部。中间加个冒号的形式表示从那里到那里。这里\textbf{注意}后面那个元素是\uwave{不包括}进来，看来python区间的默认含义都是包头不包尾。这样如果你想要最后一个元素也进去，只有使用默认的不写形式了。
\begin{xverbatim}[129]{py}
string001='string'
list001=['a','b','c']
tuple001=(1,2,3,4)

for x in [string001,list001,tuple001]:
    print(x[1:3],x[-2:-1],x[:-1],x[1:],x[1:-1])
\end{xverbatim}
用数学半开半闭区间的定义来理解这里的包含关系还是很便捷的。
\begin{enumerate}
\item 首先是数学半开半闭区间，左元素和右元素都是之前叙述的对应的定位点。左元素包含右元素不包含。
\item 其次方向应该是从左到右，如果定义的区间是从右到左，那么将产生空值。
\item 如果区间超过，那么从左到右包含的所有元素就是结果。
\item 最后如果左右元素定位点相同，那么将产生空值，比如：\\
\verb+string001[2:-4]+，其中2和-4实际上是定位在同一个元素之上的。额外值得一提的列表插入操作，请参看列表的插入操作这一小节。\ref{sec:列表插入操作}
\end{enumerate}


\subsection{序列反转}
这是python最令人叹为观止的地方了，其他的语言可能对列表啊什么的反转要编写一个复杂的函数，我们python有一种令人感动的方法。

\begin{xverbatim}[129]{py}
string001='string'
list001=['a','b','c']
tuple001=(1,2,3,4)

for x in [string001,list001,tuple001]:
    print(x[::-1])
\end{xverbatim}

之前在range函数的介绍时提及序列的索引和range函数的参数设置很是类似，这是我们可以参考理解之，序列（列表，字符串等）的索引参数[start:end:step]和range函数的参数设置一样，第一个参数是起步值，第二个参数是结束值，第三个参数是步长。

然后range函数生成的迭代器对象同样接受这种索引参数语法，看上去更加的怪异了：
\begin{Verbatim}
>>> range(1,10,2)
range(1, 10, 2)
>>> range(1,10,2)[::-2]
range(9, -1, -4)

>>> list(range(1,10,2))
[1, 3, 5, 7, 9]
>>> list(range(1,10,2)[::-2])
[9, 5, 1]
\end{Verbatim}
我们可以看到对range函数进行切片操作之后返回的仍然是一个range对象，经过了一些修正。似乎这种切片操作和类的某个特殊方法有关，和python的slice对象有关。更进一步的讨论参见......



\subsection{序列的可更改性}
字符串不可以直接更改，但可以组合成为新的字符串；列表可以直接更改；元组不可以直接更改。



\subsection{序列的加法和减法}
两个字符串相加就是字符串拼接了。乘法就是加法的重复，所以一个字符串乘以一个数字就是自己和自己拼接了几次。列表还有元组和字符串一样大致情况类似。

\begin{xverbatim}[129]{py}
print('abc'+'def')
print('abc'*3)
print([1,2,3]+[4,5,6])
print((0,'a')*2)
\end{xverbatim}



\section{字符串}
python语言不像c语言字符和字符串是不分的，用单引号或者双引号包起来就表示一个字符串了。单引号和双引号的区别是一般用单引号，如果字符串里面有单引号，那么就使用双引号，这样单引号直接作为字符处理而不需要而外的转义处理——所谓转义处理和其他很多编程语言一样用\textbackslash 符号。比如要显示\verb+'+就输入\verb+\'+。

\subsection{三单引号和三双引号}
在单引号或者双引号的情况下，你可以使用\verb+\n+来换行，其中\textbackslash n表示换行。此外还可以使用三单引号'''或者三双引号"""来包围横跨多行的字符串，其中换行的意义就是换行，不需要似前面那样的处理。

\begin{Verbatim}
print('''\
这是一段测试文字
  this is a test line
      其中空白和    换行都所见所得式的保留。''')
\end{Verbatim}

\subsection{find方法}
字符串的find方法可用来查找某个子字符串，没有找到返回-1，找到了返回字符串的偏移量。用法就是：\verb+s.find('d')+。


\subsection{replace方法}
字符串的replace方法进行替换操作，接受两个参数：第一个参数是待匹配的子字符串，第二个参数是要替换成为的样子。
\begin{Verbatim}
>>> print('a b 11 de'.replace('de','ding'))
a b 11 ding
>>> print('1,1,5,4,1,6'.replace('1','replaced'))
replaced,replaced,5,4,replaced,6
\end{Verbatim}




\subsection{upper方法}
将字符串转换成大写形式。
\begin{Verbatim}
>>> str='str'
>>> str.upper()
'STR'
\end{Verbatim}


\subsection{isdigit方法}
类似的还有isalpha方法，测试是不是数字或字母。值得注意的是就算是字母组成的语句，中间有空间也会返回False。

\subsection{split方法}
字符串的split方法可以将字符串比如有空格或者逗号等分隔符分割而成，可以将其分割成子字符串列表。默认是空格是分隔符。

\subsection{join方法}
字符串的join方法非常有用，严格来说它接受一个迭代器参数，不过最常见的是列表，如下所示：
\begin{Verbatim}
>>> list001=['a','b','c']
>>> "".join(list001)
'abc'
\end{Verbatim}



\subsection{rstrip方法}
字符串右边的空格都删除。换行符也会被删除掉。

\subsection{format方法}
字符串的format方法方便对字符串内的一些变量进行替换操作，其中花括号不带数字跟format方法里面所有的替换量，带数字0表示第一个替换量，后面类推。
\begin{Verbatim}
print('1+1={0}，2+2={1}'.format(1+1,2+2))
\end{Verbatim}

\subsection{转义和不转义}
\verb+\n    \t  +这是一般常用的转义字符，换行和制表。此外还有\verb+\\+输出\textbackslash 符号。

如果输出字符串不想转义那么使用如下格式：
\begin{Verbatim}
>>> print(r'\t \n \test')
\t \n \test
\end{Verbatim}





\section{列表}
方括号包含几个元素就是列表。


\subsection{列表的插入操作}
\label{sec:列表插入操作}
字符串和数组都不可以直接更改所以不存在这个问题，列表可以。其中列表还可以以一种定位在相同元素的区间的方法来实现插入操作，这个和之前理解的区间多少有点违和，不过考虑到定位在相同元素的区间本来就概念模糊，所以在这里就看作特例，视作在这个\uwave{定位点相同元素之前}插入吧。
\begin{xverbatim}[129]{py}
list001=['one','two','three']
list001[1:-2]=['four','five']
print(list001)
\end{xverbatim}

除了序列中的一些继承的操作之外，列表还有很多方法，实际上这还算少的（如果你见识了lisp中各种列表操作）。因为列表这个数据结构可以直接修改相当灵活，下面我打算将我学lisp语言中接触到的一些列表操作对应过来一一说明之：

extend方法似乎和列表之间的加法重合了，比如\\list001.extend([4,5,6])就和list001=list001+[4,5,6]是一致的，而且用加法表示还可以自由选择是不是覆盖原定义，这实际上更加自由。所以extend方法略过。

insert方法也就是列表的插入操作，这个前面关于列表的插入实现方法说过一种了，所以insert方法也略过。

\subsection{append方法}
python的append方法和lisp中的append还是有点差异的，python的append就是在最后面加\textbf{一个元素}，如果你append一个列表那么这一个列表整体作为一个元素。lisp的append函数和python的extend方法类似，接受一个列表。

其次append是list类中的一个方法，也就是list001.append这样的形式，也就是永久的改变了某个列表实例的值了。



\subsection{reverse方法}
reverse方法不接受任何参数，直接将一个列表永久性地翻转过来。

\subsection{sort方法}
也就是排序，永久性改变列表。默认是递增排序，可以用\textbf{reverse=True}来调成递减排序。可以用\textbf{key=function}来设置排序的函数，这个排序函数是单参数函数。

类似的有sorted函数，不同的sorted函数返回的是一个新的列表而不是原处修改。



\subsection{删除某个元素}
\begin{itemize}
\item 赋空列表值，相当于所有元素都删除了。 
\item pop方法：接受一个参数，就是列表元素的定位值，然后那个元素就删除了，方法并返回那个元素的值。如果不接受参数默认是删除最后一个元素。
\item remove方法：移除第一个相同的元素，如果没有返回相同的元素，返回错误。
\item del函数：删除列表中的某个元素。
\end{itemize}

\begin{Verbatim}
>>> list001=['a','b','c','d','e']
>>> list001.pop(2)
'c'
>>> list001
['a', 'b', 'd', 'e']
>>> list001.pop()
'e'
>>> list001
['a', 'b', 'd']
>>> list001.remove('a')
>>> list001
['b', 'd']
>>> del list001[1]
>>> list001
['b']
\end{Verbatim}




\subsection{index方法}
index方法返回某个相同元素的偏移值。
\begin{Verbatim}
>>> list001=[1,'a',100]
>>> list001.index('a')
1
\end{Verbatim}

\subsection{列表元素去重}
我写了一个列表元素去重的函数，读者可以体会一下，其中涉及到递归思想\ref{sec:递归函式}，就是很直白的我很懒惰，我把一个重复元素删除了，我就把作业上交给主管了，我说我的那部分工作干完了，其他的你接着干吧。
\begin{xverbatim}[129]{py}
def removeduplicate(list):
    newlist = list.copy()
    for j in newlist:
        for index in range(newlist.index(j)+1,len(newlist)-1):
            if j == newlist[index]:
                del newlist[index]
                return removeduplicate(newlist)
    return newlist

list001=[1,2,3,1,2,4,4,5,5,5,7]
print(removeduplicate(list001))
\end{xverbatim}
  


\subsection{列表元素的替换}
lisp语言中有subst函数，是substitute的缩写。作用于整个列表，列表中所有出现的某个元素都要被另一个元素替换掉。

由于我现在对如何修改python语言内置类还毫无头绪，只好简单写这么一个函数了。
\begin{xverbatim}[129]{py}
def subst(list001,element001,element002):
    try:
        list001.index(element001)
    except ValueError:
        return list001
    else:
        n=list001.index(element001)
        del list001[n]
        list001[n:n]=[element002]
        return subst(list001,element001,element002)

print(subst([1,'a',3,[4,5]],[4,5],'b'))
print(subst([1,1,5,4,1,6],1,'replaced'))
\end{xverbatim}
这个subst函数接受三个参数，表示接受的列表，要替换的元素和替换成为的元素。这里使用的程序结构是try...except...else...语句。其中try来侦测是不是有错误，其中index方法是看那个要替换的元素存不存在，由于不存在这个函数将产生一个\textbf{ValueError}错误，所以用except来接著。既然没有要替换的元素了，那么返回原列表即可，程序中止。

else语句接著没有错误的时候你要执行的操作，先index再删掉这个元素，再在之前插入那个元素，然后使用了递归算法，调用函数自身。

\subsection{列表解析}
\label{sec:列表解析}
lisp中的mapcar函数有这个功用，python中的map函数基本上和它情况类似。

我们先来看lisp中的情况：
\begin{xverbatim}[129]{lisp}
(defun square (n) (* n n))
(format t "~&~s" (mapcar #'square '(1 2 3 4 5)) )
\end{xverbatim}

再来看python中的情况：
\begin{xverbatim}[129]{py}
def square(n):
    return n*n
    
print(list(map(square,[1,2,3,4,5])))
print([square(x) for x in [1,2,3,4,5]])
\end{xverbatim}
map函数将某个应数应用于某个列表的元素中并生成一个map对象，需要外面加上list函数才能生成列表形式。第二种方式更有python风格，是推荐使用的列表解析方法。

在python中推荐多使用迭代操作和如上的列表解析风格，因为python中的迭代操作是直接用c语言实现的。

\subsubsection{列表解析加上过滤条件}
for语句后面可以跟一个if子句表示过滤条件，看下面的例子来理解吧：
\begin{Verbatim}
>>> [s*2 for s in ['hello','abc','final','help'] if s[0] == 'h']
['hellohello', 'helphelp']
\end{Verbatim}

这个例子的意思是列表解析，找到的元素进行乘以2的操作，其中过滤条件为字符是h字母开头的，也就是后面if表达式不为真的元素都被过滤掉了。

\subsubsection{排列组合赋值}
我想到列表解释的时候如果解析加赋值会如何呢？当然如果同一个变量逐个赋值这毫无意义，但如果我们将其变成一个字符串，从而形成一种延迟赋值语句这又会如何呢？
\begin{Verbatim}
>>> ["x,y={0},{1};".format(a,b) for a in [1,2,3] for b in [4,5]]
['x,y=1,4;', 'x,y=1,5;', 'x,y=2,4;', 'x,y=2,5;', 'x,y=3,4;', 'x,y=3,5;']
>>> exec(["x,y={0},{1};".format(a,b) for a in [1,2,3] for b in [4,5]][0])
>>> print(x,y)
1 4
>>> exec(["x,y={0},{1};".format(a,b) for a in [[1,2],2,3] for b in [4,5]][0])
>>> x
[1, 2]
\end{Verbatim}
我们看到通过exec来执行之后x和y都赋给了相应的值，这似乎有点意思，因为我们可以通过itertools（排列组合等等技术）来形成一种批量赋值和进行某些操作的机制。

然后我们看到将赋值改为列表也是可行的，这样我们可以猜测一般对象赋值都是可行的。

但是字符串赋值就出现问题了：
\begin{Verbatim}
>>> ["x,y={0},{1};".format(a,b) for a in ['a',2,3] for b in [4,5]]
['x,y=a,4;', 'x,y=a,5;', 'x,y=2,4;', 'x,y=2,5;', 'x,y=3,4;', 'x,y=3,5;']
\end{Verbatim}
我们可以看到a进入之后就成了变量名了，然后exec执行就会出错。如果你给a赋一个值，这样就不会出错了。（可能会有某种手段处理来实现字符串的赋值？）

不过这里我们看到另外一种有趣的现象，那就是我们可以通过字符串组合来生成新的变量名。
\begin{Verbatim}
 exec(["x={0};".format(str(a)+str(b)) for a in ['x'] for b in [0,1,2]][0])
\end{Verbatim}
比如如下面这样就将执行\verb+x=x0+这样的表达式，因为x0没有定义将会出错。


\subsubsection{批量赋值}
下面是一个批量赋值函数的粗糙例子，作为自动生成一些变量名和批量赋值这些变量名似乎没有什么用处，不过也许以后可能对于某些问题会有用处的，先暂时放在这里。
\begin{Verbatim}
def multiassign(n):
    for i in ["global {0};{0} = {1};".format(str(a)+str(b),i) 
    for a in ['x'] for (b,i) in [(i,i) for i in list(range(n))]]:
        exec(i)

if __name__ == '__main__':
    multiassign(100)
\end{Verbatim}




\subsection{count方法}
统计某个元素出现的次数。
\begin{Verbatim}
>>> list001=[1,'a',100,1,1,1]
>>> list001.count(1)
4
\end{Verbatim}




\section{字典}
与列表一样字典是可变的，可以像列表一样引用然后原处修改，del语句也适用。

\subsection{创建字典}
字典是一种映射，并没有从左到右的顺序，只是简单地将键映射到值。字典的声明格式如下：
\begin{Verbatim}
dict001={'name':'tom','height':'180','color':'red'}
dict001['name']
\end{Verbatim}

或者创建一个空字典，然后一边赋值一边创建对应的键：
\begin{Verbatim}
dict002={}
dict002['name']='bob'
dict002['height']=195
\end{Verbatim}

所以对字典内不存在的键赋值是可行的。




\subsection{字典里面有字典}
和列表的不同就在于字典的索引方式是根据“键”来的。
\begin{Verbatim}
dict003={'name':{'first':'bob','second':'smith'}}
dict003['name']['first']
\end{Verbatim}

\subsection{字典遍历操作}
字典特定顺序的遍历操作的通用做法就是通过字典的keys方法收集键的列表，然后用列表的sort方法处理之后用for语句遍历，如下所示：
\begin{Verbatim}
dict={'a':1,'c':2,'b':3}
dictkeys=list(dict.keys())
dictkeys.sort()
for key in dictkeys:
    print(key,'->',dict[key])
\end{Verbatim}

如果你对字典遍历的顺序没有要求，那么就可以简单的这样处理：
\begin{Verbatim}
>>> for key in dict:
...     print(key,'->',dict[key])
... 
c -> 2
a -> 1
b -> 3
\end{Verbatim}

\subsubsection{keys方法}
收集键值。

\subsubsection{values方法}
和keys方法类似，收集的值。
\begin{Verbatim}
>>> dict001.values()
dict_values([3, 1, 2])
>>> list(dict001.values())
[3, 1, 2]
\end{Verbatim}

\subsubsection{items方法}
和keys和values方法类似，不同的是返回的是(key,value)对。
\begin{Verbatim}
>>> dict001.items()
dict_items([('c', 3), ('a', 1), ('b', 2)])
>>> list(dict001.items())
[('c', 3), ('a', 1), ('b', 2)]
\end{Verbatim}

\subsection{sorted函数}
sorted方法可以对字典直接排序，返回的是该字典键值的列表。
\begin{Verbatim}
dict={'a':1,'c':2,'b':3}
for key in sorted(dict):
    print(key,'->',dict[key])
\end{Verbatim}


\subsubsection{reverse选项}
reverse=True  排序反转。







\subsection{字典的in语句}
可以看到in语句只针对字典的键，不针对字典的值。
\begin{Verbatim}
>>> dict001={'a':1,'b':2,'c':3}
>>> 2 in dict001
False
>>> 'b' in dict001
True
\end{Verbatim}

\subsection{字典对象的get方法}
get方法是去找某个键的值，为什么不直接引用呢，get方法的好处就是某个键不存在也不会出错。
\begin{Verbatim}
>>> dict001={'a':1,'b':2,'c':3}
>>> dict001.get('b')
2
>>> dict001.get('e')
\end{Verbatim}

\subsection{update方法}
感觉字典就是一个小型数据库，update方法将另外一个字典里面的键和值覆盖进之前的字典中去，称之为更新，没有的加上，有的覆盖。
\begin{Verbatim}
>>> dict001={'a':1,'b':2,'c':3}
>>> dict002={'e':4,'a':5}
>>> dict001.update(dict002)
>>> dict001
{'c': 3, 'a': 5, 'e': 4, 'b': 2}
\end{Verbatim}

\subsection{pop方法}
pop方法类似列表的pop方法，不同引用的是键，而不是偏移地址，这个就不多说了。



\subsection{字典解析}
这种字典解析方式还是很好理解的。
\begin{Verbatim}
>>> dict001={x:x**2 for x in [1,2,3,4]}
>>> dict001
{1: 1, 2: 4, 3: 9, 4: 16}
\end{Verbatim}

\subsubsection{zip函数创建字典}
可以利用zip函数来通过两个列表平行合成一个字典，这个有时很有用。zip函数刚开始返回的是什么zip对象，然后对其进行字典解析。
\begin{Verbatim}
>>> dict001=zip(['a','b','c'],[1,2,3])
>>> dict001
<zip object at 0xb6b464ac>
>>> dict001={a:b for (a,b) in dict001}
>>> dict001
{'c': 3, 'a': 1, 'b': 2}
\end{Verbatim}

这种解析方式的理解有一定难度，主要是zip函数这里比较抽象了。而下面这段代码是\emph{python2}的，就比较好理解一点。所以要理解python3的那种语法，只好认为python3中的zip对象只是还未展开的如下所示结构的那种列表。值得一提的在python3中\uwave{dict强制变换不能使用}了。
\begin{Verbatim}
>>> zip(['a','b','c'],[1,2,3])
[('a', 1), ('b', 2), ('c', 3)]
>>> dict001=dict(zip(['a','b','c'],[1,2,3]))
>>> dict001
{'a': 1, 'c': 3, 'b': 2}
\end{Verbatim}


\subsection{字典的集合操作}
python3的字典更多的接近集合了，它现在支持很多集合操作，比如-，\&{}，|等。字典的集合操作是以键参与集合操作的。


\section{集合}
集合可以用过可以通过set函数创建一个集合对象，集合的元素是无序的，数学上类似的集合操作这里都有：
\begin{Verbatim}
>>> set001=set('hello')
>>> set001
set(['h', 'e', 'l', 'o'])
>>> set002={'h','a','b'}
>>> set002
set(['a', 'h', 'b'])
>>> print(set001)
set(['h', 'e', 'l', 'o'])
>>> set001 & set002
set(['h'])
>>> set001 | set002
set(['a', 'b', 'e', 'h', 'l', 'o'])
>>> set001 - set002
set(['e', 'l', 'o'])
>>> {x**2 for x in [1,2,3,4,5]}
set([16, 1, 4, 25, 9])
\end{Verbatim}

其中\verb+&  |  -+就是交，与，差的意思。




\section{元组}
圆括号包含几个元素就是元组(tuple)。元组和列表的不同在于元组是不可改变。元组也是从属于序列对象的，元组的很多方法之前都讲了。而且元组在使用上和列表极其接近，有很多内容这里也略过了。

值得一提的是如果输入的时候写的是\textit{x,y}这样的形式，实际上表达式就加上括号了，也就是一个元组了\textit{(x,y)}。




\section{文件}

\subsection{写文件}
对文件的操作首先需要用open函数创建一个文件对象，简单的理解就是把相应的接口搭接好。文件对象的write方法进行对某个文件的写操作，最后需要调用close方法写的内容才真的写进去了。

\begin{Verbatim}
file001 = open('test.txt','w')
file001.write('hello world1\n')
file001.write('hello world2\n')
file001.close()
\end{Verbatim}

如果你们了解C语言的文件操作，在这里会为python语言的简单便捷赞叹不已。就是这样三句话：创建一个文件对象，然后调用这个文件对象的wirte方法写入一些内容，然后用close方法关闭这个文件即可。


\subsection{读文件}
一般的用法就是用open函数创建一个文件对象，然后用read方法调用文件的内容。最后记得用close关闭文件。
\begin{Verbatim}
file001 = open('test.txt')
filetext=file001.read()
print(filetext)
file001.close()
\end{Verbatim}

此外还有readline方法是一行一行的读取某文件的内容。


\subsection{open函数的处理模式}
open函数的处理模式如下：
\begin{description}
\item['r'] 默认值，read，读文件。
\item['w'] wirte，写文件，如果文件不存在会创建文件，如果文件已存在，文件原内容会清空。
\item['a'] append，附加内容，也就是后面用write方法内容会附加在原文件之后。
\item['b'] 处理模式设置的\uwave{附加}选项，'b'不能单独存在，要和上面三个基本模式进行组合，比如'rb'等，意思是二进制数据格式读。
\item['+'] 处理模式设置的\uwave{附加}选项，同样'+'不能单独存在，要和上面三个基本模式进行组合，比如'r+'等，+是updating更新的意思，也就是既可以读也可以写，那么'r+'，'w+'，'a+'还有什么区别呢？区别就是'r+'不具有文件创建功能，如果文件不存在会报错，然后'r+'不会清空文件，如果'r+'不清空文件用write方法情况会有点复杂；而'w+'具有文件创建功能，然后'w+'的write方法内容都是重新开始的；而'a+'的write方法内容是附加在原文件上的，然后'a+'也有文件创建功能。
\end{description}



\subsection{用with语句打开文件}
类似之前的例子我们可以用with语句来打开文件，这样就不用close方法来关闭文件了。然后with语句来提供了类似try语句的功能可以自动应对打开文件时的一些异常情况。
\begin{Verbatim}
with open('test.txt','w') as file001:
    file001.write('hello world1\n')
    file001.write('hello world2\n')

with open('test.txt','r') as file001:
    filetext=file001.read()
    print(filetext)
\end{Verbatim}




\subsection{除字符串外其他类型的读取}
文本里面存放的都是字符串类型，也就是写入文件需要用str函数强行将其他类型转变成字符串类型，而读取进来想要进行一些操作则需要将字符串类型转变回去。比如用int或者float等，不过列表和字典的转变则需要eval函数。

eval这个函数严格来讲作用倒不是为了进行上面说的类型转换的，它就是一个内置函数，一个字符串类型python代码用eval函数处理了之后就能转变为可执行代码。
\begin{Verbatim}
>>> eval('1+1')
2
>>> eval('[1,2,3]')
[1, 2, 3]
>>> eval("{'a':1,'b':2,'c':3}")
{'c': 3, 'b': 2, 'a': 1}
\end{Verbatim}

推荐使用pickle宏包来处理其他类型的文件读写问题，相对来说更简单更安全。请参看pickle宏包这一小节\ref{sec:pickle宏包}。





\section{总结}


\chapter{类}
类相当于自己创造一个自己的操作对象。一般面向对象(OOP)编程的基本概念这里不重复说明了，如有不明请读者自己随便搜索一篇网页阅读下即可。

\section{python中类的结构}
python中的类就好像树叶，所有的类就构成了一棵树，而python中超类，子类，实例的重载或继承关系等就是由一种搜索机制实现的：
\begin{fig}{类搜索结构图}
\label{fig:类搜索结构图}
\end{fig}
python首先搜索self有没有这个属性或者方法，如果没有，就向上搜索。比如说实例l1没有，就向上搜索C1，C1没有就向上搜索C2或C3等。

实例继承了创造他的类的属性，创造他的类上面可能还有更上层的超类，类似的概念还有子类，表示这个 类在树形层次中比较低。

well，简单来说类的结构和搜索机制就是这样的，很好地模拟了真实世界知识的树形层次结构。

上面那副图实际编写的代码如下：
\begin{Verbatim}
class C2: ...
class C3: ...
class C1(C2,C3): ...
l1=C1()
l2=C1()
\end{Verbatim}
其中class语句是创造类，而C1继承自C2和C3，这是多重继承，从左到右是内部的搜索顺序（会影响重载）。l1和l2是根据类C1创造的两个实例。

对于初次接触类这个概念的读者并不指望他们马上就弄懂类这个概念，这个概念倒并一定要涉及很多哲学的纯思考的东西，也可以看作一种编程经验或技术的总结。多接触也许对类的学习更重要，而不是纯哲学抽象概念的讨论，毕竟类这个东西创造出来就是为了更好地描述现实世界的。

最后别人编写的很多宏包就是一堆类，你就是要根据这些类来根据自己的情况情况编写自己的子类，为了更好地利用前人的成果，或者你的成果更好地让别人快速使用和上手，那么你需要好好掌握类这个工具。

\section{类的最基础知识}
\subsection{类的创建}
\begin{Verbatim}
class MyClass:
    something
\end{Verbatim}
类的创建语法如上所示，然后你需要想一个好一点的类名。类名规范的写法是首字母大写，这样好和其他变量有所区分。

\subsection{根据类创建实例}
按照如下语句格式就根据MyClass类创建了一个实例myclass001。
\begin{Verbatim}
myclass001=MyClass()
\end{Verbatim}

\subsection{类的属性}
\begin{Verbatim}
>>> class MyClass:
...  name='myclass'
... 
>>> myclass001=MyClass()
>>> myclass001.name
'myclass'
>>> MyClass.name
'myclass'
>>> myclass001.name='myclass001'
>>> myclass001.name
'myclass001'
>>> MyClass.name
'myclass'
\end{Verbatim}
如上代码所示，我们首先创建了一个类，这个类加上了一个name属性，然后创建了一个实例myclass001，然后这个实例和这个类都有了name属性。然后我们通过实例加上点加上name的这种格式引用了这个实例的name属性，并将其值做了修改。

这个例子简单演示了类的创建，属性添加，实例创建，多态等核心概念。后面类的继承等概念都和这些大同小异了。


\subsection{类的方法}
类的方法就是类似上面类的属性一样加上def语句来定义一个函数，只是函数在类里面我们一般称之为方法。这里演示一个例子，读者看一下就明白了。
\begin{Verbatim}
>>> class MyClass:
...  name='myclass'
...  def double(self):
...   self.name=self.name*2
...   print(self.name)
... 
>>> myclass001=MyClass()
>>> myclass001.name
'myclass'
>>> myclass001.double()
myclassmyclass
>>> myclass001.name
'myclassmyclass'
\end{Verbatim}

这里需要说明的是在类的定义结构里面，self代表着类自身，self.name代表着对自身name属性的引用。然后实例在调用自身的这个方法时用的是myclass001.double()这样的结构，这里double函数实际上接受的第一个参数就是自身，也就是myclass001，而不是无参数函数。所以类里面的方法（被外部引用的话）至少有一个参数self。





\section{类的继承}
实例虽然说是根据类创建出来的，但实际上实例和类也是一种继承关系，实例继承自类，而类和类的继承关系也与之类似，只是语法稍有不同。下面我们来看这个例子：
\begin{xverbatim}[129]{py}
class Hero():
    def addlevel(self):
        self.level=self.level+1
        self.hp=self.hp+self.addhp

class Garen(Hero):
    level=1
    hp=455
    addhp=96

garen001=Garen()
for i in range(6):
    print('级别:',garen001.level,'生命值：' ,garen001.hp)
    garen001.addlevel()
\end{xverbatim}

\begin{fig}[0.5]{类的继承示例}
\caption{类的继承示例}
\label{fig:类的继承示例}
\end{fig}

这里就简单的两个类，盖伦Garen类是继承自Hero类的，实例garen001是继承自Garen类的，这样garen001也有了addlevel方法，就是将自己的level属性加一，同时hp生命值也加上一定的值，整个过程还是很直观的。

\subsection{super}
\begin{flushright}
\begin{notecard}[red!30]{16em}
警报：这一小节super涉及到的知识稍微有点高深，请类大体基本知识都熟悉之后再来看这个。 
\end{notecard}
\end{flushright}

super是python3新加入的特性，按照官方文档，有两种用法：

第一种是如果是单继承的类的系统，super()这种形式就直接表示父类的意思。然后用super.什么什么的来引用父类的某个变量或方法，值得一提的是原父类的self参量会默认加进去了，详细请看下面的调试例子。

第二种是多重继承的，搜索顺序和多重继承的搜索顺序相同，也就是从左到右。请注意调试下面的例子，如果调用c.d就会返回错误，说明调用的是类A的构造函数。

\begin{xverbatim}[129]{py}

class A():
    def __init__(self,a):
        self.a=a

    @staticmethod
    def fun():
        print('fun')

    def fun2(self,what):
        print('fun',what)

class B():
    def __init__(self):
        self.d=5
    b=2
    def fun3(self):
        print('fun3')

class C(A,B):
    def __init__(self):
        super().__init__(3)
        super().fun()
        super().fun2('what')
        super().fun3()
        print(super().b)

c=C()
print(c.a,c.b)
\end{xverbatim}
fun的输出没有产生错误是因为让其成了静态函数，所以可以以fun这样的空参数形式调用。其中的self参数不会干扰它。但是通常情况下不是静态函数的话，写的函数通常就要加上self，而super()这种调用形式默认第一个参数就是self。

fun3也能被调用是因为多重继承的机制在这里，所以它会逐个找父类。然后c.d会出错，因为这里初始化是用的A类的构造函数。


\section{类的内置方法}
如果构建一个类，就使用pass语句，什么都不做，python还是会为这个类自动创建一些属性或者方法。
\begin{Verbatim}
>>> class TestClass:
...  pass
... 
>>> dir(TestClass)
['__class__', '__delattr__', '__dict__', '__dir__', '__doc__',
 '__eq__', '__format__', '__ge__', '__getattribute__',
  '__gt__',  '__hash__', '__init__', '__le__', '__lt__',
   '__module__', '__ne__', '__new__', '__reduce__', 
   '__reduce_ex__', '__repr__', '__setattr__', 
   '__sizeof__', '__str__', '__subclasshook__',
    '__weakref__']
\end{Verbatim}

这些变量名字前后都加上双下划线是给python这个语言的设计者用的，一般应用程序开发者还是不要这么做。

这些内置方法用户同样也是可以重定义他们从来覆盖掉原来的定义，其中特别值得一讲的就是\verb+__init__+方法或者称之为构造函数。

\subsection{\_\_init\_\_{}方法}
\verb+__init__+方法对应的就是该类创建实例的时候的构造函数。比如：
\begin{Verbatim}
>>> class Point:
...  def __init__(self,x,y):
...   self.x=x
...   self.y=y
... 
>>> point001=Point(5,4)
>>> point001.x
5
>>> point001.y
4
\end{Verbatim}
这个例子重载了\verb+__init__+函数，然后让他接受三个参数，self等下要创建的实例，x，还有y通过下面的语句给这个待创建的实例的属性x和y赋了值。


\subsection{self意味着什么}
self在类中是一个很重要的概念，当类的结构层次较简单时还容易看出来， 当类的层次结构很复杂之后，你可能会弄糊涂。\uwave{self就是指现在引用的这个实例}。比如你现在通过调用某个实例的某个方法，这个方法可能是一个远在天边的某个类给出的定义，就算如此，那个定义里面的self还是指调用这个方法的那个实例，这一点要牢记于心。


\subsection{类的操作第二版}
现在我们可以写出和之前那个版本相比更加专业的类的使用版本了。
\begin{xverbatim}[129]{py}
class Hero():
    def addlevel(self):
        self.level=self.level+1
        self.hp=self.hp+self.addhp

class Garen(Hero):
    def __init__(self):
        self.level=1
        self.hp=455
        self.addhp=96
        self.skill=['不屈','致命打击','勇气','审判','德玛西亚正义']

garen001=Garen()
for i in range(6):
    print('级别:',garen001.level,'生命值：' ,garen001.hp)
    garen001.addlevel()
print('盖伦的技能有：',"".join([x + '  ' for x in garen001.skill]))
\end{xverbatim}

似乎专业的做法类里面多放点方法，最好不要放属性，不太清楚是什么。但确实这样写给人感觉更干净点，方法是方法，如果没有调用代码就放在那里我们不用管它，后面用了构造函数我们就去查看相关类的构造方法，这样很省精力。


\section{类的操作第三版}
\label{sec:类的操作第三版}
\begin{xverbatim}[129]{py}
class Unit():
    def __init__(self,hp,atk,color):
        self.hp=hp
        self.atk=atk
        self.color=color
    def __str__(self):
        return '生命值：{0}，攻击力：{1}，颜色：\
        {2}'.format(self.hp,self.atk,self.color)

class Hero(Unit):
    def __init__(self,level,hp,atk,color):
        Unit.__init__(self,hp,atk,color)
        self.level=level
    def __str__(self):
        return '级别：{0},生命值：{1}，攻击力：{2}，\
        颜色：{3}'.format(self.level,self.hp,self.atk,self.color)

    def addlevel(self):
        self.level=self.level+1
        self.hp=self.hp+self.addhp
        self.atk=self.atk+self.addatk

class Garen(Hero):
    def __init__(self,color='blue'):
        Hero.__init__(self,1,455,56,color)
        self.name='盖伦'
        self.addhp=96
        self.addatk=3.5
        self.skill=['不屈','致命打击','勇气','审判','德玛西亚正义']

if __name__ == '__main__':
    garen001=Garen('red')
    garen002=Garen()
    print(garen001)
    unit001=Unit(1000,1000,'gray')
    print(unit001)
    for i in range(6):
        print(garen001)
        garen001.addlevel()
    print('盖伦的技能有：',"".join([x + '  ' for x in garen001.skill]))
\end{xverbatim}
现在就这个例子相对于第二版所作的改动，也就是核心知识点说明之。其中函数参量列表中这样表述\verb+color='blue'+表示blue是color变量的备选值，也就是color成了可选参量了。


\subsection{构造函数的继承和重载}
上面例子很核心的一个概念就是\verb+__init__+构造函数的继承和重载。比如我们看到garen001实例的创建，其中就引用了Hero的构造函数，特别强调的是\uwave{只有创造实例的时候比如这样的形式Garen()才叫做调用了Garen类的构造方法}， 比如这里\\
\verb+Hero.__init__(self,1,455,56,color)+就是调用了Hero类的构造函数，这个时候需要把self写上，因为self就是最终创建的实例garen001，而不是Hero，而且调用Hero类的构造函数就必须按照它的参量列表形式来。这个概念需要弄清楚！

理解了这一点，在类的继承关系中的构造函数的继承和重载就好看了。比如这里Hero类的构造函数又是继承自Unit类的构造函数，Hero类额外有一个参量level接下来也要开辟存储空间配置好。

\subsection{\_\_str\_\_{}函数的继承和重载}
第二个修改是这里重定义了一些类的\verb+__str__+函数，通过重新定义它可以改变默认print某个类对象是的输出。默认只是一段什么什么类并无具体内容信息。具体就是return一段你想要的字符串样式即可。




\subsection{类的其他内置方法}
类还有其他的一些内置方法，比如\verb+__add__+就控制这对象面对加号时候的行为。这些我们暂时先略过。

更多高级类的内置方法的讨论参见类的内置高级方法这一小节。。


\chapter{操作或者函数}
\section{自定义函数}
定义函数用def命令，语句基本结构如下：
\begin{Verbatim}
def yourfunctionname(para001,para002...):
    do something001
    do something002
\end{Verbatim}

\section{变量作用域问题}
python的变量作用域和大部分语言比如c语言或lisp语言的概念都类似，就是函数里面是局部变量，一层套一层，里面可以引用外面，外面不可以引用里面。

\subsection{global命令}
如果希望函数里面定义的变量能够被外面引用，在变量声明的时候前面加上\textbf{global}命令即可。

通常不建议这么做，除非你确定需要这么做，然后你需要写两行代码才能实现，意思也是不推荐你这么做。
\begin{tcbpython}
def test():
    global var
    var= 'hello'
test()
print(var)
\end{tcbpython}

而且就算你这样做了，这个变量也只能在本py文件中被引用，其他文件用不了。推荐的做法是另外写一个专门用于配置参数的config.py文件，然后那些全局变量都放在里面，如果某个文件要用，就import进来。而对与这个config.py文件的修改会影响所有的py文件配置，这样让全局变量可见可管可控更加通用，才是正确的编程方式。


\section{参数和默认参数}
定义的函数圆括号那里就是接受的参数，如果参数后面跟个等号，来个赋值语句，那个这个赋的值就是这个参数的默认值。比如下面随便写个演示程序：
\begin{xverbatim}[129]{py}
def test(x='hello'):
    print(x)
test()
test('world')
\end{xverbatim}


\section{递归函式}
\label{sec:递归函式}
虽然递归函式能够在某种程度上取代前面的一些循环或者迭代程序结构，不过不推荐这么做。这里谈及递归函式是把某些问题归结为数学函数问题，而这些问题常常用递归算法更加直观（不一定高效）。比如下面的菲波那奇函数：
\begin{xverbatim}[129]{py}
def fib(n):
    if n==0:
        return 1
    if n==1:
        return 1
    else:
        return fib(n-1)+fib(n-2)
        
for x in range(5):
    print(fib(x))
\end{xverbatim}
我们可以看到，对于这样专门的数学问题来说，用这样的递归算法来表述是非常简洁易懂的。至于其内部细节，我们可以将上面定义的fib称之为函式，函式是一种操作的模式，然后具体操作就是复制出这个函式（函数或者操作都是数据），然后按照这个函式来扩展生成具体的函数或者操作。

下面看通过递归函式来写阶乘函数，非常的简洁，我以为这就是最好最美的方法了。
\begin{xverbatim}[129]{py}
def fact(n):
    if n == 0:
        return 1
    else:
        return n*fact(n-1)
        
print(fact(0),fact(10))
\end{xverbatim}

\subsection{什么时候用递归？}
最推荐使用递归的情况是这样的情况，那就是一份工作（或函数）执行一遍之后你能够感觉到虽然所有的工作没有做完，但是已经做了一小部分了，有了一定的进展了，就好比是蚂蚁吞大象一样，那么这个时候你就可以使用递归思想了。其次有的时候有那么一种情况虽然表面上看似乎并没有什么进展，但事情在发展，你能感受到有一个条件最终将会终止程序从而得到一个输出，那么这个时候就可以用递归。

递归思想最核心的两个概念就是一做了一小部分工作，你能感觉到做着做着事情就会做完了；二有一个终止判断最终将会起作用。

其实通过递归函式也可以实现类似for的迭代结构\sidenote{这种情况不推荐使用递归}，不过我觉得递归函式还是不应该滥用。比如下面通过递归函式生成一种执行某个操作n次的结构：

\begin{xverbatim}[129]{py}
def dosomething(n):
    if n==0:
        pass
    elif n==1:
        print('do!')
    else:
        print('do!')
        return dosomething(n-1)

print(dosomething(5))
\end{xverbatim}
可以看到，如果把上面的print语句换成其他的某个操作，比如机器人向前走一步，那么这里dosomething换个名字向前走(5)就成了向前走5步了。

\section{不定参量函数}
我们在前面谈到sum函数\ref{sec:sum函数}只接受一个列表，而不支持这样的形式：sum(1,2,3,4,5)。现在我们设计这样一个可以接受不定任意数目参量的函数。首先让我们看看一种奇怪的赋值方式。

\subsection{序列解包赋值}
\label{sec:序列解包赋值}
\begin{Verbatim}
>>> a,b,*c=1,2,3,4,5,6,7,8,9
>>> print(a,b,c,sep=' | ')
1 | 2 | [3, 4, 5, 6, 7, 8, 9]
>>> a,*b,c=1,2,3,4,5,6,7,8,9
>>> print(a,b,c,sep=' | ')
1 | [2, 3, 4, 5, 6, 7, 8] | 9
>>> *a,b,c=1,2,3,4,5,6,7,8,9
>>> print(a,b,c,sep=' | ')
[1, 2, 3, 4, 5, 6, 7] | 8 | 9
\end{Verbatim}
带上一个星号*的变量变得有点类似通配符的味道了，针对后面的序列\footnote{似乎序列赋值内置迭代操作}（数组，列表，字符串），它都会将遇到的元素收集在一个列表里面，然后说是它的。

for语句也支持序列解包赋值，也是将通配到的的元素收集到了一个列表里面，如：
\begin{xverbatim}[129]{py}
for (a,*b,c) in [(1,2,3,4,5,6),(1,2,3,4,5),(1,2,3,4)]:
    print(b)
\end{xverbatim}


\subsection{函数中的通配符}
\begin{Verbatim}
>>> def test(*args):
...  print(args)
... 
>>> test(1,2,3,'a')
(1, 2, 3, 'a')
\end{Verbatim}
我们看到类似上面序列解包赋值中的带星号表通配的概念，在定义函数的时候写上一个带星号的参量（我们可以想象在函数传递参数的时候有一个类似的序列解包赋值过程），在函数定义里面，这个args就是接受到的参量组成的\emph{元组或称之为数组}。


\subsection{mysum函数}
\begin{xverbatim}[129]{py}
def mysum(*args):
    return sum([arg for arg in args[:]])

print(mysum(1,2,3,4,5,6))
\end{xverbatim}
这样我们定义的可以接受任意参数的mysum函数，如上所示。具体过程就是将接受到的args进行列表解析，然后用sum函数处理了一下。


\subsection{任意数目的可选参数}
在函数定义的写上带上两个星号的变量**args，那么args在函数里面的意思就是接受到的可选参数组成的一个字典值。
\begin{Verbatim}
>>> def test(**args):
...  print(args)
... 
>>> test(a=1,b=2)
{'b': 2, 'a': 1}
\end{Verbatim}

老实说一般参数，可选参数（关键字参数），任意参数，任意关键字参数所有这些概念混在一起非常的让人困惑了，这一块有时间再好好琢磨一下。


\section{lambda函式}
lambda
λ表达式这个在刚开始介绍lisp语言的时候已有所说明，简单来说就是函数只是一个映射规则，变量名，函数名都无所谓的。这里就是没有名字的函数的意思。

具体的样子如下面所示：
\begin{xverbatim}[129]{py}
f=lambda x,y,z:x+y+z
print(f(1,2,3))
\end{xverbatim}

lanmbda函式在有些情况下要用到，比如pyqt里面的信号－槽机制用connect方法的时候，槽比如是函数名或者无参函数，如果用户想加入参量的话，可以使用lamba函式引入，具体这里我还不够清晰。

读者如果对lambda函式表达不太熟悉强烈建议先简单学一学\textbf{scheme}语言。

\section{print函数}
print函数因为很常用和基础，就放在这里了。

print函数接受任意的参量，逐个打印出来。然后它还有一些关键字参数，\textbf{sep}：默认值是' '，也就是一个空格，如果修改为空字符串，那么逐个打印出来的字符之间就没有间隔了。\textbf{end}：默认值是'\textbackslash{}n'，\textbf{file}默认值是sys.stdout，也就是在终端显示，你可以修改为某个文件变量，这样直接往某个文件里面输出内容。



\chapter{宏包}
现在让我们进入宏包基础知识的学习吧，建立编写自己的宏包，这样不断积累自己的知识，不断变得更强。

实际上之前我们已经接触过很多python自身的标准宏包或者其他作者写的第三方宏包，而import和from语句就是加载宏包用的。这里我们主要讨论如何自己编写自己的宏包。

from语句和import语句内部作用机制很类似，只是在变量名的处理方式上有点差异（from会把变量名复制过来）。这里重点就import的工作方式说明如下：
\begin{enumerate}
\item 首先需要找到宏包文件。
\item 然后将宏包文件编译成位码（需要时，根据文件的时间戳。），你会看到新多出来一个\verb+__pycache__+文件夹。
\item 执行编译出来的位码，创建该py文件定义的对象。
\end{enumerate}
这三个步骤是第一次import的时候会执行的，第二次import的时候会跳过去，而直接引用内存中已加载的对象。



\section{找到宏包文件}
python宏包的搜索路径会搜索几个地方，这些地方最后都会放在sys.path这个列表里面，所以在你的py文件刚开始修改这个sys.path，append上你想要的地址也是可以的。我在这里选择了这种简单的方法，除此之外还有很多方法这里先不涉及。

比如主文件一般如下：
\begin{Verbatim}
import os,sys
sys.path.append(os.environ['HOME']+'/pymf')
from pyconfig import *
\end{Verbatim}
这里为什么使用\verb+from pyconfig import *+这样的语句而不是import语句呢？因为我决定整个项目的主py文件除了这一个from语句之外不会再import或者from其他宏包了，其他所有宏包的引用都放在pyconfig.py这个主配置文件里面。

pyconfig.py任务就是加载最常用最通用的一些宏包，如果你实际编写的另外一个项目通用pyconfig文件满足不了你的要求了，那么你可以把那个pyconfig文件复制过来，然后放在你的项目文件夹里面，然后继续衍化修改。这个经验是我从\LaTeX 文档的编写中总结出来的，既满足了共性又满足了个性。

那么为什么要用from语句，很简单。如果用import语句，那么pyconfig.py文件里面import math宏包，在主py文件里面引用就要使用这样的格式\verb+pyconfig.math.pi+，这既不方便而且违背大家平时惯用的那种math.pi格式。


现在我们让可以开始编写自己的宏包吧。

\section{编写宏包}
well，编写宏包就是一些py文件，然后宏包的名字和py文件里面的内容编写好就是了。

我现在编写了一个pyconfig.py文件，放在主文件夹（ubuntu系统）的pymf文件里面的。里面定义了一个斐波拉契函数，如下所示：
\begin{Verbatim}
#菲波那奇数列
def fib(n):
    if n==0:
        return 1
    if n==1:
        return 1
    else:
        return fib(n-1)+fib(n-2)
\end{Verbatim}

然后我们的测试小脚本如下：
\begin{xverbatim}[129]{py}
import os,sys
sys.path.append(os.environ['HOME']+'/pymf')
from pyconfig import *

print([fib(n) for n in range(10)])
\end{xverbatim}

一些你觉得常用的类和函数就直接放在pyconfig.py文件里面吧，然后一些不太常用的你可以分类出来放在其他py文件里面，然后pyconfig.py文件用import或者from语句来加载那个宏包即可，这里就不多说了。


\section{import语句}
import语句的一般使用方法之前已有接触，比如import math，然后要使用math宏包里面的函数或者类等需要使用这样的带点的变量名结构：math.pi。

此外import语句还有一个常见的缩写名使用技巧，比如import numpy as np，那么后面就可以这样写了， np.array，而不是numpy.array。


\section{from语句}
from语句的使用有以下两种情况：
\begin{Verbatim}
from this import this
from what import *
\end{Verbatim}
第一种形式是点名只导入某个变量，第二种形式是都导入进来。我想读者肯定知道这点，使用第二种导入形式的时候要小心变量名覆盖问题，这个自己心里有数即可。


\section{reload函数}
reload函数可以重新载入某个宏包，这个重载和程序重新运行第一次载入宏包又有点区别。








\part{python3高级篇}
\chapter{类的高级知识}
\section{静态方法}
\begin{Verbatim}
class Test:
#    @staticmethod
    def hello():
        print('aaa')

test=Test()
test.hello()
\end{Verbatim}
在上面的例子中，我们希望创造一个函数，这个函数和self或者其他类都没有关系（这里的其他类一般指继承来的）。如上所示，hello函数只是希望简单打印一小段字符，如上面这样的代码是错误的，如果我们在这个函数上面加上\textbf{@staticmethod}，那么上面这段代码就不会出错了，

\begin{Verbatim}
class Test:
    @staticmethod
    def hello():
        print('aaa')

test=Test()
test.hello()
\end{Verbatim}
这样在类里面定义出来的函数叫做这个类的静态方法，静态方法同样可以继承等等，而静态方法通常使用最大的特色就是不需要建立实例，即可以直接从类来调用，如下所示：
\begin{Verbatim}
class Test:
    @staticmethod
    def hello():
        print('aaa')

Test.hello()
\end{Verbatim}

\chapter{类的高级内置方法}

\section{和迭代操作有关}
比如文件对象本身就是可迭代的，调用\verb+__next__+方法就返回文件中下一行的内容，到达文件尾也就是迭代越界了返回：\textbf{StopIteration}异常。

\subsection{next函数}
next函数比如next(f)等价于\verb+f.__next__()+，其中f是一个文件对象。

\begin{Verbatim}
>>> for line in open('removeduplicate.py'):
...  print(line,end='')
... 
#!/usr/bin/env python3
#-*-coding:utf-8-*-
#此处一些内容省略。
    
>>> f=open('removeduplicate.py')
>>> next(f)
'#!/usr/bin/env python3\n'
\end{Verbatim}

\subsection{iter函数}
iter函数接受一个不可迭代对象（比如列表）然后生成一个可迭代对象。这样的可迭代对象就可以使用next函数和\verb+__next__+方法了。

\begin{Verbatim}
>>> list=[1,2,3]
>>> next(list)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'list' object is not an iterator
>>> i=iter(list)
>>> next(i)
1
>>> i.__next__()
2
\end{Verbatim}

下面是for语句的while实现版本：
\begin{Verbatim}
>>> list=[1,2,3]
>>> iter=iter(list)
>>> while True:
...    try:
...        x=next(iter)
...    except StopIteration:
...        break
...    print(x)
... 
1
2
3
\end{Verbatim}

range对象也可以通过iter函数来生成一个可迭代对象。

\subsection{enumerate函数}
enumerate函数返回一个enumerate对象，这个对象将偏移值和元素组合起来，成为一个可迭代对象了，也就是next函数也可以使用了。

\begin{Verbatim}
>>> for (offset,item) in enumerate('abcdefg'):
...  print(offset,item)
... 
0 a
1 b
2 c
3 d
4 e
5 f
6 g
\end{Verbatim}




\chapter{模块}
多个宏包py文件组成一个多文件夹目录的整体就是一个模块，这个暂时还用不到而且处理起来更加复杂，暂时略过。


\chapter{文件处理高级知识}
接下来的例子都基于这样一个简单的removeduplicate.py文件。
\begin{Verbatim}
#!/usr/bin/env python3
#-*-coding:utf-8-*-
def removeduplicate(list):
    newlist = list.copy()
    for j in newlist:
        for index in range(newlist.index(j)+1,len(newlist)-1):
            if j == newlist[index]:
                del newlist[index]
                return removeduplicate(newlist)
    return newlist

if __name__ == '__main__':
    list001=[1,2,3,1,2,4,4,5,5,5,7]
    print(removeduplicate(list001))
\end{Verbatim}

\section{一行行的操作}
因为文件对象本身是可迭代的，我们简单迭代文件对象就可以对文件的一行行内容进行一些操作。比如：
\begin{tcbpython}
f = open('removeduplicate.py')

for line in f:
    print(line,end='')
\end{tcbpython}
这个代码就将打印这个文件，其中end=''的意思是取消\verb+\n+，因为原来的行里面已经有\verb+\n+了。

然后代码稍作修改就可以在每一行之前加上>>>这个符号了。 
\begin{tcbpython}
f = open('removeduplicate.py')

for line in f:
    print('>>>',line,end='')
\end{tcbpython}

什么？这个输出只是在终端，没有到某个文件里面去，行，加上file参数。然后代码变成如下：
\begin{tcbpython}
import sys

f = open('removeduplicate.py')
pyout=open(sys.argv[1] ,"w")

for line in f:
    print('>>>',line,end='',file=pyout)

pyout.close()
f.close()
\end{tcbpython}
这样我们就制作了一个小python脚本，接受一个文件名然后输出这个文件，这个文件的内容就是之前我们在终端中看到的。

\section{整个文件的列表解析}
python的列表解析（迭代）效率是很高的，我们应该多用列表解析模式。

\subsection{readlines方法}
文件对象有一个readlines方法，能够一次性把整个文件的所有行字符串装入到一个列表中。然后我们再对这个列表进行解析操作就可以直接对整个文件的内容做出一些修改了。不过不推荐使用readlines方法了，这样将整个文件装入内存的方法具有内存爆炸风险，而迭代版本更好一点。

\subsection{文本所有某个单词的替换}
这里举一个例子，将removeduplicate.py文件接受进来，然后进行列表解析，将文本中的newlist全部都替换为list2。

\begin{tcbpython}
import sys

pyout=open(sys.argv[1] ,"w")

print(''.join([line.replace('newlist','list2') 
for line in open('removeduplicate.py')]),file=pyout)

pyout.close()
\end{tcbpython}

我们可以看到这种列表解析风格代码更加具有python风格和更加的简洁同时功能是异常的强大的。

从这里起我们看到如果需要更加复杂的文本处理技巧就需要学习正则表达式和re宏包了，请参见re宏包这一小节\ref{sec:re宏包}。




\part{常用的宏包}
\chapter{pickle宏包}
\label{sec:pickle宏包}
pickle宏包可以将某\uwave{一个}复杂的对象永久存入\uwave{一个}文件中，以后再导入这个文件，这样自动将这个复杂的对象导入进来了。

\section{将对象存入文件}
\begin{Verbatim}
import pickle

class Test:
    def __init__(self):
        self.a=0
        self.b=0
        self.c=1
        self.d=1

    def __str__(self):
        return str(self.__dict__)

if __name__ == '__main__':
    test001=Test()
    print(test001)
    testfile=open('data.pkl','wb')
    pickle.dump(test001,testfile)
    testfile.close()
\end{Verbatim}




\section{从文件中取出对象}
值得一提的是从文件中取出对象，原来的类的定义还是必须存在，也就是声明一次在内存中的，否则会出错。
\begin{Verbatim}
import pickle

class Test:
    def __init__(self):
        self.a=0
        self.b=0
        self.c=1
        self.d=1

    def __str__(self):
        return str(self.__dict__)

if __name__ == '__main__':
    testfile=open('data.pkl','rb')
    test001=pickle.load(testfile)
    print(test001)
    testfile.close()
\end{Verbatim}

pickle宏包的基本使用就是用dump函数将某个对象存入某个文件中，然后这个文件以后可以用load函数来加载，然后之前的那个对象会自动返回出来。


\chapter{shelve宏包}
shelve宏包是基于pickle宏包的，也就是只有pickle宏包支持的对象它才支持。 之前提及pickle宏包只能针对一个对象，如果你有多个对象要处理，可以考虑使用shelve宏包，而shelve宏包就好像是自动将这些对象用字典的形式包装起来了。除此之外shelve宏包的使用更加简便了。

\section{存入多个对象}
我们根据类的操作第三版中定义的类（\ref{sec:类的操作第三版}）建立了一个Hero.py文件，就是将那些类的定义复制进去。然后我们新建了几个实例来存入test.db文件中。

\begin{tcbpython}
import shelve
from Hero import Garen

if __name__ == '__main__':
    garen1=Garen()
    garen2=Garen('red')
    garen3=Garen('yellow')
    db=shelve.open('test.db')
    for (key,item) in [('garen1',garen1),('garen2',garen2),('garen3',garen3)]:
        db[key]=item
    db.close()
\end{tcbpython}

我们看到整个过程的代码变得非常的简洁了，然后一个个对象是以字典的形式存入进去的。

\section{读取这些对象}
读取这些对象的代码也很简洁，就是用shelve宏包的open函数打开数据库文件，open函数会自动返回一个字典对象，这个字典对象里面的数据就对应着之前存入的键值和对象。

同时通过这个例子我发现，如果自己定义的类，将他们提取出来放入另外一个文件，那么shelve宏包读取文件时候是不需要再引入之前的定义。这一点值得我们注意，因为shelve宏包内部也采用的是pickle的机制，所以可以猜测之前pickle的那个例子类的定义写在写入文件代码的里面，所以不能载入数据库；而如果将这些类的定义放入一个文件，然后这些类以模块或说宏包载入的形式引入，那么读取这些对象就可以以一种更优雅的形式实现。如下所示：
\begin{tcbpython}
import shelve

if __name__ == '__main__':
    db=shelve.open('test.db')
    for key in sorted(db):
        print(db[key])
    db.close()
\end{tcbpython}

我们看到就作为简单的程序或者原型程序的数据库，shelve宏包已经很好用而且够用了。

\subsection{zodb宏包}


\chapter{time宏包}
time宏包提供了一些和时间相关的函数，更加的底层，不过有些函数可能在某些平台并不适用。类似的宏包还有datetime宏包，datetime是以类的框架来解决一些时间问题的。所以如果只是需要简单的调用一下时间，那么用time宏包，如果是大量和时间相关的问题，推荐使用datetime宏包。

\section{time函数}
\begin{Verbatim}
>>> import time
>>> time.time()
1404348227.07554
\end{Verbatim}
time函数返回一个数值，这个数值表示从1970年1月1号0时0分0秒到现在的时间过了多少秒。

\section{gmtime函数}
这个函数可以接受一个参数，这个参数是多少秒，然后返回一个特定格式的时间数组\verb+struct_time+。如果不接受参数，那么默认接受的秒数由time函数返回，也就是从那个特定时间到现在过了多少秒，这样这个特定格式的时间数组对应的就是当前时间。

\begin{Verbatim}
>>> time.gmtime()
time.struct_time(tm_year=2014, tm_mon=7, tm_mday=3, tm_hour=0, 
tm_min=53, tm_sec=0, tm_wday=3, tm_yday=184, tm_isdst=0)
>>> time.gmtime(0)
time.struct_time(tm_year=1970, tm_mon=1, tm_mday=1, tm_hour=0, 
tm_min=0, tm_sec=0, tm_wday=3, tm_yday=1, tm_isdst=0)
\end{Verbatim}

\section{localtime函数}
此外类似的还有\textbf{localtime}函数，和gmtime用法和返回完全一模一样，唯一的区别就是返回的是当地的时间。
\begin{Verbatim}
>>> time.strftime('%Y-%m-%d %H:%M:%S',time.localtime())
'2014-07-03 09:19:40'
>>> time.strftime('%Y-%m-%d %H:%M:%S',time.gmtime())
'2014-07-03 01:19:49'
\end{Verbatim}


\section{ctime函数}
\begin{Verbatim}
>>> time.ctime()
'Thu Jul  3 08:54:54 2014'
>>> time.ctime(0)
'Thu Jan  1 07:00:00 1970'
\end{Verbatim}
和gmtime类似，不过返回的是字符串格式的时间。我们看到ctime默认设置的时间是根据localtime函数来的。


\section{strftime函数}
接受那个特定格式的时间数组\verb+struct_time+作为参数，然后返回一定字符串格式的时间。
最常用的格式符有：
\begin{Verbatim}
%Y，多少年；%m，多少月；%d，多少日；
%H，多少小时；%M，多少分；%S，多少秒。
\end{Verbatim}

\%{}X直接输出09:27:19这样的格式，也就是前面的多少小时多少分多少秒可以用一个\%{}X表示即可。

还有一些，比如：\%{}I表示多少小时，不过是[0-12]的形式；\%{}y表示多少年，不过是[00-99]的格式，比如2014年就输出14等等。


\section{sleep函数 }
sleep函数有时需要用到，将程序休眠个几秒的意思。需要接受一个数值参数，单位是秒，可以是零点几秒。但sleep函数只是大概休眠几秒的意思，最好不去用来计时，因为它不大精确。



\chapter{sys宏包}
sys宏包有一些功能很常用，其实在前面我们就看到过一些了。

\section{sys.argv}
在刚开始说明python执行脚本参数传递的问题时就已经讲了sys.argv这个变量。这是一个由字符串组成的列表。
\begin{tcbpython}
import sys

print(sys.argv)
for i in range(len(sys.argv)):
    print(sys.argv[i])
\end{tcbpython}
比如新建上面的一个test.py文件，然后执行：
\begin{Verbatim}
python3 test.py test1 test2
['test.py', 'test1', 'test2']
test.py
test1
test2
\end{Verbatim}
我们可以看到sys.argv[0]就是这个脚本的文件名，然后后面依次是各个参数。

\section{exit函数}
这个我们在编写GUI程序的时候经常看到，在其他脚本程序中也很常用。如果不带参数的话那么直接退出程序，还可以带一个字符串参数，返回错误提示信息，或者带一个数字，这里的详细讨论略过。

\begin{tcbbash}[]
>>> import sys
>>> sys.exit('出错了')
出错了
wanze@wanze-ubuntu:~$ 
\end{tcbbash} 
%$

\section{sys.platform}
返回当前脚本执行的操作系统环境。

Linux 返回字符串值：linux；Windows返回win32；Mac OS X 返回darwin。

\section{sys.path}
一连串字符串列表，是python脚本宏包的搜索路径，所以我们自定义的python宏包，只需要在sys.path这个列表上新加一个字符串路径即可。

\section{标准输入输出错误输出文件}
sys.stdin，sys.stdout，sys.stderr这三个文件对象对应的就是linux系统所谓的标准输入标准输出和错误输出文件流对象。

\section{判断python的版本}
sys.version输出当前python的版本信息和编译环境的详细信息。

\mint{bash}+sys.version_info[0]+返回当前python主版本的标识，比如python3就返回数字3。



\chapter{os.path宏包}
前面提到sys.argv只能返回当前python脚本的文件名，而我们常常需要这个python脚本的绝对路径，这可以通过os.path宏包的abspath函数来达到目的。

\section{abspath函数}
abspath函数最常用的用法如下：
\begin{tcbpython}
import os

print(os.path.abspath(''))
\end{tcbpython}
\begin{Verbatim}
/home/wanze/桌面
\end{Verbatim}


也就是根据当前脚本所在的路径做修改从而生成一个绝对路径，大部分系统都兼容。

\section{expanduser函数}
\begin{tcbpython}
import os

print(os.path.expanduser('~'))
\end{tcbpython}
\begin{Verbatim}
/home/wanze/test
\end{Verbatim}

\verb+~+这个符号可以在这里使用，从而展开为以/home/wanze为基础的绝对路径，兼容大部分系统。




\section{判断是否是文件或路径等}
os.path.isfile(path)：接受一个字符串路径变量，如果是文件那么返回True，否则返回False。

类似的有isdir和islink函数。

\section{判断文件或路径是否相同}
os.path.samefile(path1,path2)：如果两个文件或路径相同则返回True\\，否则返回False。


\chapter{subprocess宏包}
我想大家都注意到了现在的计算机都是多任务的，这种多任务的实现机制就是所谓的多个进程同时运行，因为计算机只有一个CPU（现在多核的越来越普及了，它们内部的工作原理我没了解过。）所有计算机一次只能处理一个进程，而这种多进程的实现有点类似你人脑（当然不排除某些极个别现象），你不能一边看电影一边写作业，但是可以写一会作业然后再看一会电影（当然不推荐这么做、），计算机的多进程实现机制也和这个类似，就是一会干这个进程，一会儿做那个进程。

计算机的一个进程里面还可以分为很多个线程，这个较为复杂，就不谈了。比如你编写的一个脚本程序，系统就会给它分配一个进程号之类的，然后cpu有时就会转过头来执行它一下（计算机各个进程之间的切换很快的，所以才会给我们一种多任务的错觉。）而你的脚本程序里面还可以再开出其他的子进程出来， python的subprocess宏包主要负责这方面的工作。

\section{call函数}
\begin{tcbpython}[]
import subprocess

# Command with shell expansion
subprocess.call(["echo", "hello world"])
subprocess.call(["echo", "$HOME"])
subprocess.call('echo $HOME',shell=True)
\end{tcbpython}
\begin{Verbatim}
hello world
$HOME
/home/wanze
\end{Verbatim}
%$

其中使用shell=True选项后用法较简单较直观，但网上提及安全性和兼容性可能有问题，他们推荐一般不适用shell=True这个选项。\sidenote{\href{http://stackoverflow.com/questions/3172470/actual-meaning-of-shell-true-in-subprocess}{参考网站}}

如果不使用shell=True这个选项的，比如这里\verb+$HOME+这个系统变量就无法正确翻译过来，如果实在需要home路径，需要使用os.path的expanduser函数。



\section{getoutput函数}
取出某个进程命令的输出，返回的是字符串形式。
\begin{Verbatim}
import subprocess

name=subprocess.getoutput('whoami')
print(name)
\end{Verbatim}



\section{getstatusoutput函数}
某个进程执行的状态。



\section{Popen类}
根据Popen类创建一个进程管理实例，可以进行进程的沟通，暂停，关闭等等操作。前面的函数的实现是基于Popen类的，这是较高级的课题，这里暂时略过。




\chapter{collections宏包}
\section{namedtuple函数}
collections宏包里面的namedtuple函数将会产生一个有名字的数组的类，通过这个类可以新建类似的实例。比如：
\begin{xverbatim}[129]{py}
from collections import namedtuple

Point3d=namedtuple('Point3d',['x','y','z'])
p1=Point3d(0,1,2)
print(p1)
print(p1[0],p1.z)
\end{xverbatim}


\chapter{re宏包}
\label{sec:re宏包}


\chapter{datetime宏包}

\chapter{calendar宏包}



\part{加上GUI}
具体内容请参看文件夹\textbf{pyqt4指南}。




\part{常用的第三方宏包}
\chapter{setuptools宏包}
setuptools宏包方便python用户快速分发自己写的python宏包，特别是对于那些对其他宏包有依存关系的宏包。

安装就是先安装pip3：
\begin{Verbatim}
sudo apt-get install python3-pip
\end{Verbatim}


然后通过pip3来安装setuptools：
\begin{Verbatim}
sudo pip3 install setuptools
\end{Verbatim}


\chapter{sql数据库技术}
\begin{flushright}
\begin{notecard}[red!30]{12em}
 一个程序没有数据库哪有什么用处啊。
\end{notecard}
\end{flushright}


数据库有很多类型，比如sql为代表的关系数据库，在python中推荐sqlite3宏包，这个python3里面自带的标准模块，不过你的linux系统还是需要安装sqlite3命令行工具。也就是：

\begin{tcbbash}[]
sudo apt-get install sqlite3
\end{tcbbash}




而在python中既要有sql的底层又要有良好的python语法接口，推荐使用sqlalchemy宏包。



\chapter{numpy宏包}
\section{安装}
安装使用类似的语法：
\begin{Verbatim}
sudo apt-get install python3-numpy
\end{Verbatim}



\section{ndarray对象}
\begin{Verbatim}
import numpy as np
x = np.array([1,2,3,4,5,6])
print(x)
type(x)
\end{Verbatim}


\section{ndarray元素的引用}
语法和list对象中元素的引用类似。


\section{多维ndarray}
\begin{Verbatim}
y=np.array([[1,2,3,4,5],[6,7,8,9,10]])
y,y[0][1],y[0]
\end{Verbatim}


\section{shape属性}
ndarray对象有一个shape属性，表示几行几列。
\begin{Verbatim}
y.shape
\end{Verbatim}

\section{dtype属性}
ndarray对象有一个dtype属性，表示存储相同单元的数据类型。

dtype属性还有小属性itemsize
\begin{Verbatim}
In [1]: import numpy as np
In [2]: a=np.arange(5)
In [3]: a
Out[3]: array([0, 1, 2, 3, 4])
In [4]: a.dtype
Out[4]: dtype('int32')
In [5]: a.dtype.itemsize
Out[5]: 4
\end{Verbatim}




\section{in语句}
in语句测量某元素是不是在这个ndarray对象中。
\begin{Verbatim}
8 in y, 11 in y
\end{Verbatim}

\section{reshape方法}
\begin{Verbatim}
In [8]: ndarray001=np.arange(1,10).reshape(3,3)
In [9]: ndarray001
Out[9]: 
array([[1, 2, 3],
       [4, 5, 6],
       [7, 8, 9]])
\end{Verbatim}




\section{copy方法}



\section{ndarray变成list}


\section{类似range的arange函数}

\section{flatten方法}


\section{resize方法}


\section{transpose方法}


\section{eye方法}
创造单位矩阵

\begin{Verbatim}
In [10]: ndarray001=np.eye(3)
In [11]: ndarray001
Out[11]: 
array([[ 1.,  0.,  0.],
       [ 0.,  1.,  0.],
       [ 0.,  0.,  1.]])

\end{Verbatim}


\section{读写文件}
\begin{Verbatim}
In [10]: ndarray001=np.eye(3)
In [12]: np.savetxt("ndarray001.txt",ndarray001)
In [13]: x=np.loadtxt("ndarray001.txt")
In [14]: x
Out[14]: 
array([[ 1.,  0.,  0.],
       [ 0.,  1.,  0.],
       [ 0.,  0.,  1.]])
\end{Verbatim}




\part{其他}
\chapter{暂时还不知道分类的东东}

\section{matplotlib加入中文}
\href{http://blog.sciencenet.cn/blog-43412-343002.html }{参考网站}

\section{matplotlib棒状图上加上说明文字}
\href{http://stackoverflow.com/questions/7423445/how-can-i-display-text-over-columns-in-a-bar-chart-in-matplotlib}{参考网站}


\section{从excel中读取数据}
xlrd宏包

\section{中文排序}
\href{https://github.com/mozillazg/python-pinyin}{参考网站}

\subsection{字典按值排序}
字典按值排序：\href{http://www.cnpythoner.com/post/266.html}{参考网站}

\section{for语句的进阶}
在lisp语言的loop宏中，还有很多高级应用，比如

\begin{description}
\item[collect] 将迭代产生的所有信息收集到列表中。
\item[summing] 将迭代产生的所有信息加到一起。
\item[count] 跟着一个判断函数，每次迭代运行一次，然后记录得到的True即真值的情况的总数。
\item[minimize] 将每次迭代的结果进行比较，然后返回最小值。
\item[maximize] 同minimize，返回最大值。
\item[append] 将每次迭代产生的列表append在一起。
\end{description}

那么在python中如何实现以上功能呢？

在这里最基本的是通过迭代语句产生一个列表，然后通过某些函数比如minimize对应min函数，maximize对应max函数等对这个列表进行一些操作即可。

\begin{xverbatim}[129]{py}
from random import *
def random_list_max(n):
    y=[randint(1,n) for x in range(1000)]
    list_count=[y.count(x) for x in range(1,n+1)]
    return list_count.index(max(list_count))+1

print(random_list_max(40))
\end{xverbatim}


%这里空一行

\end{common-format}
\end{document}