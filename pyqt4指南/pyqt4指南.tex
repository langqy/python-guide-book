% !Mode:: "TeX:UTF-8"%確保文檔utf-8編碼
%新加入的命令如下：addchtoc addsectoc reduline showendnotes hlabel
%新加入的环境如下：common-format  fig linefig xverbatim

\documentclass[12pt,oneside]{book}
\newlength{\textpt}
\setlength{\textpt}{12pt}
\newif\ifphone
\phonefalse


\usepackage{myconfig}
\usepackage{mytitle}




\begin{document}
\frontmatter

\titlea{pyqt4指南}
\author{万泽}
\authorinfo{作者：}
\editor{德山书生}
\email{a358003542@gmail.com}
\editorinfo{编者：德山书生，湖南常德人氏。}
\version{0.1}
\titleLA

\addchtoc{前言}
\chapter*{前言}
\begin{common-format}
前置知识：python语言基础知识。从变量各个操作对象到程序结构直到类。


本文主要参考资料：\\
1.pyqt4教程，\href{http://blog.cx125.com/books/PyQt4_Tutorial/}{http://blog.cx125.com/books/PyQt4\_{}Tutorial/}

2.Prentice Hall，Rapid GUI Programming with Python and Qt，2007年10月

3.http://pyqt.sourceforge.net/Docs/PyQt4/classes.html

4.http://straightedgelinux.com/blog/python/html/pyqtxt.html

5.


%这里空一行。

\end{common-format}


\addchtoc{目录}
\setcounter{tocdepth}{2}
\tableofcontents

\begin{common-format}
\mainmatter

\chapter{刚开始}

\section{安装pyqt4}
ubuntu下安装pyqt4即安装python3-pyqt4即可：\\
\verb+sudo apt-get install python3-pyqt4+

检查pyqt4安装情况执行以下脚本即可，显示的是当前安装的pyqt4的版本号:
\begin{Verbatim}
from PyQt4.QtCore import QT_VERSION_STR
print(QT_VERSION_STR)
\end{Verbatim}

\section{pyqt4模块简介}
\begin{description}
\item[QtCore] 模块包括了核心的非GUI功能，该模块用来对时间、文件、目录、各种数据类型、流、网址、媒体类型、线程或进程进行处理。
\item[QtGui] 模块包括图形化窗口部件和及相关类。包括如按钮、窗体、状态栏、滑块、位图、颜色、字体等等。
\item[QtHelp] 模块包含了用于创建和查看可查找的文档的类。
\item[QtNetwork] 模块包括网络编程的类。这些类可以用来编写TCP/IP和UDP的客户端和服务器。它们使得网络编程更容易和便捷。
\item[QtOpenGL] 模块使用OpenGL库来渲染3D和2D图形。该模块使得Qt GUI库和OpenGL库无缝集成。
\item[QtScript] 模块包含了使PyQt应用程序使用JavaScript解释器编写脚本的类。
\item[QtSql] 模块提供操作数据库的类。
\item[QtSvg] 模块提供了显示SVG文件内容的类。可缩放矢量图形(SVG)是一种用XML描述二维图形和图形应用的语言。
\item[QtTest] 模块包含了对PyQt应用程序进行单元测试的功能。（PyQt没有实现完全的Qt单元测试框架，相反，它假设使用标准的Python单元测试框架来实现模拟用户和GUI进行交互。）
\item[QtWebKit] 模块实现了基于开源浏览器引擎WebKit的浏览器引擎。
\item[QtXml] 包括处理XML文件的类，该模块提供了SAX和DOM API的接口。
\item[QtXmlPatterns] 模块包含的类实现了对XML和自定义数据模型的XQuery和XPath的支持。
\item[phonon] 模块包含的类实现了跨平台的多媒体框架，可以在PyQt应用程序中使用音频和视频内容。
\item[QtMultimedia] 模块提供了低级的多媒体功能，开发人员通常使用\textbf{phonon}模块。
\item[QtAssistant] 模块包含的类允许集成\textbf{Qt Assistant}到PyQt应用程序中，提供在线帮助。
\item[QtDesigner] 模块包含的类允许使用PyQt扩展\textbf{Qt Designer}。
\item[Qt] 模块综合了上面描述的模块中的类到一个单一的模块中。这样做的好处是你不用担心哪个模块包含哪个特定的类，坏处是加载进了整个Qt框架，从而增加了应用程序的内存占用。
\item[uic] 模块包含的类用来处理.ui文件，该文件由Qt Designer创建，用于描述整个或者部分用户界面。它包含的加载.ui文件和直接渲染以及从.ui文件生成Python代码为以后执行的类。
\end{description}


\chapter{第一个例子}
\section{窗口}
\begin{Verbatim}
import sys
from PyQt4  import QtGui

class MyQWidget(QtGui.QWidget):
    def __init__(self,parent=None):
        QtGui.QWidget.__init__(self,parent)
        self.setGeometry(0, 0, 800, 600)
        #坐标0 0 大小800 600
        self.setWindowTitle('myapp')

myapp = QtGui.QApplication(sys.argv)
mywidget = MyQWidget()
mywidget.show()
sys.exit(myapp.exec_())
\end{Verbatim}

首先导入sys宏包，是为了后面接受sys.argv参数\footnote{这里sys.argv就是这个py文件的文件名组成的列表：['窗口.py']}。从PyQt4模块导入QtGui宏包，是为了后面创建QWidget类的实例。

接下来我们定义了MyQWidget类，它继承自QtGui的QWidget类。然后重定义了构造函数，首先继承了QtGui的QWidget类的构造函数，这里将parent的默认参数传递进去了。

然后通过QWidget类定义好的\textbf{setGeometry}方法来调整窗口的左顶点的坐标位置和窗口的大小。

然后通过\textbf{setWindowTitle}方法来设置这个窗口程序的标题，这里就简单设置为myapp了。

任何窗口程序都需要创建一个QApplication类的实例，这里是myapp。然后接下来创建QWidget类的实例mywidget，然后通过调用mywidget的方法\textbf{show}来显示窗体。

最后我们看到系统要退出是调用的myapp实例的\textbf{exec\_}方法。


\section{加上图标}
现在我们在前面第一个程序的基础上稍作修改，来给这个程序加上图标。程序代码如下：
\begin{Verbatim}
import sys
from PyQt4  import QtGui

class MyQWidget(QtGui.QWidget):
    def __init__(self,parent=None):
        QtGui.QWidget.__init__(self,parent)
        self.resize(800,600)
        self.setWindowTitle('myapp')
        self.setWindowIcon(QtGui.QIcon\
        ('icons/myapp.ico'))


myapp = QtGui.QApplication(sys.argv)
mywidget = MyQWidget()
mywidget.show()
sys.exit(myapp.exec_())
\end{Verbatim}

这个程序相对上面的程序就增加了一个\textbf{setWindowIcon}方法，这个方法调用了QtGui.QIcon方法，然后后面跟的就是图标的存放路径，使用相对路径。在运行这个例子的时候，请随便弄个图标文件过来。

这个程序为了简单起见就使用了QWidget类的\textbf{resize}方法来设置窗体的大小。



\section{弹出提示信息}
\begin{Verbatim}
import sys
from PyQt4  import QtGui

class MyQWidget(QtGui.QWidget):
    def __init__(self,parent=None):
        QtGui.QWidget.__init__(self,parent)
        self.resize(800,600)
        self.setWindowTitle('myapp')
        self.setWindowIcon(QtGui.QIcon\
        ('icons/myapp.ico'))
        self.setToolTip('看什么看^_^')
        QtGui.QToolTip.setFont(QtGui.QFont\
        ('微软雅黑', 12))

myapp = QtGui.QApplication(sys.argv)
mywidget = MyQWidget()
mywidget.show()
sys.exit(myapp.exec_())
\end{Verbatim}

上面这段代码和前面的代码的不同就在于MyQWidget类的初始函数新加入了两条命令。其中\textbf{setToolTip}方法设置具体显示的文本内容，然后后面调用QToolTip类的\textbf{setFont}方法来设置字体和字号，我不太清楚这里随便设置系统的字体微软雅黑是不是有效。

这样你的鼠标停放在窗口上一会儿会弹出一小段提示文字。


\section{关闭窗体时询问}
目前程序点击那个叉叉图标关闭程序的时候将会直接退出，这里新加入一个询问机制。
\begin{Verbatim}
import sys
from PyQt4  import QtGui

class MyQWidget(QtGui.QWidget):
    def __init__(self,parent=None):
        QtGui.QWidget.__init__(self,parent)
        self.resize(800,600)
        self.setWindowTitle('myapp')
        self.setWindowIcon(QtGui.QIcon\
        ('icons/myapp.ico'))
        self.setToolTip('看什么看^_^')
        QtGui.QToolTip.setFont(QtGui.QFont\
        ('微软雅黑', 12))

    def closeEvent(self, event):
        reply = QtGui.QMessageBox.question\
        (self, '信息',
            "你确定要退出吗？",
             QtGui.QMessageBox.Yes,
             QtGui.QMessageBox.No)

        if reply == QtGui.QMessageBox.Yes:
            event.accept()
        else:
            event.ignore()

myapp = QtGui.QApplication(sys.argv)
mywidget = MyQWidget()
mywidget.show()
sys.exit(myapp.exec_())
\end{Verbatim}

这段代码和前面代码的不同就是重新定义了\textbf{colseEvent}事件。这段代码的核心就是QtGui类的QMessageBox类的question方法，这个方法将会弹出一个询问窗体。这个方法接受四个参数：第一个参数是这个窗体所属的母体，这里就是self也就是实例mywidget；第二个参数是弹出窗体的标题；第三个参数是一个标准button；第四个参数也是一个标准button，是默认（也就是按enter直接选定的）的button。然后这个方法返回的是那个被点击了的标准button的标识符，所以后面和标准buttonYes比较了，然后执行event的accept方法。

这样这个程序在关闭的时候会弹出一个对话框，询问你是否真的要关闭，具体请读者自己实验一下。

\section{屏幕居中显示窗体}
\begin{Verbatim}
import sys
from PyQt4  import QtGui

class MyQWidget(QtGui.QWidget):
    def __init__(self,parent=None):
        QtGui.QWidget.__init__(self,parent)
        self.resize(800,600)
        self.center()
        self.setWindowTitle('myapp')
        self.setWindowIcon(QtGui.QIcon\
        ('icons/myapp.ico'))
        self.setToolTip('看什么看^_^')
        QtGui.QToolTip.setFont(QtGui.QFont\
        ('微软雅黑', 12))

    def closeEvent(self, event):
        #重新定义colseEvent
        reply = QtGui.QMessageBox.question\
        (self, '信息',
            "你确定要退出吗？",
             QtGui.QMessageBox.Yes,
             QtGui.QMessageBox.No)

        if reply == QtGui.QMessageBox.Yes:
            event.accept()
        else:
            event.ignore()
            
    def center(self):
        screen = QtGui.QDesktopWidget().screenGeometry()
        size =  self.geometry()
        self.move((screen.width()-size.width())/2,\
         (screen.height()-size.height())/2)

myapp = QtGui.QApplication(sys.argv)
mywidget = MyQWidget()
mywidget.show()
sys.exit(myapp.exec_())
\end{Verbatim}
这个例子和前面相比改动是新建了一个center方法，接受一个实例，这里是mywidget。然后对这个实例也就是窗口的具体位置做一些调整。

QDesktopWidget类的\textbf{screenGeometry}方法返回一个量，这个量的width属性就是屏幕的宽度（按照pt像素计，比如1366×768\\，宽度就是1366），这个量的height属性就是屏幕的高度。

然后QWidget类的\textbf{geometry}方法同样返回一个量，这个量的width是这个窗体的宽度，这个量的height属性是这个窗体的高度。

然后调用QWidget类的move方法，这里是对mywidget这个实例作用。我们可以看到move方法的X，Y是从屏幕的坐标原点 (0,0) 开始计算的。第一个参数X表示向右移动了多少宽度，Y表示向下移动了多少高度。

整个函数的作用效果就是将这个窗体居中显示。


\section{QMainWindow类}
QtGui.QMainWindow类提供应用程序主窗口，可以创建一个经典的拥有状态栏、工具栏和菜单栏的应用程序骨架。（之前使用的是QWidget类，现在换成QMainWindow类。）

前面第一个例子都是用的QtGui.QWidget类创建的一个窗体。关于QWidget和QMainWindow这两个类的区别\href{http://stackoverflow.com/questions/3298792/whats-the-difference-between-qmainwindow-and-qwidget-and-qdialog}{参考这个网站}得出的结论是：QWdget类在Qt中是所有可画类的基础（这里的意思可能是窗体的基础吧。） 任何基于QWidget的类都可以作为独立窗体而显示出来而不需要母体（parent）。

QMainWindow类是针对主窗体一般需求而设计的，它预定义了菜单栏状态栏和其他widget（窗口小部件） 。因为它继承自QWidget，所以前面谈及的一些属性修改都适用于它。那么首先我们将之前的代码中的QWidget类换成QMainWindow类。


\begin{Verbatim}
import sys
from PyQt4  import QtGui

class MainWindow(QtGui.QMainWindow):
    def __init__(self,parent=None):
        QtGui.QMainWindow.__init__(self,parent)
        self.resize(800,600)
        self.center()
        self.setWindowTitle('myapp')
        self.setWindowIcon(QtGui.QIcon\
        ('icons/myapp.ico'))
        self.setToolTip('看什么看^_^')
        QtGui.QToolTip.setFont(QtGui.QFont\
        ('微软雅黑', 12))

    def closeEvent(self, event):
        reply = QtGui.QMessageBox.question\
        (self, '信息',
            "你确定要退出吗？",
             QtGui.QMessageBox.Yes,
             QtGui.QMessageBox.No)

        if reply == QtGui.QMessageBox.Yes:
            event.accept()
        else:
            event.ignore()

    def center(self):
        screen = QtGui.QDesktopWidget().screenGeometry()
        size =  self.geometry()
        self.move((screen.width()-size.width())/2,\
         (screen.height()-size.height())/2)

myapp = QtGui.QApplication(sys.argv)
mainwindow = MainWindow()
mainwindow.show()
sys.exit(myapp.exec_())
\end{Verbatim}

现在程序运行情况良好，我们继续加点东西进去。


\section{加上状态栏}
\begin{Verbatim}
#!/usr/bin/env python3
#-*- coding: utf-8 -*-
import sys
from PyQt4  import QtGui

class MainWindow(QtGui.QMainWindow):
    def __init__(self,parent=None):
        QtGui.QMainWindow.__init__(self,parent)
        self.resize(800,600)
        self.center()
        self.setWindowTitle('myapp')
        self.setWindowIcon(QtGui.QIcon\
        ('icons/myapp.ico'))
        self.setToolTip('看什么看^_^')
        QtGui.QToolTip.setFont(QtGui.QFont\
        ('微软雅黑', 12))


    def closeEvent(self, event):
        reply = QtGui.QMessageBox.question\
        (self, '信息',
            "你确定要退出吗？",
             QtGui.QMessageBox.Yes,
             QtGui.QMessageBox.No)

        if reply == QtGui.QMessageBox.Yes:
            event.accept()
        else:
            event.ignore()

    def center(self):
        screen = QtGui.QDesktopWidget().screenGeometry()
        size =  self.geometry()
        self.move((screen.width()-size.width())/2,\
         (screen.height()-size.height())/2)

myapp = QtGui.QApplication(sys.argv)
mainwindow = MainWindow()
mainwindow.show()
mainwindow.statusBar().showMessage('程序已就绪...')
sys.exit(myapp.exec_())
\end{Verbatim}

这个程序和前面的区别在于最后倒数第二行，调用mainwindow这个QMainWindow类生成的实例的\textbf{statusBar}方法生成一个QStatusBar对象，然后调用QStatusBar类的\textbf{showMessage}方法来显示一段文字。

如果你希望这段代码在\verb+__init__+方法里面，那么具体实现过程也与上面描述的类似。考虑到状态栏有些程序不一定需要，这里暂时不加到构造函数里面了。


\section{加上菜单栏}
\begin{Verbatim}
#!/usr/bin/env python3
#-*- coding: utf-8 -*-
import sys
from PyQt4  import QtGui

class MainWindow(QtGui.QMainWindow):
    def __init__(self,parent=None):
        QtGui.QMainWindow.__init__(self,parent)
        self.resize(800,600)
        self.center()
        self.setWindowTitle('myapp')
        self.setWindowIcon(QtGui.QIcon\
        ('icons/myapp.ico'))
        self.setToolTip('看什么看^_^')
        QtGui.QToolTip.setFont(QtGui.QFont\
        ('微软雅黑', 12))

    #菜单栏
        self.menubar = self.menuBar()
        menu_file=self.menubar.addMenu('文件')
        menu_edit=self.menubar.addMenu('编辑')
        menu_help=self.menubar.addMenu('帮助')

    def closeEvent(self, event):
        reply = QtGui.QMessageBox.question\
        (self, '信息',
            "你确定要退出吗？",
             QtGui.QMessageBox.Yes,
             QtGui.QMessageBox.No)

        if reply == QtGui.QMessageBox.Yes:
            event.accept()
        else:
            event.ignore()

    def center(self):
        screen = QtGui.QDesktopWidget().screenGeometry()
        size =  self.geometry()
        self.move((screen.width()-size.width())/2,\
         (screen.height()-size.height())/2)

myapp = QtGui.QApplication(sys.argv)
mainwindow = MainWindow()
mainwindow.show()
mainwindow.statusBar().showMessage('程序已就绪...')
sys.exit(myapp.exec_())
\end{Verbatim}
和上面讨论加上状态栏类似，这里用QMainWindow类的menuBar方法来获得一个菜单栏对象。然后用这个菜单栏对象的\textbf{addMenu}方法来创建一个新的菜单对象（QMenu类）——方法里面的内容是新建菜单显示的名字。

建议给菜单对象取个名字，后面方便引用。



\section{加上动作}
\begin{Verbatim}
#!/usr/bin/env python3
#-*- coding: utf-8 -*-
import sys
from PyQt4  import QtGui

class MainWindow(QtGui.QMainWindow):
    def __init__(self,parent=None):
        QtGui.QMainWindow.__init__(self,parent)
        self.resize(800,600)
        self.center()
        self.setWindowTitle('myapp')
        self.setWindowIcon(QtGui.QIcon\
        ('icons/myapp.ico'))
        self.setToolTip('看什么看^_^')
        QtGui.QToolTip.setFont(QtGui.QFont\
        ('微软雅黑', 12))

    #动作和连接
        act_exit = QtGui.QAction('退出', self)
        act_exit.setStatusTip('退出程序')
        act_exit.triggered.connect(self.close)

        act_about = QtGui.QAction('关于本程序', self)
        act_about.triggered.connect(self.about)

        act_aboutqt = QtGui.QAction('关于Qt', self)
        act_aboutqt.triggered.connect(self.aboutqt)

    #菜单栏
        self.menubar = self.menuBar()
        menu_file=self.menubar.addMenu('文件')
        menu_file.addAction(act_exit)
        menu_edit=self.menubar.addMenu('编辑')
        menu_help=self.menubar.addMenu('帮助')
        menu_help.addAction(act_about)
        menu_help.addAction(act_aboutqt)

#函数
    def about(self):
        QtGui.QMessageBox.about(self,"关于本程序","本程序是一个用于教学的程序。\n\nFell free to use it\n(including it's source code).")
    def aboutqt(self):
        QtGui.QMessageBox.aboutQt(self)

    def closeEvent(self, event):
        reply = QtGui.QMessageBox.question\
        (self, '信息',
            "你确定要退出吗？",
             QtGui.QMessageBox.Yes,
             QtGui.QMessageBox.No)

        if reply == QtGui.QMessageBox.Yes:
            event.accept()
        else:
            event.ignore()

    def center(self):
        screen = QtGui.QDesktopWidget().screenGeometry()
        size =  self.geometry()
        self.move((screen.width()-size.width())/2,\
         (screen.height()-size.height())/2)

myapp = QtGui.QApplication(sys.argv)
mainwindow = MainWindow()
mainwindow.show()
mainwindow.statusBar().showMessage('程序已就绪...')
sys.exit(myapp.exec_())
\end{Verbatim}
现在在前面例子的基础上给之前的菜单对象加上动作。比如menu\_{}file就是之前创建的一个菜单对象，现在调用这个对象的\textbf{addAction}方法，将act\_{}exit动作对象加进去。

act\_{}exit动作对象需要在前面定义，通过QtGui类的QAction类的构造函数来创建一个动作对象。构造函数最少需要两个参量：第一个是显示的文本，第二个是这个动作依附的母体（也就是常见的parent变量），通常这里填上self即可。

在这里这个动作对象，就是菜单的下拉选项，如果我们用鼠标点击一下的话，将会触发\textbf{triggered}信号，如果我们connect方法连接到某个槽上（或者某个你定义的函数），那么将会触发这个函数的执行。下面就信号－槽机制详细说明之。
\subsection{信号－槽机制}
GUI程序一般都引入一种事件和信号机制，well，简单来说就是一个循环程序，这个循环程序等到某个时刻程序会自动做某些事情比如刷新程序界面啊，或者扫描键盘鼠标之类的，等用户点击鼠标或者按了键盘之后，它会接受这个信号然后做出相应的反应。

所以你一定猜到了，close函数可能就是要退出这个循环程序。我们调用主程序的\verb+exec_+方法，就是开启这个循环程序。
\begin{Verbatim}
myapp.exec_()
\end{Verbatim}

pyqt4的旧信号－槽连接语句我在这里忽略了，网上到处都是。下面就新的语句说明之。
\begin{Verbatim}
act_exit.triggered.connect(self.close)
\end{Verbatim}
我们看到新的信号－槽机制语句变得更精简更易懂了。整个过程就是如我前面所述，某个对象发出了某个信号，然后用connect将这个信号和某个槽（或者你定义的某个函数）连接起来即形成了一个反射弧了。

这里的槽就是self主窗口实例的close方法，这个是主窗口自带的函数。

下面我们看到aboutqt和about函数，是重新定义的。具体读者如果不懂请翻阅QMessageBox类的静态方法about和aboutqt。


\chapter{简单的编辑器}



\chapter{布局设计}
先就常用布局类进行介绍，然后引入用qt设计器来手工绘制UI的过程。

\section{QHBoxLayout类}
在QtGui模块中，继承自QBoxLayout，QBoxLayout继承自QLayout，QLayout继承自QObject和QLayoutItem。

简单布局，让元素横向排列。

使用方法如下：
\begin{Verbatim}
mainlayout=QtGui.QHBoxLayout()
mainlayout.addWidget(button1)
mainlayout.addWidget(button2)
self.setLayout(mainlayout)
\end{Verbatim}
首先建立一个布局对象，有QHBoxLayout类生成，然后在这个布局实例里面用\textbf{addWidget}方法来加入元素，然后将这个布局用主窗口的\textbf{setLayout}方法设置进去。

\section{QVBoxLayout类}
在QtGui模块中，继承自QBoxLayout，QBoxLayout继承自QLayout，QLayout继承自QObject和QLayoutItem。

和QHBoxLayout类似，简单布局，竖向排列。


\chapter{pyqt4类详解}
\section{QWidget类}
在QtGui模块中，继承自QObject和QPaintDevice。

\subsection{构造函数}
\begin{Verbatim}
QWidget.__init__(self, QWidget parent = None, Qt.WindowFlags flags = 0)
\end{Verbatim}

默认parent是None，如果是其他widget，那么这个widget就变成那个（参量）widget的子窗口了，如果那个（参量）widget删除了，这个widget也就是删除了。

\subsection{激活窗口}
\begin{Verbatim}
QWidget.activateWindow(self)
\end{Verbatim}
activateWindow方法用于激活这个窗口，这个窗口是可见的并且可以键盘输入。点击窗口的标题栏一个窗口就上前显现了用的就是这个函数。

\subsection{调整窗口大小}
\begin{Verbatim}
QWidget.setGeometry(self, QRect)
QWidget.setGeometry(self, int ax, int ay, int aw, int ah)
QWidget.resize(self, QSize)
QWidget.resize(self, int w, int h)
\end{Verbatim}

\subsection{设置图标}
\begin{Verbatim}
QWidget.setWindowIcon(self, QIcon icon)
QWidget.setWindowIconText(self, QString)
\end{Verbatim}
就是设置程序下面显示的图标和图标文字。（QString对象我测试了直接用python3的字符串对象也是可以的。）


\subsection{设置窗口标题}
\begin{Verbatim}
QWidget.setWindowTitle(self, QString)
\end{Verbatim}


\subsection{show方法}
\begin{Verbatim}
QWidget.show(self)
\end{Verbatim}
显示某个窗口和它的子窗口，相当于让这个窗口可见，和\textbf{setVisible(True)}等价。

\subsection{设置提示词}
\begin{Verbatim}
QWidget.setToolTip(self, QString)
\end{Verbatim}

\subsection{closeEvent方法}
\begin{Verbatim}
QWidget.closeEvent (self, QCloseEvent)
\end{Verbatim}
一般在窗口关闭时调用，你可以重定义这个方法来改变窗口在面对关闭事件时的反应。



\section{QIcon类}
在QtGui模块中。

这个类提供了可缩放图标的解决方案。

\subsection{构造函数}
\begin{Verbatim}
__init__(self)
__init__(self, QPixmap pixmap)
__init__(self, QIcon other)
__init__(self, QString fileName)
__init__(self, QIconEngine engine)
__init__(self, QIconEngineV2 engine)
__init__(self, QVariant variant)
\end{Verbatim}

最常用的是第四种形式，也就是用相对路径（要注意操作系统的不同可能带来的问题）引用某个图标文件。


\section{QPushButton类}
来自QtGui模块，继承自QAbstractButton类，QAbstractButton类继承自QWidget类。

QPushButton也就是GUI设计中最常见的按钮。

\subsection{构造函数}
\begin{Verbatim}
__init__(self, QWidget parent = None)
__init__(self, QString text, QWidget parent = None)
__init__(self, QIcon icon, QString text, QWidget parent = None)
\end{Verbatim}
我们看到按钮显示的文字和图标在这里是可以设置的。


\section{QFileDialog}
来自QtGui模块，继承自QDialog，QDialog继承自QWidget。

弹出一个文件或目录选择对话框。

简单的使用常通过静态方法来实现：
\subsection{静态方法}
更多信息请参见官方类文档。

\subsubsection{getExistingDirectory方法}
返回用户选定的已存在的目录。这里parent是对话框依附的父窗口，caption是弹出窗口的标题，directory是窗口弹出时默认打开的位置，options是？

\subsubsection{getOpenFileName方法}
返回用户选定的已存在文件。比如：
\begin{Verbatim}
filename=QtGui.QFileDialog.getOpenFileName(self,"打开文件...",".","")
\end{Verbatim}
这里filename是字符串类型，就是你选择的文件的名字（包含绝对引用地址），后面"."是当前目录的意思，在后面过滤器空字符串表示所有的文件都显示。


\section{QColorDialog类}
来自QtGui模块，继承自QDialog，QDialog继承自QWidget。

弹出一个选择颜色的窗口。

\subsection{静态方法}
\subsubsection{getColor方法}
简单的设置不给参数也是可以的。

\section{QFontDialog类}
来自QtGui模块，继承自QDialog，QDialog继承自QWidget。

弹出一个选择字体的窗口。
\subsection{静态方法}
\subsubsection{getFont方法}
简单的设置不给参数也是可以的。


\section{QMessageBox类}
来自QtGui模块，继承自QDialog，QDialog继承自QWidget。

弹出一个对话框用于用户做出一些选择或者给出一些提示信息。

\subsection{静态方法}
\subsubsection{about方法}
需要三个参数，第一个参数是窗口的依附父窗口，第二个参数是窗口的标题，第三个参数是窗口的文字信息。

\subsubsection{aboutQt方法}
最少只需要一个参数，即弹出窗口的依附父窗口。


\section{QMainWindow类}



\section{QDialog类}


\chapter{pyqt4实例}
\section{按钮打印你好}
\begin{Verbatim}
import sys
from PyQt4  import QtGui

class Mybutton(QtGui.QPushButton):
    def __init__(self,parent=None):
        QtGui.QPushButton.__init__(self,parent)
        self.resize(150, 90)
        self.center()
        self.setWindowTitle('你好')
        self.clicked.connect(self.hello)

    def center(self):
        screen = QtGui.QDesktopWidget().screenGeometry()
        size =  self.geometry()
        self.move((screen.width()-size.width())/2,\
         (screen.height()-size.height())/2)

    def hello(self):
        print('你好')

myapp = QtGui.QApplication(sys.argv)
mywidget = Mybutton()
mywidget.show()

myapp.exec_()
sys.exit()
\end{Verbatim}
这个代码最值得一提的就是pyqt4最新的信号－槽机制。就是某个对象的某个信号调用connect方法连接到某个槽上，所谓槽实际上就是定义的函数，只是这个函数没加上()圆括号，只是一个函数符号，所以称之为槽。


\section{文件对话框}
\begin{Verbatim}
import sys
from PyQt4  import QtGui

class Mybutton(QtGui.QPushButton):
    def __init__(self,parent=None):
        QtGui.QPushButton.__init__(self,"打开文件",parent)
        self.resize(150, 90)
        self.center()
        self.setWindowTitle('打开文件')
        self.clicked.connect(self.openfile)

    def center(self):
        screen = QtGui.QDesktopWidget().screenGeometry()
        size =  self.geometry()
        self.move((screen.width()-size.width())/2,\
         (screen.height()-size.height())/2)


    def openfile(self):
        filename=QtGui.QFileDialog.getOpenFileName(self,"打开文件...",".","")
        print('文件'+str(filename)+'已选择')

myapp = QtGui.QApplication(sys.argv)
mywidget = Mybutton()
mywidget.show()

myapp.exec_()
sys.exit()
\end{Verbatim}
这个例子和上面例子的区别就在于将按钮的动作改成了openfile，然后用QFileDialog的静态方法getOpenFileName来获取打开文件的对话框。


\section{更多的按钮更多的对话框}
这个例子我们在前面两个例子的基础上，加上更多的按钮并对应更多的对话框（文件选择对话框，颜色选择对话框，字体选择对话框，一般信息对话框，一般选择对话框（关闭机制））。同时引入一种简单的布局。

\begin{Verbatim}
import sys
from PyQt4  import QtGui

class Mywidget(QtGui.QWidget):
    def __init__(self,parent=None):
        QtGui.QWidget.__init__(self,parent)
        self.center()
        self.setWindowTitle('myapp')

        button1=QtGui.QPushButton("文件")
        button2=QtGui.QPushButton("颜色")
        button3=QtGui.QPushButton("字体")
        button4=QtGui.QPushButton("关于")
        button5=QtGui.QPushButton("关于Qt")
        mainlayout=QtGui.QHBoxLayout()
        mainlayout.addWidget(button1)
        mainlayout.addWidget(button2)
        mainlayout.addWidget(button3)
        mainlayout.addWidget(button4)
        mainlayout.addWidget(button5)
        self.setLayout(mainlayout)
        button1.clicked.connect(self.openfile)
        button2.clicked.connect(self.choosecolor)
        button3.clicked.connect(self.choosefont)
        button4.clicked.connect(self.about)
        button5.clicked.connect(self.aboutqt)

    def center(self):
        screen = QtGui.QDesktopWidget().screenGeometry()
        size =  self.geometry()
        self.move((screen.width()-size.width())/2,\
         (screen.height()-size.height())/2)

    def openfile(self):
        filename=QtGui.QFileDialog.getOpenFileName(self,"打开文件...",".","")
        print('文件'+str(filename)+'已选择')

    def choosecolor(self):
        colorname=QtGui.QColorDialog.getColor()
        print('颜色'+str(colorname)+'已选择')

    def choosefont(self):
        fontname=QtGui.QFontDialog.getFont()
        print('字体'+str(fontname)+'已选择')

    def about(self):
        QtGui.QMessageBox.about(self,"关于本程序","本程序用于测试按钮和对话框。")
    def aboutqt(self):
        QtGui.QMessageBox.aboutQt(self)

    def closeEvent(self, event):
        #重新定义colseEvent
        reply = QtGui.QMessageBox.question\
        (self, '信息',
            "你确定要退出吗？",
             QtGui.QMessageBox.Yes,
             QtGui.QMessageBox.No)

        if reply == QtGui.QMessageBox.Yes:
            event.accept()
        else:
            event.ignore()

myapp = QtGui.QApplication(sys.argv)
mywidget = Mywidget()
mywidget.show()
myapp.exec_()
sys.exit()
\end{Verbatim}





%这里空一行

\end{common-format}
\end{document}



